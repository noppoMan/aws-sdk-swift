//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for ElastiCache
public struct ElastiCacheErrorType: AWSErrorType {
    enum Code: String {
        case aPICallRateForCustomerExceededFault = "APICallRateForCustomerExceeded"
        case authorizationAlreadyExistsFault = "AuthorizationAlreadyExists"
        case authorizationNotFoundFault = "AuthorizationNotFound"
        case cacheClusterAlreadyExistsFault = "CacheClusterAlreadyExists"
        case cacheClusterNotFoundFault = "CacheClusterNotFound"
        case cacheParameterGroupAlreadyExistsFault = "CacheParameterGroupAlreadyExists"
        case cacheParameterGroupNotFoundFault = "CacheParameterGroupNotFound"
        case cacheParameterGroupQuotaExceededFault = "CacheParameterGroupQuotaExceeded"
        case cacheSecurityGroupAlreadyExistsFault = "CacheSecurityGroupAlreadyExists"
        case cacheSecurityGroupNotFoundFault = "CacheSecurityGroupNotFound"
        case cacheSecurityGroupQuotaExceededFault = "QuotaExceeded.CacheSecurityGroup"
        case cacheSubnetGroupAlreadyExistsFault = "CacheSubnetGroupAlreadyExists"
        case cacheSubnetGroupInUse = "CacheSubnetGroupInUse"
        case cacheSubnetGroupNotFoundFault = "CacheSubnetGroupNotFoundFault"
        case cacheSubnetGroupQuotaExceededFault = "CacheSubnetGroupQuotaExceeded"
        case cacheSubnetQuotaExceededFault = "CacheSubnetQuotaExceededFault"
        case clusterQuotaForCustomerExceededFault = "ClusterQuotaForCustomerExceeded"
        case globalReplicationGroupAlreadyExistsFault = "GlobalReplicationGroupAlreadyExistsFault"
        case globalReplicationGroupNotFoundFault = "GlobalReplicationGroupNotFoundFault"
        case insufficientCacheClusterCapacityFault = "InsufficientCacheClusterCapacity"
        case invalidARNFault = "InvalidARN"
        case invalidCacheClusterStateFault = "InvalidCacheClusterState"
        case invalidCacheParameterGroupStateFault = "InvalidCacheParameterGroupState"
        case invalidCacheSecurityGroupStateFault = "InvalidCacheSecurityGroupState"
        case invalidGlobalReplicationGroupStateFault = "InvalidGlobalReplicationGroupState"
        case invalidKMSKeyFault = "InvalidKMSKeyFault"
        case invalidParameterCombinationException = "InvalidParameterCombination"
        case invalidParameterValueException = "InvalidParameterValue"
        case invalidReplicationGroupStateFault = "InvalidReplicationGroupState"
        case invalidSnapshotStateFault = "InvalidSnapshotState"
        case invalidSubnet = "InvalidSubnet"
        case invalidVPCNetworkStateFault = "InvalidVPCNetworkStateFault"
        case noOperationFault = "NoOperationFault"
        case nodeGroupNotFoundFault = "NodeGroupNotFoundFault"
        case nodeGroupsPerReplicationGroupQuotaExceededFault = "NodeGroupsPerReplicationGroupQuotaExceeded"
        case nodeQuotaForClusterExceededFault = "NodeQuotaForClusterExceeded"
        case nodeQuotaForCustomerExceededFault = "NodeQuotaForCustomerExceeded"
        case replicationGroupAlreadyExistsFault = "ReplicationGroupAlreadyExists"
        case replicationGroupAlreadyUnderMigrationFault = "ReplicationGroupAlreadyUnderMigrationFault"
        case replicationGroupNotFoundFault = "ReplicationGroupNotFoundFault"
        case replicationGroupNotUnderMigrationFault = "ReplicationGroupNotUnderMigrationFault"
        case reservedCacheNodeAlreadyExistsFault = "ReservedCacheNodeAlreadyExists"
        case reservedCacheNodeNotFoundFault = "ReservedCacheNodeNotFound"
        case reservedCacheNodeQuotaExceededFault = "ReservedCacheNodeQuotaExceeded"
        case reservedCacheNodesOfferingNotFoundFault = "ReservedCacheNodesOfferingNotFound"
        case serviceLinkedRoleNotFoundFault = "ServiceLinkedRoleNotFoundFault"
        case serviceUpdateNotFoundFault = "ServiceUpdateNotFoundFault"
        case snapshotAlreadyExistsFault = "SnapshotAlreadyExistsFault"
        case snapshotFeatureNotSupportedFault = "SnapshotFeatureNotSupportedFault"
        case snapshotNotFoundFault = "SnapshotNotFoundFault"
        case snapshotQuotaExceededFault = "SnapshotQuotaExceededFault"
        case subnetInUse = "SubnetInUse"
        case tagNotFoundFault = "TagNotFound"
        case tagQuotaPerResourceExceeded = "TagQuotaPerResourceExceeded"
        case testFailoverNotAvailableFault = "TestFailoverNotAvailableFault"
    }

    private var error: Code
    public var message: String?

    public init?(errorCode: String, message: String?) {
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.message = message
    }

    internal init(_ error: Code) {
        self.error = error
        self.message = nil
    }

    public static var aPICallRateForCustomerExceededFault: Self { .init(.aPICallRateForCustomerExceededFault) }
    public static var authorizationAlreadyExistsFault: Self { .init(.authorizationAlreadyExistsFault) }
    public static var authorizationNotFoundFault: Self { .init(.authorizationNotFoundFault) }
    public static var cacheClusterAlreadyExistsFault: Self { .init(.cacheClusterAlreadyExistsFault) }
    public static var cacheClusterNotFoundFault: Self { .init(.cacheClusterNotFoundFault) }
    public static var cacheParameterGroupAlreadyExistsFault: Self { .init(.cacheParameterGroupAlreadyExistsFault) }
    public static var cacheParameterGroupNotFoundFault: Self { .init(.cacheParameterGroupNotFoundFault) }
    public static var cacheParameterGroupQuotaExceededFault: Self { .init(.cacheParameterGroupQuotaExceededFault) }
    public static var cacheSecurityGroupAlreadyExistsFault: Self { .init(.cacheSecurityGroupAlreadyExistsFault) }
    public static var cacheSecurityGroupNotFoundFault: Self { .init(.cacheSecurityGroupNotFoundFault) }
    public static var cacheSecurityGroupQuotaExceededFault: Self { .init(.cacheSecurityGroupQuotaExceededFault) }
    public static var cacheSubnetGroupAlreadyExistsFault: Self { .init(.cacheSubnetGroupAlreadyExistsFault) }
    public static var cacheSubnetGroupInUse: Self { .init(.cacheSubnetGroupInUse) }
    public static var cacheSubnetGroupNotFoundFault: Self { .init(.cacheSubnetGroupNotFoundFault) }
    public static var cacheSubnetGroupQuotaExceededFault: Self { .init(.cacheSubnetGroupQuotaExceededFault) }
    public static var cacheSubnetQuotaExceededFault: Self { .init(.cacheSubnetQuotaExceededFault) }
    public static var clusterQuotaForCustomerExceededFault: Self { .init(.clusterQuotaForCustomerExceededFault) }
    public static var globalReplicationGroupAlreadyExistsFault: Self { .init(.globalReplicationGroupAlreadyExistsFault) }
    public static var globalReplicationGroupNotFoundFault: Self { .init(.globalReplicationGroupNotFoundFault) }
    public static var insufficientCacheClusterCapacityFault: Self { .init(.insufficientCacheClusterCapacityFault) }
    public static var invalidARNFault: Self { .init(.invalidARNFault) }
    public static var invalidCacheClusterStateFault: Self { .init(.invalidCacheClusterStateFault) }
    public static var invalidCacheParameterGroupStateFault: Self { .init(.invalidCacheParameterGroupStateFault) }
    public static var invalidCacheSecurityGroupStateFault: Self { .init(.invalidCacheSecurityGroupStateFault) }
    public static var invalidGlobalReplicationGroupStateFault: Self { .init(.invalidGlobalReplicationGroupStateFault) }
    public static var invalidKMSKeyFault: Self { .init(.invalidKMSKeyFault) }
    public static var invalidParameterCombinationException: Self { .init(.invalidParameterCombinationException) }
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    public static var invalidReplicationGroupStateFault: Self { .init(.invalidReplicationGroupStateFault) }
    public static var invalidSnapshotStateFault: Self { .init(.invalidSnapshotStateFault) }
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    public static var invalidVPCNetworkStateFault: Self { .init(.invalidVPCNetworkStateFault) }
    public static var noOperationFault: Self { .init(.noOperationFault) }
    public static var nodeGroupNotFoundFault: Self { .init(.nodeGroupNotFoundFault) }
    public static var nodeGroupsPerReplicationGroupQuotaExceededFault: Self { .init(.nodeGroupsPerReplicationGroupQuotaExceededFault) }
    public static var nodeQuotaForClusterExceededFault: Self { .init(.nodeQuotaForClusterExceededFault) }
    public static var nodeQuotaForCustomerExceededFault: Self { .init(.nodeQuotaForCustomerExceededFault) }
    public static var replicationGroupAlreadyExistsFault: Self { .init(.replicationGroupAlreadyExistsFault) }
    public static var replicationGroupAlreadyUnderMigrationFault: Self { .init(.replicationGroupAlreadyUnderMigrationFault) }
    public static var replicationGroupNotFoundFault: Self { .init(.replicationGroupNotFoundFault) }
    public static var replicationGroupNotUnderMigrationFault: Self { .init(.replicationGroupNotUnderMigrationFault) }
    public static var reservedCacheNodeAlreadyExistsFault: Self { .init(.reservedCacheNodeAlreadyExistsFault) }
    public static var reservedCacheNodeNotFoundFault: Self { .init(.reservedCacheNodeNotFoundFault) }
    public static var reservedCacheNodeQuotaExceededFault: Self { .init(.reservedCacheNodeQuotaExceededFault) }
    public static var reservedCacheNodesOfferingNotFoundFault: Self { .init(.reservedCacheNodesOfferingNotFoundFault) }
    public static var serviceLinkedRoleNotFoundFault: Self { .init(.serviceLinkedRoleNotFoundFault) }
    public static var serviceUpdateNotFoundFault: Self { .init(.serviceUpdateNotFoundFault) }
    public static var snapshotAlreadyExistsFault: Self { .init(.snapshotAlreadyExistsFault) }
    public static var snapshotFeatureNotSupportedFault: Self { .init(.snapshotFeatureNotSupportedFault) }
    public static var snapshotNotFoundFault: Self { .init(.snapshotNotFoundFault) }
    public static var snapshotQuotaExceededFault: Self { .init(.snapshotQuotaExceededFault) }
    public static var subnetInUse: Self { .init(.subnetInUse) }
    public static var tagNotFoundFault: Self { .init(.tagNotFoundFault) }
    public static var tagQuotaPerResourceExceeded: Self { .init(.tagQuotaPerResourceExceeded) }
    public static var testFailoverNotAvailableFault: Self { .init(.testFailoverNotAvailableFault) }
}

extension ElastiCacheErrorType: Equatable {
    public static func == (lhs: ElastiCacheErrorType, rhs: ElastiCacheErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ElastiCacheErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}

//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for CodeDeploy
public struct CodeDeployErrorType: AWSErrorType {
    enum Code: String {
        case alarmsLimitExceededException = "AlarmsLimitExceededException"
        case applicationAlreadyExistsException = "ApplicationAlreadyExistsException"
        case applicationDoesNotExistException = "ApplicationDoesNotExistException"
        case applicationLimitExceededException = "ApplicationLimitExceededException"
        case applicationNameRequiredException = "ApplicationNameRequiredException"
        case arnNotSupportedException = "ArnNotSupportedException"
        case batchLimitExceededException = "BatchLimitExceededException"
        case bucketNameFilterRequiredException = "BucketNameFilterRequiredException"
        case deploymentAlreadyCompletedException = "DeploymentAlreadyCompletedException"
        case deploymentConfigAlreadyExistsException = "DeploymentConfigAlreadyExistsException"
        case deploymentConfigDoesNotExistException = "DeploymentConfigDoesNotExistException"
        case deploymentConfigInUseException = "DeploymentConfigInUseException"
        case deploymentConfigLimitExceededException = "DeploymentConfigLimitExceededException"
        case deploymentConfigNameRequiredException = "DeploymentConfigNameRequiredException"
        case deploymentDoesNotExistException = "DeploymentDoesNotExistException"
        case deploymentGroupAlreadyExistsException = "DeploymentGroupAlreadyExistsException"
        case deploymentGroupDoesNotExistException = "DeploymentGroupDoesNotExistException"
        case deploymentGroupLimitExceededException = "DeploymentGroupLimitExceededException"
        case deploymentGroupNameRequiredException = "DeploymentGroupNameRequiredException"
        case deploymentIdRequiredException = "DeploymentIdRequiredException"
        case deploymentIsNotInReadyStateException = "DeploymentIsNotInReadyStateException"
        case deploymentLimitExceededException = "DeploymentLimitExceededException"
        case deploymentNotStartedException = "DeploymentNotStartedException"
        case deploymentTargetDoesNotExistException = "DeploymentTargetDoesNotExistException"
        case deploymentTargetIdRequiredException = "DeploymentTargetIdRequiredException"
        case deploymentTargetListSizeExceededException = "DeploymentTargetListSizeExceededException"
        case descriptionTooLongException = "DescriptionTooLongException"
        case eCSServiceMappingLimitExceededException = "ECSServiceMappingLimitExceededException"
        case gitHubAccountTokenDoesNotExistException = "GitHubAccountTokenDoesNotExistException"
        case gitHubAccountTokenNameRequiredException = "GitHubAccountTokenNameRequiredException"
        case iamArnRequiredException = "IamArnRequiredException"
        case iamSessionArnAlreadyRegisteredException = "IamSessionArnAlreadyRegisteredException"
        case iamUserArnAlreadyRegisteredException = "IamUserArnAlreadyRegisteredException"
        case iamUserArnRequiredException = "IamUserArnRequiredException"
        case instanceDoesNotExistException = "InstanceDoesNotExistException"
        case instanceIdRequiredException = "InstanceIdRequiredException"
        case instanceLimitExceededException = "InstanceLimitExceededException"
        case instanceNameAlreadyRegisteredException = "InstanceNameAlreadyRegisteredException"
        case instanceNameRequiredException = "InstanceNameRequiredException"
        case instanceNotRegisteredException = "InstanceNotRegisteredException"
        case invalidAlarmConfigException = "InvalidAlarmConfigException"
        case invalidApplicationNameException = "InvalidApplicationNameException"
        case invalidArnException = "InvalidArnException"
        case invalidAutoRollbackConfigException = "InvalidAutoRollbackConfigException"
        case invalidAutoScalingGroupException = "InvalidAutoScalingGroupException"
        case invalidBlueGreenDeploymentConfigurationException = "InvalidBlueGreenDeploymentConfigurationException"
        case invalidBucketNameFilterException = "InvalidBucketNameFilterException"
        case invalidComputePlatformException = "InvalidComputePlatformException"
        case invalidDeployedStateFilterException = "InvalidDeployedStateFilterException"
        case invalidDeploymentConfigNameException = "InvalidDeploymentConfigNameException"
        case invalidDeploymentGroupNameException = "InvalidDeploymentGroupNameException"
        case invalidDeploymentIdException = "InvalidDeploymentIdException"
        case invalidDeploymentInstanceTypeException = "InvalidDeploymentInstanceTypeException"
        case invalidDeploymentStatusException = "InvalidDeploymentStatusException"
        case invalidDeploymentStyleException = "InvalidDeploymentStyleException"
        case invalidDeploymentTargetIdException = "InvalidDeploymentTargetIdException"
        case invalidDeploymentWaitTypeException = "InvalidDeploymentWaitTypeException"
        case invalidEC2TagCombinationException = "InvalidEC2TagCombinationException"
        case invalidEC2TagException = "InvalidEC2TagException"
        case invalidECSServiceException = "InvalidECSServiceException"
        case invalidExternalIdException = "InvalidExternalIdException"
        case invalidFileExistsBehaviorException = "InvalidFileExistsBehaviorException"
        case invalidGitHubAccountTokenException = "InvalidGitHubAccountTokenException"
        case invalidGitHubAccountTokenNameException = "InvalidGitHubAccountTokenNameException"
        case invalidIamSessionArnException = "InvalidIamSessionArnException"
        case invalidIamUserArnException = "InvalidIamUserArnException"
        case invalidIgnoreApplicationStopFailuresValueException = "InvalidIgnoreApplicationStopFailuresValueException"
        case invalidInputException = "InvalidInputException"
        case invalidInstanceNameException = "InvalidInstanceNameException"
        case invalidInstanceStatusException = "InvalidInstanceStatusException"
        case invalidInstanceTypeException = "InvalidInstanceTypeException"
        case invalidKeyPrefixFilterException = "InvalidKeyPrefixFilterException"
        case invalidLifecycleEventHookExecutionIdException = "InvalidLifecycleEventHookExecutionIdException"
        case invalidLifecycleEventHookExecutionStatusException = "InvalidLifecycleEventHookExecutionStatusException"
        case invalidLoadBalancerInfoException = "InvalidLoadBalancerInfoException"
        case invalidMinimumHealthyHostValueException = "InvalidMinimumHealthyHostValueException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case invalidOnPremisesTagCombinationException = "InvalidOnPremisesTagCombinationException"
        case invalidOperationException = "InvalidOperationException"
        case invalidRegistrationStatusException = "InvalidRegistrationStatusException"
        case invalidRevisionException = "InvalidRevisionException"
        case invalidRoleException = "InvalidRoleException"
        case invalidSortByException = "InvalidSortByException"
        case invalidSortOrderException = "InvalidSortOrderException"
        case invalidTagException = "InvalidTagException"
        case invalidTagFilterException = "InvalidTagFilterException"
        case invalidTagsToAddException = "InvalidTagsToAddException"
        case invalidTargetFilterNameException = "InvalidTargetFilterNameException"
        case invalidTargetGroupPairException = "InvalidTargetGroupPairException"
        case invalidTargetInstancesException = "InvalidTargetInstancesException"
        case invalidTimeRangeException = "InvalidTimeRangeException"
        case invalidTrafficRoutingConfigurationException = "InvalidTrafficRoutingConfigurationException"
        case invalidTriggerConfigException = "InvalidTriggerConfigException"
        case invalidUpdateOutdatedInstancesOnlyValueException = "InvalidUpdateOutdatedInstancesOnlyValueException"
        case lifecycleEventAlreadyCompletedException = "LifecycleEventAlreadyCompletedException"
        case lifecycleHookLimitExceededException = "LifecycleHookLimitExceededException"
        case multipleIamArnsProvidedException = "MultipleIamArnsProvidedException"
        case operationNotSupportedException = "OperationNotSupportedException"
        case resourceArnRequiredException = "ResourceArnRequiredException"
        case resourceValidationException = "ResourceValidationException"
        case revisionDoesNotExistException = "RevisionDoesNotExistException"
        case revisionRequiredException = "RevisionRequiredException"
        case roleRequiredException = "RoleRequiredException"
        case tagLimitExceededException = "TagLimitExceededException"
        case tagRequiredException = "TagRequiredException"
        case tagSetListLimitExceededException = "TagSetListLimitExceededException"
        case throttlingException = "ThrottlingException"
        case triggerTargetsLimitExceededException = "TriggerTargetsLimitExceededException"
        case unsupportedActionForDeploymentTypeException = "UnsupportedActionForDeploymentTypeException"
    }

    private var error: Code
    public var message: String?

    public init?(errorCode: String, message: String?) {
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.message = message
    }

    internal init(_ error: Code) {
        self.error = error
        self.message = nil
    }

    public static var alarmsLimitExceededException: Self { .init(.alarmsLimitExceededException) }
    public static var applicationAlreadyExistsException: Self { .init(.applicationAlreadyExistsException) }
    public static var applicationDoesNotExistException: Self { .init(.applicationDoesNotExistException) }
    public static var applicationLimitExceededException: Self { .init(.applicationLimitExceededException) }
    public static var applicationNameRequiredException: Self { .init(.applicationNameRequiredException) }
    public static var arnNotSupportedException: Self { .init(.arnNotSupportedException) }
    public static var batchLimitExceededException: Self { .init(.batchLimitExceededException) }
    public static var bucketNameFilterRequiredException: Self { .init(.bucketNameFilterRequiredException) }
    public static var deploymentAlreadyCompletedException: Self { .init(.deploymentAlreadyCompletedException) }
    public static var deploymentConfigAlreadyExistsException: Self { .init(.deploymentConfigAlreadyExistsException) }
    public static var deploymentConfigDoesNotExistException: Self { .init(.deploymentConfigDoesNotExistException) }
    public static var deploymentConfigInUseException: Self { .init(.deploymentConfigInUseException) }
    public static var deploymentConfigLimitExceededException: Self { .init(.deploymentConfigLimitExceededException) }
    public static var deploymentConfigNameRequiredException: Self { .init(.deploymentConfigNameRequiredException) }
    public static var deploymentDoesNotExistException: Self { .init(.deploymentDoesNotExistException) }
    public static var deploymentGroupAlreadyExistsException: Self { .init(.deploymentGroupAlreadyExistsException) }
    public static var deploymentGroupDoesNotExistException: Self { .init(.deploymentGroupDoesNotExistException) }
    public static var deploymentGroupLimitExceededException: Self { .init(.deploymentGroupLimitExceededException) }
    public static var deploymentGroupNameRequiredException: Self { .init(.deploymentGroupNameRequiredException) }
    public static var deploymentIdRequiredException: Self { .init(.deploymentIdRequiredException) }
    public static var deploymentIsNotInReadyStateException: Self { .init(.deploymentIsNotInReadyStateException) }
    public static var deploymentLimitExceededException: Self { .init(.deploymentLimitExceededException) }
    public static var deploymentNotStartedException: Self { .init(.deploymentNotStartedException) }
    public static var deploymentTargetDoesNotExistException: Self { .init(.deploymentTargetDoesNotExistException) }
    public static var deploymentTargetIdRequiredException: Self { .init(.deploymentTargetIdRequiredException) }
    public static var deploymentTargetListSizeExceededException: Self { .init(.deploymentTargetListSizeExceededException) }
    public static var descriptionTooLongException: Self { .init(.descriptionTooLongException) }
    public static var eCSServiceMappingLimitExceededException: Self { .init(.eCSServiceMappingLimitExceededException) }
    public static var gitHubAccountTokenDoesNotExistException: Self { .init(.gitHubAccountTokenDoesNotExistException) }
    public static var gitHubAccountTokenNameRequiredException: Self { .init(.gitHubAccountTokenNameRequiredException) }
    public static var iamArnRequiredException: Self { .init(.iamArnRequiredException) }
    public static var iamSessionArnAlreadyRegisteredException: Self { .init(.iamSessionArnAlreadyRegisteredException) }
    public static var iamUserArnAlreadyRegisteredException: Self { .init(.iamUserArnAlreadyRegisteredException) }
    public static var iamUserArnRequiredException: Self { .init(.iamUserArnRequiredException) }
    public static var instanceDoesNotExistException: Self { .init(.instanceDoesNotExistException) }
    public static var instanceIdRequiredException: Self { .init(.instanceIdRequiredException) }
    public static var instanceLimitExceededException: Self { .init(.instanceLimitExceededException) }
    public static var instanceNameAlreadyRegisteredException: Self { .init(.instanceNameAlreadyRegisteredException) }
    public static var instanceNameRequiredException: Self { .init(.instanceNameRequiredException) }
    public static var instanceNotRegisteredException: Self { .init(.instanceNotRegisteredException) }
    public static var invalidAlarmConfigException: Self { .init(.invalidAlarmConfigException) }
    public static var invalidApplicationNameException: Self { .init(.invalidApplicationNameException) }
    public static var invalidArnException: Self { .init(.invalidArnException) }
    public static var invalidAutoRollbackConfigException: Self { .init(.invalidAutoRollbackConfigException) }
    public static var invalidAutoScalingGroupException: Self { .init(.invalidAutoScalingGroupException) }
    public static var invalidBlueGreenDeploymentConfigurationException: Self { .init(.invalidBlueGreenDeploymentConfigurationException) }
    public static var invalidBucketNameFilterException: Self { .init(.invalidBucketNameFilterException) }
    public static var invalidComputePlatformException: Self { .init(.invalidComputePlatformException) }
    public static var invalidDeployedStateFilterException: Self { .init(.invalidDeployedStateFilterException) }
    public static var invalidDeploymentConfigNameException: Self { .init(.invalidDeploymentConfigNameException) }
    public static var invalidDeploymentGroupNameException: Self { .init(.invalidDeploymentGroupNameException) }
    public static var invalidDeploymentIdException: Self { .init(.invalidDeploymentIdException) }
    public static var invalidDeploymentInstanceTypeException: Self { .init(.invalidDeploymentInstanceTypeException) }
    public static var invalidDeploymentStatusException: Self { .init(.invalidDeploymentStatusException) }
    public static var invalidDeploymentStyleException: Self { .init(.invalidDeploymentStyleException) }
    public static var invalidDeploymentTargetIdException: Self { .init(.invalidDeploymentTargetIdException) }
    public static var invalidDeploymentWaitTypeException: Self { .init(.invalidDeploymentWaitTypeException) }
    public static var invalidEC2TagCombinationException: Self { .init(.invalidEC2TagCombinationException) }
    public static var invalidEC2TagException: Self { .init(.invalidEC2TagException) }
    public static var invalidECSServiceException: Self { .init(.invalidECSServiceException) }
    public static var invalidExternalIdException: Self { .init(.invalidExternalIdException) }
    public static var invalidFileExistsBehaviorException: Self { .init(.invalidFileExistsBehaviorException) }
    public static var invalidGitHubAccountTokenException: Self { .init(.invalidGitHubAccountTokenException) }
    public static var invalidGitHubAccountTokenNameException: Self { .init(.invalidGitHubAccountTokenNameException) }
    public static var invalidIamSessionArnException: Self { .init(.invalidIamSessionArnException) }
    public static var invalidIamUserArnException: Self { .init(.invalidIamUserArnException) }
    public static var invalidIgnoreApplicationStopFailuresValueException: Self { .init(.invalidIgnoreApplicationStopFailuresValueException) }
    public static var invalidInputException: Self { .init(.invalidInputException) }
    public static var invalidInstanceNameException: Self { .init(.invalidInstanceNameException) }
    public static var invalidInstanceStatusException: Self { .init(.invalidInstanceStatusException) }
    public static var invalidInstanceTypeException: Self { .init(.invalidInstanceTypeException) }
    public static var invalidKeyPrefixFilterException: Self { .init(.invalidKeyPrefixFilterException) }
    public static var invalidLifecycleEventHookExecutionIdException: Self { .init(.invalidLifecycleEventHookExecutionIdException) }
    public static var invalidLifecycleEventHookExecutionStatusException: Self { .init(.invalidLifecycleEventHookExecutionStatusException) }
    public static var invalidLoadBalancerInfoException: Self { .init(.invalidLoadBalancerInfoException) }
    public static var invalidMinimumHealthyHostValueException: Self { .init(.invalidMinimumHealthyHostValueException) }
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    public static var invalidOnPremisesTagCombinationException: Self { .init(.invalidOnPremisesTagCombinationException) }
    public static var invalidOperationException: Self { .init(.invalidOperationException) }
    public static var invalidRegistrationStatusException: Self { .init(.invalidRegistrationStatusException) }
    public static var invalidRevisionException: Self { .init(.invalidRevisionException) }
    public static var invalidRoleException: Self { .init(.invalidRoleException) }
    public static var invalidSortByException: Self { .init(.invalidSortByException) }
    public static var invalidSortOrderException: Self { .init(.invalidSortOrderException) }
    public static var invalidTagException: Self { .init(.invalidTagException) }
    public static var invalidTagFilterException: Self { .init(.invalidTagFilterException) }
    public static var invalidTagsToAddException: Self { .init(.invalidTagsToAddException) }
    public static var invalidTargetFilterNameException: Self { .init(.invalidTargetFilterNameException) }
    public static var invalidTargetGroupPairException: Self { .init(.invalidTargetGroupPairException) }
    public static var invalidTargetInstancesException: Self { .init(.invalidTargetInstancesException) }
    public static var invalidTimeRangeException: Self { .init(.invalidTimeRangeException) }
    public static var invalidTrafficRoutingConfigurationException: Self { .init(.invalidTrafficRoutingConfigurationException) }
    public static var invalidTriggerConfigException: Self { .init(.invalidTriggerConfigException) }
    public static var invalidUpdateOutdatedInstancesOnlyValueException: Self { .init(.invalidUpdateOutdatedInstancesOnlyValueException) }
    public static var lifecycleEventAlreadyCompletedException: Self { .init(.lifecycleEventAlreadyCompletedException) }
    public static var lifecycleHookLimitExceededException: Self { .init(.lifecycleHookLimitExceededException) }
    public static var multipleIamArnsProvidedException: Self { .init(.multipleIamArnsProvidedException) }
    public static var operationNotSupportedException: Self { .init(.operationNotSupportedException) }
    public static var resourceArnRequiredException: Self { .init(.resourceArnRequiredException) }
    public static var resourceValidationException: Self { .init(.resourceValidationException) }
    public static var revisionDoesNotExistException: Self { .init(.revisionDoesNotExistException) }
    public static var revisionRequiredException: Self { .init(.revisionRequiredException) }
    public static var roleRequiredException: Self { .init(.roleRequiredException) }
    public static var tagLimitExceededException: Self { .init(.tagLimitExceededException) }
    public static var tagRequiredException: Self { .init(.tagRequiredException) }
    public static var tagSetListLimitExceededException: Self { .init(.tagSetListLimitExceededException) }
    public static var throttlingException: Self { .init(.throttlingException) }
    public static var triggerTargetsLimitExceededException: Self { .init(.triggerTargetsLimitExceededException) }
    public static var unsupportedActionForDeploymentTypeException: Self { .init(.unsupportedActionForDeploymentTypeException) }
}

extension CodeDeployErrorType: Equatable {
    public static func == (lhs: CodeDeployErrorType, rhs: CodeDeployErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CodeDeployErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}

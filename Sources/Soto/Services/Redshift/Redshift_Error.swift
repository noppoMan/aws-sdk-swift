//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for Redshift
public struct RedshiftErrorType: AWSErrorType {
    enum Code: String {
        case accessToSnapshotDeniedFault = "AccessToSnapshotDenied"
        case authorizationAlreadyExistsFault = "AuthorizationAlreadyExists"
        case authorizationNotFoundFault = "AuthorizationNotFound"
        case authorizationQuotaExceededFault = "AuthorizationQuotaExceeded"
        case batchDeleteRequestSizeExceededFault = "BatchDeleteRequestSizeExceeded"
        case batchModifyClusterSnapshotsLimitExceededFault = "BatchModifyClusterSnapshotsLimitExceededFault"
        case bucketNotFoundFault = "BucketNotFoundFault"
        case clusterAlreadyExistsFault = "ClusterAlreadyExists"
        case clusterNotFoundFault = "ClusterNotFound"
        case clusterOnLatestRevisionFault = "ClusterOnLatestRevision"
        case clusterParameterGroupAlreadyExistsFault = "ClusterParameterGroupAlreadyExists"
        case clusterParameterGroupNotFoundFault = "ClusterParameterGroupNotFound"
        case clusterParameterGroupQuotaExceededFault = "ClusterParameterGroupQuotaExceeded"
        case clusterQuotaExceededFault = "ClusterQuotaExceeded"
        case clusterSecurityGroupAlreadyExistsFault = "ClusterSecurityGroupAlreadyExists"
        case clusterSecurityGroupNotFoundFault = "ClusterSecurityGroupNotFound"
        case clusterSecurityGroupQuotaExceededFault = "QuotaExceeded.ClusterSecurityGroup"
        case clusterSnapshotAlreadyExistsFault = "ClusterSnapshotAlreadyExists"
        case clusterSnapshotNotFoundFault = "ClusterSnapshotNotFound"
        case clusterSnapshotQuotaExceededFault = "ClusterSnapshotQuotaExceeded"
        case clusterSubnetGroupAlreadyExistsFault = "ClusterSubnetGroupAlreadyExists"
        case clusterSubnetGroupNotFoundFault = "ClusterSubnetGroupNotFoundFault"
        case clusterSubnetGroupQuotaExceededFault = "ClusterSubnetGroupQuotaExceeded"
        case clusterSubnetQuotaExceededFault = "ClusterSubnetQuotaExceededFault"
        case copyToRegionDisabledFault = "CopyToRegionDisabledFault"
        case dependentServiceRequestThrottlingFault = "DependentServiceRequestThrottlingFault"
        case dependentServiceUnavailableFault = "DependentServiceUnavailableFault"
        case eventSubscriptionQuotaExceededFault = "EventSubscriptionQuotaExceeded"
        case hsmClientCertificateAlreadyExistsFault = "HsmClientCertificateAlreadyExistsFault"
        case hsmClientCertificateNotFoundFault = "HsmClientCertificateNotFoundFault"
        case hsmClientCertificateQuotaExceededFault = "HsmClientCertificateQuotaExceededFault"
        case hsmConfigurationAlreadyExistsFault = "HsmConfigurationAlreadyExistsFault"
        case hsmConfigurationNotFoundFault = "HsmConfigurationNotFoundFault"
        case hsmConfigurationQuotaExceededFault = "HsmConfigurationQuotaExceededFault"
        case inProgressTableRestoreQuotaExceededFault = "InProgressTableRestoreQuotaExceededFault"
        case incompatibleOrderableOptions = "IncompatibleOrderableOptions"
        case insufficientClusterCapacityFault = "InsufficientClusterCapacity"
        case insufficientS3BucketPolicyFault = "InsufficientS3BucketPolicyFault"
        case invalidClusterParameterGroupStateFault = "InvalidClusterParameterGroupState"
        case invalidClusterSecurityGroupStateFault = "InvalidClusterSecurityGroupState"
        case invalidClusterSnapshotScheduleStateFault = "InvalidClusterSnapshotScheduleState"
        case invalidClusterSnapshotStateFault = "InvalidClusterSnapshotState"
        case invalidClusterStateFault = "InvalidClusterState"
        case invalidClusterSubnetGroupStateFault = "InvalidClusterSubnetGroupStateFault"
        case invalidClusterSubnetStateFault = "InvalidClusterSubnetStateFault"
        case invalidClusterTrackFault = "InvalidClusterTrack"
        case invalidElasticIpFault = "InvalidElasticIpFault"
        case invalidHsmClientCertificateStateFault = "InvalidHsmClientCertificateStateFault"
        case invalidHsmConfigurationStateFault = "InvalidHsmConfigurationStateFault"
        case invalidReservedNodeStateFault = "InvalidReservedNodeState"
        case invalidRestoreFault = "InvalidRestore"
        case invalidRetentionPeriodFault = "InvalidRetentionPeriodFault"
        case invalidS3BucketNameFault = "InvalidS3BucketNameFault"
        case invalidS3KeyPrefixFault = "InvalidS3KeyPrefixFault"
        case invalidScheduleFault = "InvalidSchedule"
        case invalidScheduledActionFault = "InvalidScheduledAction"
        case invalidSnapshotCopyGrantStateFault = "InvalidSnapshotCopyGrantStateFault"
        case invalidSubnet = "InvalidSubnet"
        case invalidSubscriptionStateFault = "InvalidSubscriptionStateFault"
        case invalidTableRestoreArgumentFault = "InvalidTableRestoreArgument"
        case invalidTagFault = "InvalidTagFault"
        case invalidUsageLimitFault = "InvalidUsageLimit"
        case invalidVPCNetworkStateFault = "InvalidVPCNetworkStateFault"
        case limitExceededFault = "LimitExceededFault"
        case numberOfNodesPerClusterLimitExceededFault = "NumberOfNodesPerClusterLimitExceeded"
        case numberOfNodesQuotaExceededFault = "NumberOfNodesQuotaExceeded"
        case reservedNodeAlreadyExistsFault = "ReservedNodeAlreadyExists"
        case reservedNodeAlreadyMigratedFault = "ReservedNodeAlreadyMigrated"
        case reservedNodeNotFoundFault = "ReservedNodeNotFound"
        case reservedNodeOfferingNotFoundFault = "ReservedNodeOfferingNotFound"
        case reservedNodeQuotaExceededFault = "ReservedNodeQuotaExceeded"
        case resizeNotFoundFault = "ResizeNotFound"
        case resourceNotFoundFault = "ResourceNotFoundFault"
        case sNSInvalidTopicFault = "SNSInvalidTopic"
        case sNSNoAuthorizationFault = "SNSNoAuthorization"
        case sNSTopicArnNotFoundFault = "SNSTopicArnNotFound"
        case scheduleDefinitionTypeUnsupportedFault = "ScheduleDefinitionTypeUnsupported"
        case scheduledActionAlreadyExistsFault = "ScheduledActionAlreadyExists"
        case scheduledActionNotFoundFault = "ScheduledActionNotFound"
        case scheduledActionQuotaExceededFault = "ScheduledActionQuotaExceeded"
        case scheduledActionTypeUnsupportedFault = "ScheduledActionTypeUnsupported"
        case snapshotCopyAlreadyDisabledFault = "SnapshotCopyAlreadyDisabledFault"
        case snapshotCopyAlreadyEnabledFault = "SnapshotCopyAlreadyEnabledFault"
        case snapshotCopyDisabledFault = "SnapshotCopyDisabledFault"
        case snapshotCopyGrantAlreadyExistsFault = "SnapshotCopyGrantAlreadyExistsFault"
        case snapshotCopyGrantNotFoundFault = "SnapshotCopyGrantNotFoundFault"
        case snapshotCopyGrantQuotaExceededFault = "SnapshotCopyGrantQuotaExceededFault"
        case snapshotScheduleAlreadyExistsFault = "SnapshotScheduleAlreadyExists"
        case snapshotScheduleNotFoundFault = "SnapshotScheduleNotFound"
        case snapshotScheduleQuotaExceededFault = "SnapshotScheduleQuotaExceeded"
        case snapshotScheduleUpdateInProgressFault = "SnapshotScheduleUpdateInProgress"
        case sourceNotFoundFault = "SourceNotFound"
        case subnetAlreadyInUse = "SubnetAlreadyInUse"
        case subscriptionAlreadyExistFault = "SubscriptionAlreadyExist"
        case subscriptionCategoryNotFoundFault = "SubscriptionCategoryNotFound"
        case subscriptionEventIdNotFoundFault = "SubscriptionEventIdNotFound"
        case subscriptionNotFoundFault = "SubscriptionNotFound"
        case subscriptionSeverityNotFoundFault = "SubscriptionSeverityNotFound"
        case tableLimitExceededFault = "TableLimitExceeded"
        case tableRestoreNotFoundFault = "TableRestoreNotFoundFault"
        case tagLimitExceededFault = "TagLimitExceededFault"
        case unauthorizedOperation = "UnauthorizedOperation"
        case unknownSnapshotCopyRegionFault = "UnknownSnapshotCopyRegionFault"
        case unsupportedOperationFault = "UnsupportedOperation"
        case unsupportedOptionFault = "UnsupportedOptionFault"
        case usageLimitAlreadyExistsFault = "UsageLimitAlreadyExists"
        case usageLimitNotFoundFault = "UsageLimitNotFound"
    }

    private var error: Code
    public var message: String?

    public init?(errorCode: String, message: String?) {
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.message = message
    }

    internal init(_ error: Code) {
        self.error = error
        self.message = nil
    }

    public static var accessToSnapshotDeniedFault: Self { .init(.accessToSnapshotDeniedFault) }
    public static var authorizationAlreadyExistsFault: Self { .init(.authorizationAlreadyExistsFault) }
    public static var authorizationNotFoundFault: Self { .init(.authorizationNotFoundFault) }
    public static var authorizationQuotaExceededFault: Self { .init(.authorizationQuotaExceededFault) }
    public static var batchDeleteRequestSizeExceededFault: Self { .init(.batchDeleteRequestSizeExceededFault) }
    public static var batchModifyClusterSnapshotsLimitExceededFault: Self { .init(.batchModifyClusterSnapshotsLimitExceededFault) }
    public static var bucketNotFoundFault: Self { .init(.bucketNotFoundFault) }
    public static var clusterAlreadyExistsFault: Self { .init(.clusterAlreadyExistsFault) }
    public static var clusterNotFoundFault: Self { .init(.clusterNotFoundFault) }
    public static var clusterOnLatestRevisionFault: Self { .init(.clusterOnLatestRevisionFault) }
    public static var clusterParameterGroupAlreadyExistsFault: Self { .init(.clusterParameterGroupAlreadyExistsFault) }
    public static var clusterParameterGroupNotFoundFault: Self { .init(.clusterParameterGroupNotFoundFault) }
    public static var clusterParameterGroupQuotaExceededFault: Self { .init(.clusterParameterGroupQuotaExceededFault) }
    public static var clusterQuotaExceededFault: Self { .init(.clusterQuotaExceededFault) }
    public static var clusterSecurityGroupAlreadyExistsFault: Self { .init(.clusterSecurityGroupAlreadyExistsFault) }
    public static var clusterSecurityGroupNotFoundFault: Self { .init(.clusterSecurityGroupNotFoundFault) }
    public static var clusterSecurityGroupQuotaExceededFault: Self { .init(.clusterSecurityGroupQuotaExceededFault) }
    public static var clusterSnapshotAlreadyExistsFault: Self { .init(.clusterSnapshotAlreadyExistsFault) }
    public static var clusterSnapshotNotFoundFault: Self { .init(.clusterSnapshotNotFoundFault) }
    public static var clusterSnapshotQuotaExceededFault: Self { .init(.clusterSnapshotQuotaExceededFault) }
    public static var clusterSubnetGroupAlreadyExistsFault: Self { .init(.clusterSubnetGroupAlreadyExistsFault) }
    public static var clusterSubnetGroupNotFoundFault: Self { .init(.clusterSubnetGroupNotFoundFault) }
    public static var clusterSubnetGroupQuotaExceededFault: Self { .init(.clusterSubnetGroupQuotaExceededFault) }
    public static var clusterSubnetQuotaExceededFault: Self { .init(.clusterSubnetQuotaExceededFault) }
    public static var copyToRegionDisabledFault: Self { .init(.copyToRegionDisabledFault) }
    public static var dependentServiceRequestThrottlingFault: Self { .init(.dependentServiceRequestThrottlingFault) }
    public static var dependentServiceUnavailableFault: Self { .init(.dependentServiceUnavailableFault) }
    public static var eventSubscriptionQuotaExceededFault: Self { .init(.eventSubscriptionQuotaExceededFault) }
    public static var hsmClientCertificateAlreadyExistsFault: Self { .init(.hsmClientCertificateAlreadyExistsFault) }
    public static var hsmClientCertificateNotFoundFault: Self { .init(.hsmClientCertificateNotFoundFault) }
    public static var hsmClientCertificateQuotaExceededFault: Self { .init(.hsmClientCertificateQuotaExceededFault) }
    public static var hsmConfigurationAlreadyExistsFault: Self { .init(.hsmConfigurationAlreadyExistsFault) }
    public static var hsmConfigurationNotFoundFault: Self { .init(.hsmConfigurationNotFoundFault) }
    public static var hsmConfigurationQuotaExceededFault: Self { .init(.hsmConfigurationQuotaExceededFault) }
    public static var inProgressTableRestoreQuotaExceededFault: Self { .init(.inProgressTableRestoreQuotaExceededFault) }
    public static var incompatibleOrderableOptions: Self { .init(.incompatibleOrderableOptions) }
    public static var insufficientClusterCapacityFault: Self { .init(.insufficientClusterCapacityFault) }
    public static var insufficientS3BucketPolicyFault: Self { .init(.insufficientS3BucketPolicyFault) }
    public static var invalidClusterParameterGroupStateFault: Self { .init(.invalidClusterParameterGroupStateFault) }
    public static var invalidClusterSecurityGroupStateFault: Self { .init(.invalidClusterSecurityGroupStateFault) }
    public static var invalidClusterSnapshotScheduleStateFault: Self { .init(.invalidClusterSnapshotScheduleStateFault) }
    public static var invalidClusterSnapshotStateFault: Self { .init(.invalidClusterSnapshotStateFault) }
    public static var invalidClusterStateFault: Self { .init(.invalidClusterStateFault) }
    public static var invalidClusterSubnetGroupStateFault: Self { .init(.invalidClusterSubnetGroupStateFault) }
    public static var invalidClusterSubnetStateFault: Self { .init(.invalidClusterSubnetStateFault) }
    public static var invalidClusterTrackFault: Self { .init(.invalidClusterTrackFault) }
    public static var invalidElasticIpFault: Self { .init(.invalidElasticIpFault) }
    public static var invalidHsmClientCertificateStateFault: Self { .init(.invalidHsmClientCertificateStateFault) }
    public static var invalidHsmConfigurationStateFault: Self { .init(.invalidHsmConfigurationStateFault) }
    public static var invalidReservedNodeStateFault: Self { .init(.invalidReservedNodeStateFault) }
    public static var invalidRestoreFault: Self { .init(.invalidRestoreFault) }
    public static var invalidRetentionPeriodFault: Self { .init(.invalidRetentionPeriodFault) }
    public static var invalidS3BucketNameFault: Self { .init(.invalidS3BucketNameFault) }
    public static var invalidS3KeyPrefixFault: Self { .init(.invalidS3KeyPrefixFault) }
    public static var invalidScheduleFault: Self { .init(.invalidScheduleFault) }
    public static var invalidScheduledActionFault: Self { .init(.invalidScheduledActionFault) }
    public static var invalidSnapshotCopyGrantStateFault: Self { .init(.invalidSnapshotCopyGrantStateFault) }
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    public static var invalidSubscriptionStateFault: Self { .init(.invalidSubscriptionStateFault) }
    public static var invalidTableRestoreArgumentFault: Self { .init(.invalidTableRestoreArgumentFault) }
    public static var invalidTagFault: Self { .init(.invalidTagFault) }
    public static var invalidUsageLimitFault: Self { .init(.invalidUsageLimitFault) }
    public static var invalidVPCNetworkStateFault: Self { .init(.invalidVPCNetworkStateFault) }
    public static var limitExceededFault: Self { .init(.limitExceededFault) }
    public static var numberOfNodesPerClusterLimitExceededFault: Self { .init(.numberOfNodesPerClusterLimitExceededFault) }
    public static var numberOfNodesQuotaExceededFault: Self { .init(.numberOfNodesQuotaExceededFault) }
    public static var reservedNodeAlreadyExistsFault: Self { .init(.reservedNodeAlreadyExistsFault) }
    public static var reservedNodeAlreadyMigratedFault: Self { .init(.reservedNodeAlreadyMigratedFault) }
    public static var reservedNodeNotFoundFault: Self { .init(.reservedNodeNotFoundFault) }
    public static var reservedNodeOfferingNotFoundFault: Self { .init(.reservedNodeOfferingNotFoundFault) }
    public static var reservedNodeQuotaExceededFault: Self { .init(.reservedNodeQuotaExceededFault) }
    public static var resizeNotFoundFault: Self { .init(.resizeNotFoundFault) }
    public static var resourceNotFoundFault: Self { .init(.resourceNotFoundFault) }
    public static var sNSInvalidTopicFault: Self { .init(.sNSInvalidTopicFault) }
    public static var sNSNoAuthorizationFault: Self { .init(.sNSNoAuthorizationFault) }
    public static var sNSTopicArnNotFoundFault: Self { .init(.sNSTopicArnNotFoundFault) }
    public static var scheduleDefinitionTypeUnsupportedFault: Self { .init(.scheduleDefinitionTypeUnsupportedFault) }
    public static var scheduledActionAlreadyExistsFault: Self { .init(.scheduledActionAlreadyExistsFault) }
    public static var scheduledActionNotFoundFault: Self { .init(.scheduledActionNotFoundFault) }
    public static var scheduledActionQuotaExceededFault: Self { .init(.scheduledActionQuotaExceededFault) }
    public static var scheduledActionTypeUnsupportedFault: Self { .init(.scheduledActionTypeUnsupportedFault) }
    public static var snapshotCopyAlreadyDisabledFault: Self { .init(.snapshotCopyAlreadyDisabledFault) }
    public static var snapshotCopyAlreadyEnabledFault: Self { .init(.snapshotCopyAlreadyEnabledFault) }
    public static var snapshotCopyDisabledFault: Self { .init(.snapshotCopyDisabledFault) }
    public static var snapshotCopyGrantAlreadyExistsFault: Self { .init(.snapshotCopyGrantAlreadyExistsFault) }
    public static var snapshotCopyGrantNotFoundFault: Self { .init(.snapshotCopyGrantNotFoundFault) }
    public static var snapshotCopyGrantQuotaExceededFault: Self { .init(.snapshotCopyGrantQuotaExceededFault) }
    public static var snapshotScheduleAlreadyExistsFault: Self { .init(.snapshotScheduleAlreadyExistsFault) }
    public static var snapshotScheduleNotFoundFault: Self { .init(.snapshotScheduleNotFoundFault) }
    public static var snapshotScheduleQuotaExceededFault: Self { .init(.snapshotScheduleQuotaExceededFault) }
    public static var snapshotScheduleUpdateInProgressFault: Self { .init(.snapshotScheduleUpdateInProgressFault) }
    public static var sourceNotFoundFault: Self { .init(.sourceNotFoundFault) }
    public static var subnetAlreadyInUse: Self { .init(.subnetAlreadyInUse) }
    public static var subscriptionAlreadyExistFault: Self { .init(.subscriptionAlreadyExistFault) }
    public static var subscriptionCategoryNotFoundFault: Self { .init(.subscriptionCategoryNotFoundFault) }
    public static var subscriptionEventIdNotFoundFault: Self { .init(.subscriptionEventIdNotFoundFault) }
    public static var subscriptionNotFoundFault: Self { .init(.subscriptionNotFoundFault) }
    public static var subscriptionSeverityNotFoundFault: Self { .init(.subscriptionSeverityNotFoundFault) }
    public static var tableLimitExceededFault: Self { .init(.tableLimitExceededFault) }
    public static var tableRestoreNotFoundFault: Self { .init(.tableRestoreNotFoundFault) }
    public static var tagLimitExceededFault: Self { .init(.tagLimitExceededFault) }
    public static var unauthorizedOperation: Self { .init(.unauthorizedOperation) }
    public static var unknownSnapshotCopyRegionFault: Self { .init(.unknownSnapshotCopyRegionFault) }
    public static var unsupportedOperationFault: Self { .init(.unsupportedOperationFault) }
    public static var unsupportedOptionFault: Self { .init(.unsupportedOptionFault) }
    public static var usageLimitAlreadyExistsFault: Self { .init(.usageLimitAlreadyExistsFault) }
    public static var usageLimitNotFoundFault: Self { .init(.usageLimitNotFoundFault) }
}

extension RedshiftErrorType: Equatable {
    public static func == (lhs: RedshiftErrorType, rhs: RedshiftErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RedshiftErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}

//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for DAX
public struct DAXErrorType: AWSErrorType {
    enum Code: String {
        case clusterAlreadyExistsFault = "ClusterAlreadyExistsFault"
        case clusterNotFoundFault = "ClusterNotFoundFault"
        case clusterQuotaForCustomerExceededFault = "ClusterQuotaForCustomerExceededFault"
        case insufficientClusterCapacityFault = "InsufficientClusterCapacityFault"
        case invalidARNFault = "InvalidARNFault"
        case invalidClusterStateFault = "InvalidClusterStateFault"
        case invalidParameterCombinationException = "InvalidParameterCombinationException"
        case invalidParameterGroupStateFault = "InvalidParameterGroupStateFault"
        case invalidParameterValueException = "InvalidParameterValueException"
        case invalidSubnet = "InvalidSubnet"
        case invalidVPCNetworkStateFault = "InvalidVPCNetworkStateFault"
        case nodeNotFoundFault = "NodeNotFoundFault"
        case nodeQuotaForClusterExceededFault = "NodeQuotaForClusterExceededFault"
        case nodeQuotaForCustomerExceededFault = "NodeQuotaForCustomerExceededFault"
        case parameterGroupAlreadyExistsFault = "ParameterGroupAlreadyExistsFault"
        case parameterGroupNotFoundFault = "ParameterGroupNotFoundFault"
        case parameterGroupQuotaExceededFault = "ParameterGroupQuotaExceededFault"
        case serviceLinkedRoleNotFoundFault = "ServiceLinkedRoleNotFoundFault"
        case subnetGroupAlreadyExistsFault = "SubnetGroupAlreadyExistsFault"
        case subnetGroupInUseFault = "SubnetGroupInUseFault"
        case subnetGroupNotFoundFault = "SubnetGroupNotFoundFault"
        case subnetGroupQuotaExceededFault = "SubnetGroupQuotaExceededFault"
        case subnetInUse = "SubnetInUse"
        case subnetQuotaExceededFault = "SubnetQuotaExceededFault"
        case tagNotFoundFault = "TagNotFoundFault"
        case tagQuotaPerResourceExceeded = "TagQuotaPerResourceExceeded"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DAX
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var clusterAlreadyExistsFault: Self { .init(.clusterAlreadyExistsFault) }
    public static var clusterNotFoundFault: Self { .init(.clusterNotFoundFault) }
    public static var clusterQuotaForCustomerExceededFault: Self { .init(.clusterQuotaForCustomerExceededFault) }
    public static var insufficientClusterCapacityFault: Self { .init(.insufficientClusterCapacityFault) }
    public static var invalidARNFault: Self { .init(.invalidARNFault) }
    public static var invalidClusterStateFault: Self { .init(.invalidClusterStateFault) }
    public static var invalidParameterCombinationException: Self { .init(.invalidParameterCombinationException) }
    public static var invalidParameterGroupStateFault: Self { .init(.invalidParameterGroupStateFault) }
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    public static var invalidVPCNetworkStateFault: Self { .init(.invalidVPCNetworkStateFault) }
    public static var nodeNotFoundFault: Self { .init(.nodeNotFoundFault) }
    public static var nodeQuotaForClusterExceededFault: Self { .init(.nodeQuotaForClusterExceededFault) }
    public static var nodeQuotaForCustomerExceededFault: Self { .init(.nodeQuotaForCustomerExceededFault) }
    public static var parameterGroupAlreadyExistsFault: Self { .init(.parameterGroupAlreadyExistsFault) }
    public static var parameterGroupNotFoundFault: Self { .init(.parameterGroupNotFoundFault) }
    public static var parameterGroupQuotaExceededFault: Self { .init(.parameterGroupQuotaExceededFault) }
    public static var serviceLinkedRoleNotFoundFault: Self { .init(.serviceLinkedRoleNotFoundFault) }
    public static var subnetGroupAlreadyExistsFault: Self { .init(.subnetGroupAlreadyExistsFault) }
    public static var subnetGroupInUseFault: Self { .init(.subnetGroupInUseFault) }
    public static var subnetGroupNotFoundFault: Self { .init(.subnetGroupNotFoundFault) }
    public static var subnetGroupQuotaExceededFault: Self { .init(.subnetGroupQuotaExceededFault) }
    public static var subnetInUse: Self { .init(.subnetInUse) }
    public static var subnetQuotaExceededFault: Self { .init(.subnetQuotaExceededFault) }
    public static var tagNotFoundFault: Self { .init(.tagNotFoundFault) }
    public static var tagQuotaPerResourceExceeded: Self { .init(.tagQuotaPerResourceExceeded) }
}

extension DAXErrorType: Equatable {
    public static func == (lhs: DAXErrorType, rhs: DAXErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DAXErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}

//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for RDS
public struct RDSErrorType: AWSErrorType {
    enum Code: String {
        case authorizationAlreadyExistsFault = "AuthorizationAlreadyExists"
        case authorizationNotFoundFault = "AuthorizationNotFound"
        case authorizationQuotaExceededFault = "AuthorizationQuotaExceeded"
        case backupPolicyNotFoundFault = "BackupPolicyNotFoundFault"
        case certificateNotFoundFault = "CertificateNotFound"
        case customAvailabilityZoneAlreadyExistsFault = "CustomAvailabilityZoneAlreadyExists"
        case customAvailabilityZoneNotFoundFault = "CustomAvailabilityZoneNotFound"
        case customAvailabilityZoneQuotaExceededFault = "CustomAvailabilityZoneQuotaExceeded"
        case dBClusterAlreadyExistsFault = "DBClusterAlreadyExistsFault"
        case dBClusterBacktrackNotFoundFault = "DBClusterBacktrackNotFoundFault"
        case dBClusterEndpointAlreadyExistsFault = "DBClusterEndpointAlreadyExistsFault"
        case dBClusterEndpointNotFoundFault = "DBClusterEndpointNotFoundFault"
        case dBClusterEndpointQuotaExceededFault = "DBClusterEndpointQuotaExceededFault"
        case dBClusterNotFoundFault = "DBClusterNotFoundFault"
        case dBClusterParameterGroupNotFoundFault = "DBClusterParameterGroupNotFound"
        case dBClusterQuotaExceededFault = "DBClusterQuotaExceededFault"
        case dBClusterRoleAlreadyExistsFault = "DBClusterRoleAlreadyExists"
        case dBClusterRoleNotFoundFault = "DBClusterRoleNotFound"
        case dBClusterRoleQuotaExceededFault = "DBClusterRoleQuotaExceeded"
        case dBClusterSnapshotAlreadyExistsFault = "DBClusterSnapshotAlreadyExistsFault"
        case dBClusterSnapshotNotFoundFault = "DBClusterSnapshotNotFoundFault"
        case dBInstanceAlreadyExistsFault = "DBInstanceAlreadyExists"
        case dBInstanceAutomatedBackupNotFoundFault = "DBInstanceAutomatedBackupNotFound"
        case dBInstanceAutomatedBackupQuotaExceededFault = "DBInstanceAutomatedBackupQuotaExceeded"
        case dBInstanceNotFoundFault = "DBInstanceNotFound"
        case dBInstanceRoleAlreadyExistsFault = "DBInstanceRoleAlreadyExists"
        case dBInstanceRoleNotFoundFault = "DBInstanceRoleNotFound"
        case dBInstanceRoleQuotaExceededFault = "DBInstanceRoleQuotaExceeded"
        case dBLogFileNotFoundFault = "DBLogFileNotFoundFault"
        case dBParameterGroupAlreadyExistsFault = "DBParameterGroupAlreadyExists"
        case dBParameterGroupNotFoundFault = "DBParameterGroupNotFound"
        case dBParameterGroupQuotaExceededFault = "DBParameterGroupQuotaExceeded"
        case dBProxyAlreadyExistsFault = "DBProxyTargetExistsFault"
        case dBProxyNotFoundFault = "DBProxyNotFoundFault"
        case dBProxyQuotaExceededFault = "DBProxyQuotaExceededFault"
        case dBProxyTargetAlreadyRegisteredFault = "DBProxyTargetAlreadyRegisteredFault"
        case dBProxyTargetGroupNotFoundFault = "DBProxyTargetGroupNotFoundFault"
        case dBProxyTargetNotFoundFault = "DBProxyTargetNotFoundFault"
        case dBSecurityGroupAlreadyExistsFault = "DBSecurityGroupAlreadyExists"
        case dBSecurityGroupNotFoundFault = "DBSecurityGroupNotFound"
        case dBSecurityGroupNotSupportedFault = "DBSecurityGroupNotSupported"
        case dBSecurityGroupQuotaExceededFault = "QuotaExceeded.DBSecurityGroup"
        case dBSnapshotAlreadyExistsFault = "DBSnapshotAlreadyExists"
        case dBSnapshotNotFoundFault = "DBSnapshotNotFound"
        case dBSubnetGroupAlreadyExistsFault = "DBSubnetGroupAlreadyExists"
        case dBSubnetGroupDoesNotCoverEnoughAZs = "DBSubnetGroupDoesNotCoverEnoughAZs"
        case dBSubnetGroupNotAllowedFault = "DBSubnetGroupNotAllowedFault"
        case dBSubnetGroupNotFoundFault = "DBSubnetGroupNotFoundFault"
        case dBSubnetGroupQuotaExceededFault = "DBSubnetGroupQuotaExceeded"
        case dBSubnetQuotaExceededFault = "DBSubnetQuotaExceededFault"
        case dBUpgradeDependencyFailureFault = "DBUpgradeDependencyFailure"
        case domainNotFoundFault = "DomainNotFoundFault"
        case eventSubscriptionQuotaExceededFault = "EventSubscriptionQuotaExceeded"
        case exportTaskAlreadyExistsFault = "ExportTaskAlreadyExists"
        case exportTaskNotFoundFault = "ExportTaskNotFound"
        case globalClusterAlreadyExistsFault = "GlobalClusterAlreadyExistsFault"
        case globalClusterNotFoundFault = "GlobalClusterNotFoundFault"
        case globalClusterQuotaExceededFault = "GlobalClusterQuotaExceededFault"
        case iamRoleMissingPermissionsFault = "IamRoleMissingPermissions"
        case iamRoleNotFoundFault = "IamRoleNotFound"
        case installationMediaAlreadyExistsFault = "InstallationMediaAlreadyExists"
        case installationMediaNotFoundFault = "InstallationMediaNotFound"
        case instanceQuotaExceededFault = "InstanceQuotaExceeded"
        case insufficientAvailableIPsInSubnetFault = "InsufficientAvailableIPsInSubnetFault"
        case insufficientDBClusterCapacityFault = "InsufficientDBClusterCapacityFault"
        case insufficientDBInstanceCapacityFault = "InsufficientDBInstanceCapacity"
        case insufficientStorageClusterCapacityFault = "InsufficientStorageClusterCapacity"
        case invalidDBClusterCapacityFault = "InvalidDBClusterCapacityFault"
        case invalidDBClusterEndpointStateFault = "InvalidDBClusterEndpointStateFault"
        case invalidDBClusterSnapshotStateFault = "InvalidDBClusterSnapshotStateFault"
        case invalidDBClusterStateFault = "InvalidDBClusterStateFault"
        case invalidDBInstanceAutomatedBackupStateFault = "InvalidDBInstanceAutomatedBackupState"
        case invalidDBInstanceStateFault = "InvalidDBInstanceState"
        case invalidDBParameterGroupStateFault = "InvalidDBParameterGroupState"
        case invalidDBProxyStateFault = "InvalidDBProxyStateFault"
        case invalidDBSecurityGroupStateFault = "InvalidDBSecurityGroupState"
        case invalidDBSnapshotStateFault = "InvalidDBSnapshotState"
        case invalidDBSubnetGroupFault = "InvalidDBSubnetGroupFault"
        case invalidDBSubnetGroupStateFault = "InvalidDBSubnetGroupStateFault"
        case invalidDBSubnetStateFault = "InvalidDBSubnetStateFault"
        case invalidEventSubscriptionStateFault = "InvalidEventSubscriptionState"
        case invalidExportOnlyFault = "InvalidExportOnly"
        case invalidExportSourceStateFault = "InvalidExportSourceState"
        case invalidExportTaskStateFault = "InvalidExportTaskStateFault"
        case invalidGlobalClusterStateFault = "InvalidGlobalClusterStateFault"
        case invalidOptionGroupStateFault = "InvalidOptionGroupStateFault"
        case invalidRestoreFault = "InvalidRestoreFault"
        case invalidS3BucketFault = "InvalidS3BucketFault"
        case invalidSubnet = "InvalidSubnet"
        case invalidVPCNetworkStateFault = "InvalidVPCNetworkStateFault"
        case kMSKeyNotAccessibleFault = "KMSKeyNotAccessibleFault"
        case optionGroupAlreadyExistsFault = "OptionGroupAlreadyExistsFault"
        case optionGroupNotFoundFault = "OptionGroupNotFoundFault"
        case optionGroupQuotaExceededFault = "OptionGroupQuotaExceededFault"
        case pointInTimeRestoreNotEnabledFault = "PointInTimeRestoreNotEnabled"
        case provisionedIopsNotAvailableInAZFault = "ProvisionedIopsNotAvailableInAZFault"
        case reservedDBInstanceAlreadyExistsFault = "ReservedDBInstanceAlreadyExists"
        case reservedDBInstanceNotFoundFault = "ReservedDBInstanceNotFound"
        case reservedDBInstanceQuotaExceededFault = "ReservedDBInstanceQuotaExceeded"
        case reservedDBInstancesOfferingNotFoundFault = "ReservedDBInstancesOfferingNotFound"
        case resourceNotFoundFault = "ResourceNotFoundFault"
        case sNSInvalidTopicFault = "SNSInvalidTopic"
        case sNSNoAuthorizationFault = "SNSNoAuthorization"
        case sNSTopicArnNotFoundFault = "SNSTopicArnNotFound"
        case sharedSnapshotQuotaExceededFault = "SharedSnapshotQuotaExceeded"
        case snapshotQuotaExceededFault = "SnapshotQuotaExceeded"
        case sourceNotFoundFault = "SourceNotFound"
        case storageQuotaExceededFault = "StorageQuotaExceeded"
        case storageTypeNotSupportedFault = "StorageTypeNotSupported"
        case subnetAlreadyInUse = "SubnetAlreadyInUse"
        case subscriptionAlreadyExistFault = "SubscriptionAlreadyExist"
        case subscriptionCategoryNotFoundFault = "SubscriptionCategoryNotFound"
        case subscriptionNotFoundFault = "SubscriptionNotFound"
    }

    private var error: Code
    public var message: String?

    public init?(errorCode: String, message: String?) {
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.message = message
    }

    internal init(_ error: Code) {
        self.error = error
        self.message = nil
    }

    public static var authorizationAlreadyExistsFault: Self { .init(.authorizationAlreadyExistsFault) }
    public static var authorizationNotFoundFault: Self { .init(.authorizationNotFoundFault) }
    public static var authorizationQuotaExceededFault: Self { .init(.authorizationQuotaExceededFault) }
    public static var backupPolicyNotFoundFault: Self { .init(.backupPolicyNotFoundFault) }
    public static var certificateNotFoundFault: Self { .init(.certificateNotFoundFault) }
    public static var customAvailabilityZoneAlreadyExistsFault: Self { .init(.customAvailabilityZoneAlreadyExistsFault) }
    public static var customAvailabilityZoneNotFoundFault: Self { .init(.customAvailabilityZoneNotFoundFault) }
    public static var customAvailabilityZoneQuotaExceededFault: Self { .init(.customAvailabilityZoneQuotaExceededFault) }
    public static var dBClusterAlreadyExistsFault: Self { .init(.dBClusterAlreadyExistsFault) }
    public static var dBClusterBacktrackNotFoundFault: Self { .init(.dBClusterBacktrackNotFoundFault) }
    public static var dBClusterEndpointAlreadyExistsFault: Self { .init(.dBClusterEndpointAlreadyExistsFault) }
    public static var dBClusterEndpointNotFoundFault: Self { .init(.dBClusterEndpointNotFoundFault) }
    public static var dBClusterEndpointQuotaExceededFault: Self { .init(.dBClusterEndpointQuotaExceededFault) }
    public static var dBClusterNotFoundFault: Self { .init(.dBClusterNotFoundFault) }
    public static var dBClusterParameterGroupNotFoundFault: Self { .init(.dBClusterParameterGroupNotFoundFault) }
    public static var dBClusterQuotaExceededFault: Self { .init(.dBClusterQuotaExceededFault) }
    public static var dBClusterRoleAlreadyExistsFault: Self { .init(.dBClusterRoleAlreadyExistsFault) }
    public static var dBClusterRoleNotFoundFault: Self { .init(.dBClusterRoleNotFoundFault) }
    public static var dBClusterRoleQuotaExceededFault: Self { .init(.dBClusterRoleQuotaExceededFault) }
    public static var dBClusterSnapshotAlreadyExistsFault: Self { .init(.dBClusterSnapshotAlreadyExistsFault) }
    public static var dBClusterSnapshotNotFoundFault: Self { .init(.dBClusterSnapshotNotFoundFault) }
    public static var dBInstanceAlreadyExistsFault: Self { .init(.dBInstanceAlreadyExistsFault) }
    public static var dBInstanceAutomatedBackupNotFoundFault: Self { .init(.dBInstanceAutomatedBackupNotFoundFault) }
    public static var dBInstanceAutomatedBackupQuotaExceededFault: Self { .init(.dBInstanceAutomatedBackupQuotaExceededFault) }
    public static var dBInstanceNotFoundFault: Self { .init(.dBInstanceNotFoundFault) }
    public static var dBInstanceRoleAlreadyExistsFault: Self { .init(.dBInstanceRoleAlreadyExistsFault) }
    public static var dBInstanceRoleNotFoundFault: Self { .init(.dBInstanceRoleNotFoundFault) }
    public static var dBInstanceRoleQuotaExceededFault: Self { .init(.dBInstanceRoleQuotaExceededFault) }
    public static var dBLogFileNotFoundFault: Self { .init(.dBLogFileNotFoundFault) }
    public static var dBParameterGroupAlreadyExistsFault: Self { .init(.dBParameterGroupAlreadyExistsFault) }
    public static var dBParameterGroupNotFoundFault: Self { .init(.dBParameterGroupNotFoundFault) }
    public static var dBParameterGroupQuotaExceededFault: Self { .init(.dBParameterGroupQuotaExceededFault) }
    public static var dBProxyAlreadyExistsFault: Self { .init(.dBProxyAlreadyExistsFault) }
    public static var dBProxyNotFoundFault: Self { .init(.dBProxyNotFoundFault) }
    public static var dBProxyQuotaExceededFault: Self { .init(.dBProxyQuotaExceededFault) }
    public static var dBProxyTargetAlreadyRegisteredFault: Self { .init(.dBProxyTargetAlreadyRegisteredFault) }
    public static var dBProxyTargetGroupNotFoundFault: Self { .init(.dBProxyTargetGroupNotFoundFault) }
    public static var dBProxyTargetNotFoundFault: Self { .init(.dBProxyTargetNotFoundFault) }
    public static var dBSecurityGroupAlreadyExistsFault: Self { .init(.dBSecurityGroupAlreadyExistsFault) }
    public static var dBSecurityGroupNotFoundFault: Self { .init(.dBSecurityGroupNotFoundFault) }
    public static var dBSecurityGroupNotSupportedFault: Self { .init(.dBSecurityGroupNotSupportedFault) }
    public static var dBSecurityGroupQuotaExceededFault: Self { .init(.dBSecurityGroupQuotaExceededFault) }
    public static var dBSnapshotAlreadyExistsFault: Self { .init(.dBSnapshotAlreadyExistsFault) }
    public static var dBSnapshotNotFoundFault: Self { .init(.dBSnapshotNotFoundFault) }
    public static var dBSubnetGroupAlreadyExistsFault: Self { .init(.dBSubnetGroupAlreadyExistsFault) }
    public static var dBSubnetGroupDoesNotCoverEnoughAZs: Self { .init(.dBSubnetGroupDoesNotCoverEnoughAZs) }
    public static var dBSubnetGroupNotAllowedFault: Self { .init(.dBSubnetGroupNotAllowedFault) }
    public static var dBSubnetGroupNotFoundFault: Self { .init(.dBSubnetGroupNotFoundFault) }
    public static var dBSubnetGroupQuotaExceededFault: Self { .init(.dBSubnetGroupQuotaExceededFault) }
    public static var dBSubnetQuotaExceededFault: Self { .init(.dBSubnetQuotaExceededFault) }
    public static var dBUpgradeDependencyFailureFault: Self { .init(.dBUpgradeDependencyFailureFault) }
    public static var domainNotFoundFault: Self { .init(.domainNotFoundFault) }
    public static var eventSubscriptionQuotaExceededFault: Self { .init(.eventSubscriptionQuotaExceededFault) }
    public static var exportTaskAlreadyExistsFault: Self { .init(.exportTaskAlreadyExistsFault) }
    public static var exportTaskNotFoundFault: Self { .init(.exportTaskNotFoundFault) }
    public static var globalClusterAlreadyExistsFault: Self { .init(.globalClusterAlreadyExistsFault) }
    public static var globalClusterNotFoundFault: Self { .init(.globalClusterNotFoundFault) }
    public static var globalClusterQuotaExceededFault: Self { .init(.globalClusterQuotaExceededFault) }
    public static var iamRoleMissingPermissionsFault: Self { .init(.iamRoleMissingPermissionsFault) }
    public static var iamRoleNotFoundFault: Self { .init(.iamRoleNotFoundFault) }
    public static var installationMediaAlreadyExistsFault: Self { .init(.installationMediaAlreadyExistsFault) }
    public static var installationMediaNotFoundFault: Self { .init(.installationMediaNotFoundFault) }
    public static var instanceQuotaExceededFault: Self { .init(.instanceQuotaExceededFault) }
    public static var insufficientAvailableIPsInSubnetFault: Self { .init(.insufficientAvailableIPsInSubnetFault) }
    public static var insufficientDBClusterCapacityFault: Self { .init(.insufficientDBClusterCapacityFault) }
    public static var insufficientDBInstanceCapacityFault: Self { .init(.insufficientDBInstanceCapacityFault) }
    public static var insufficientStorageClusterCapacityFault: Self { .init(.insufficientStorageClusterCapacityFault) }
    public static var invalidDBClusterCapacityFault: Self { .init(.invalidDBClusterCapacityFault) }
    public static var invalidDBClusterEndpointStateFault: Self { .init(.invalidDBClusterEndpointStateFault) }
    public static var invalidDBClusterSnapshotStateFault: Self { .init(.invalidDBClusterSnapshotStateFault) }
    public static var invalidDBClusterStateFault: Self { .init(.invalidDBClusterStateFault) }
    public static var invalidDBInstanceAutomatedBackupStateFault: Self { .init(.invalidDBInstanceAutomatedBackupStateFault) }
    public static var invalidDBInstanceStateFault: Self { .init(.invalidDBInstanceStateFault) }
    public static var invalidDBParameterGroupStateFault: Self { .init(.invalidDBParameterGroupStateFault) }
    public static var invalidDBProxyStateFault: Self { .init(.invalidDBProxyStateFault) }
    public static var invalidDBSecurityGroupStateFault: Self { .init(.invalidDBSecurityGroupStateFault) }
    public static var invalidDBSnapshotStateFault: Self { .init(.invalidDBSnapshotStateFault) }
    public static var invalidDBSubnetGroupFault: Self { .init(.invalidDBSubnetGroupFault) }
    public static var invalidDBSubnetGroupStateFault: Self { .init(.invalidDBSubnetGroupStateFault) }
    public static var invalidDBSubnetStateFault: Self { .init(.invalidDBSubnetStateFault) }
    public static var invalidEventSubscriptionStateFault: Self { .init(.invalidEventSubscriptionStateFault) }
    public static var invalidExportOnlyFault: Self { .init(.invalidExportOnlyFault) }
    public static var invalidExportSourceStateFault: Self { .init(.invalidExportSourceStateFault) }
    public static var invalidExportTaskStateFault: Self { .init(.invalidExportTaskStateFault) }
    public static var invalidGlobalClusterStateFault: Self { .init(.invalidGlobalClusterStateFault) }
    public static var invalidOptionGroupStateFault: Self { .init(.invalidOptionGroupStateFault) }
    public static var invalidRestoreFault: Self { .init(.invalidRestoreFault) }
    public static var invalidS3BucketFault: Self { .init(.invalidS3BucketFault) }
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    public static var invalidVPCNetworkStateFault: Self { .init(.invalidVPCNetworkStateFault) }
    public static var kMSKeyNotAccessibleFault: Self { .init(.kMSKeyNotAccessibleFault) }
    public static var optionGroupAlreadyExistsFault: Self { .init(.optionGroupAlreadyExistsFault) }
    public static var optionGroupNotFoundFault: Self { .init(.optionGroupNotFoundFault) }
    public static var optionGroupQuotaExceededFault: Self { .init(.optionGroupQuotaExceededFault) }
    public static var pointInTimeRestoreNotEnabledFault: Self { .init(.pointInTimeRestoreNotEnabledFault) }
    public static var provisionedIopsNotAvailableInAZFault: Self { .init(.provisionedIopsNotAvailableInAZFault) }
    public static var reservedDBInstanceAlreadyExistsFault: Self { .init(.reservedDBInstanceAlreadyExistsFault) }
    public static var reservedDBInstanceNotFoundFault: Self { .init(.reservedDBInstanceNotFoundFault) }
    public static var reservedDBInstanceQuotaExceededFault: Self { .init(.reservedDBInstanceQuotaExceededFault) }
    public static var reservedDBInstancesOfferingNotFoundFault: Self { .init(.reservedDBInstancesOfferingNotFoundFault) }
    public static var resourceNotFoundFault: Self { .init(.resourceNotFoundFault) }
    public static var sNSInvalidTopicFault: Self { .init(.sNSInvalidTopicFault) }
    public static var sNSNoAuthorizationFault: Self { .init(.sNSNoAuthorizationFault) }
    public static var sNSTopicArnNotFoundFault: Self { .init(.sNSTopicArnNotFoundFault) }
    public static var sharedSnapshotQuotaExceededFault: Self { .init(.sharedSnapshotQuotaExceededFault) }
    public static var snapshotQuotaExceededFault: Self { .init(.snapshotQuotaExceededFault) }
    public static var sourceNotFoundFault: Self { .init(.sourceNotFoundFault) }
    public static var storageQuotaExceededFault: Self { .init(.storageQuotaExceededFault) }
    public static var storageTypeNotSupportedFault: Self { .init(.storageTypeNotSupportedFault) }
    public static var subnetAlreadyInUse: Self { .init(.subnetAlreadyInUse) }
    public static var subscriptionAlreadyExistFault: Self { .init(.subscriptionAlreadyExistFault) }
    public static var subscriptionCategoryNotFoundFault: Self { .init(.subscriptionCategoryNotFoundFault) }
    public static var subscriptionNotFoundFault: Self { .init(.subscriptionNotFoundFault) }
}

extension RDSErrorType: Equatable {
    public static func == (lhs: RDSErrorType, rhs: RDSErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RDSErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}

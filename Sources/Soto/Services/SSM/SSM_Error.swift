//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

/// Error enum for SSM
public struct SSMErrorType: AWSErrorType {
    enum Code: String {
        case alreadyExistsException = "AlreadyExistsException"
        case associatedInstances = "AssociatedInstances"
        case associationAlreadyExists = "AssociationAlreadyExists"
        case associationDoesNotExist = "AssociationDoesNotExist"
        case associationExecutionDoesNotExist = "AssociationExecutionDoesNotExist"
        case associationLimitExceeded = "AssociationLimitExceeded"
        case associationVersionLimitExceeded = "AssociationVersionLimitExceeded"
        case automationDefinitionNotFoundException = "AutomationDefinitionNotFoundException"
        case automationDefinitionVersionNotFoundException = "AutomationDefinitionVersionNotFoundException"
        case automationExecutionLimitExceededException = "AutomationExecutionLimitExceededException"
        case automationExecutionNotFoundException = "AutomationExecutionNotFoundException"
        case automationStepNotFoundException = "AutomationStepNotFoundException"
        case complianceTypeCountLimitExceededException = "ComplianceTypeCountLimitExceededException"
        case customSchemaCountLimitExceededException = "CustomSchemaCountLimitExceededException"
        case documentAlreadyExists = "DocumentAlreadyExists"
        case documentLimitExceeded = "DocumentLimitExceeded"
        case documentPermissionLimit = "DocumentPermissionLimit"
        case documentVersionLimitExceeded = "DocumentVersionLimitExceeded"
        case doesNotExistException = "DoesNotExistException"
        case duplicateDocumentContent = "DuplicateDocumentContent"
        case duplicateDocumentVersionName = "DuplicateDocumentVersionName"
        case duplicateInstanceId = "DuplicateInstanceId"
        case featureNotAvailableException = "FeatureNotAvailableException"
        case hierarchyLevelLimitExceededException = "HierarchyLevelLimitExceededException"
        case hierarchyTypeMismatchException = "HierarchyTypeMismatchException"
        case idempotentParameterMismatch = "IdempotentParameterMismatch"
        case incompatiblePolicyException = "IncompatiblePolicyException"
        case internalServerError = "InternalServerError"
        case invalidActivation = "InvalidActivation"
        case invalidActivationId = "InvalidActivationId"
        case invalidAggregatorException = "InvalidAggregatorException"
        case invalidAllowedPatternException = "InvalidAllowedPatternException"
        case invalidAssociation = "InvalidAssociation"
        case invalidAssociationVersion = "InvalidAssociationVersion"
        case invalidAutomationExecutionParametersException = "InvalidAutomationExecutionParametersException"
        case invalidAutomationSignalException = "InvalidAutomationSignalException"
        case invalidAutomationStatusUpdateException = "InvalidAutomationStatusUpdateException"
        case invalidCommandId = "InvalidCommandId"
        case invalidDeleteInventoryParametersException = "InvalidDeleteInventoryParametersException"
        case invalidDeletionIdException = "InvalidDeletionIdException"
        case invalidDocument = "InvalidDocument"
        case invalidDocumentContent = "InvalidDocumentContent"
        case invalidDocumentOperation = "InvalidDocumentOperation"
        case invalidDocumentSchemaVersion = "InvalidDocumentSchemaVersion"
        case invalidDocumentType = "InvalidDocumentType"
        case invalidDocumentVersion = "InvalidDocumentVersion"
        case invalidFilter = "InvalidFilter"
        case invalidFilterKey = "InvalidFilterKey"
        case invalidFilterOption = "InvalidFilterOption"
        case invalidFilterValue = "InvalidFilterValue"
        case invalidInstanceId = "InvalidInstanceId"
        case invalidInstanceInformationFilterValue = "InvalidInstanceInformationFilterValue"
        case invalidInventoryGroupException = "InvalidInventoryGroupException"
        case invalidInventoryItemContextException = "InvalidInventoryItemContextException"
        case invalidInventoryRequestException = "InvalidInventoryRequestException"
        case invalidItemContentException = "InvalidItemContentException"
        case invalidKeyId = "InvalidKeyId"
        case invalidNextToken = "InvalidNextToken"
        case invalidNotificationConfig = "InvalidNotificationConfig"
        case invalidOptionException = "InvalidOptionException"
        case invalidOutputFolder = "InvalidOutputFolder"
        case invalidOutputLocation = "InvalidOutputLocation"
        case invalidParameters = "InvalidParameters"
        case invalidPermissionType = "InvalidPermissionType"
        case invalidPluginName = "InvalidPluginName"
        case invalidPolicyAttributeException = "InvalidPolicyAttributeException"
        case invalidPolicyTypeException = "InvalidPolicyTypeException"
        case invalidResourceId = "InvalidResourceId"
        case invalidResourceType = "InvalidResourceType"
        case invalidResultAttributeException = "InvalidResultAttributeException"
        case invalidRole = "InvalidRole"
        case invalidSchedule = "InvalidSchedule"
        case invalidTarget = "InvalidTarget"
        case invalidTypeNameException = "InvalidTypeNameException"
        case invalidUpdate = "InvalidUpdate"
        case invocationDoesNotExist = "InvocationDoesNotExist"
        case itemContentMismatchException = "ItemContentMismatchException"
        case itemSizeLimitExceededException = "ItemSizeLimitExceededException"
        case maxDocumentSizeExceeded = "MaxDocumentSizeExceeded"
        case opsItemAlreadyExistsException = "OpsItemAlreadyExistsException"
        case opsItemInvalidParameterException = "OpsItemInvalidParameterException"
        case opsItemLimitExceededException = "OpsItemLimitExceededException"
        case opsItemNotFoundException = "OpsItemNotFoundException"
        case parameterAlreadyExists = "ParameterAlreadyExists"
        case parameterLimitExceeded = "ParameterLimitExceeded"
        case parameterMaxVersionLimitExceeded = "ParameterMaxVersionLimitExceeded"
        case parameterNotFound = "ParameterNotFound"
        case parameterPatternMismatchException = "ParameterPatternMismatchException"
        case parameterVersionLabelLimitExceeded = "ParameterVersionLabelLimitExceeded"
        case parameterVersionNotFound = "ParameterVersionNotFound"
        case policiesLimitExceededException = "PoliciesLimitExceededException"
        case resourceDataSyncAlreadyExistsException = "ResourceDataSyncAlreadyExistsException"
        case resourceDataSyncConflictException = "ResourceDataSyncConflictException"
        case resourceDataSyncCountExceededException = "ResourceDataSyncCountExceededException"
        case resourceDataSyncInvalidConfigurationException = "ResourceDataSyncInvalidConfigurationException"
        case resourceDataSyncNotFoundException = "ResourceDataSyncNotFoundException"
        case resourceInUseException = "ResourceInUseException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case serviceSettingNotFound = "ServiceSettingNotFound"
        case statusUnchanged = "StatusUnchanged"
        case subTypeCountLimitExceededException = "SubTypeCountLimitExceededException"
        case targetInUseException = "TargetInUseException"
        case targetNotConnected = "TargetNotConnected"
        case tooManyTagsError = "TooManyTagsError"
        case tooManyUpdates = "TooManyUpdates"
        case totalSizeLimitExceededException = "TotalSizeLimitExceededException"
        case unsupportedCalendarException = "UnsupportedCalendarException"
        case unsupportedFeatureRequiredException = "UnsupportedFeatureRequiredException"
        case unsupportedInventoryItemContextException = "UnsupportedInventoryItemContextException"
        case unsupportedInventorySchemaVersionException = "UnsupportedInventorySchemaVersionException"
        case unsupportedOperatingSystem = "UnsupportedOperatingSystem"
        case unsupportedParameterType = "UnsupportedParameterType"
        case unsupportedPlatformType = "UnsupportedPlatformType"
    }

    private var error: Code
    public var message: String?

    public init?(errorCode: String, message: String?) {
        var errorCode = errorCode
        if let index = errorCode.firstIndex(of: "#") {
            errorCode = String(errorCode[errorCode.index(index, offsetBy: 1)...])
        }
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.message = message
    }

    internal init(_ error: Code) {
        self.error = error
        self.message = nil
    }

    public static var alreadyExistsException: Self { .init(.alreadyExistsException) }
    public static var associatedInstances: Self { .init(.associatedInstances) }
    public static var associationAlreadyExists: Self { .init(.associationAlreadyExists) }
    public static var associationDoesNotExist: Self { .init(.associationDoesNotExist) }
    public static var associationExecutionDoesNotExist: Self { .init(.associationExecutionDoesNotExist) }
    public static var associationLimitExceeded: Self { .init(.associationLimitExceeded) }
    public static var associationVersionLimitExceeded: Self { .init(.associationVersionLimitExceeded) }
    public static var automationDefinitionNotFoundException: Self { .init(.automationDefinitionNotFoundException) }
    public static var automationDefinitionVersionNotFoundException: Self { .init(.automationDefinitionVersionNotFoundException) }
    public static var automationExecutionLimitExceededException: Self { .init(.automationExecutionLimitExceededException) }
    public static var automationExecutionNotFoundException: Self { .init(.automationExecutionNotFoundException) }
    public static var automationStepNotFoundException: Self { .init(.automationStepNotFoundException) }
    public static var complianceTypeCountLimitExceededException: Self { .init(.complianceTypeCountLimitExceededException) }
    public static var customSchemaCountLimitExceededException: Self { .init(.customSchemaCountLimitExceededException) }
    public static var documentAlreadyExists: Self { .init(.documentAlreadyExists) }
    public static var documentLimitExceeded: Self { .init(.documentLimitExceeded) }
    public static var documentPermissionLimit: Self { .init(.documentPermissionLimit) }
    public static var documentVersionLimitExceeded: Self { .init(.documentVersionLimitExceeded) }
    public static var doesNotExistException: Self { .init(.doesNotExistException) }
    public static var duplicateDocumentContent: Self { .init(.duplicateDocumentContent) }
    public static var duplicateDocumentVersionName: Self { .init(.duplicateDocumentVersionName) }
    public static var duplicateInstanceId: Self { .init(.duplicateInstanceId) }
    public static var featureNotAvailableException: Self { .init(.featureNotAvailableException) }
    public static var hierarchyLevelLimitExceededException: Self { .init(.hierarchyLevelLimitExceededException) }
    public static var hierarchyTypeMismatchException: Self { .init(.hierarchyTypeMismatchException) }
    public static var idempotentParameterMismatch: Self { .init(.idempotentParameterMismatch) }
    public static var incompatiblePolicyException: Self { .init(.incompatiblePolicyException) }
    public static var internalServerError: Self { .init(.internalServerError) }
    public static var invalidActivation: Self { .init(.invalidActivation) }
    public static var invalidActivationId: Self { .init(.invalidActivationId) }
    public static var invalidAggregatorException: Self { .init(.invalidAggregatorException) }
    public static var invalidAllowedPatternException: Self { .init(.invalidAllowedPatternException) }
    public static var invalidAssociation: Self { .init(.invalidAssociation) }
    public static var invalidAssociationVersion: Self { .init(.invalidAssociationVersion) }
    public static var invalidAutomationExecutionParametersException: Self { .init(.invalidAutomationExecutionParametersException) }
    public static var invalidAutomationSignalException: Self { .init(.invalidAutomationSignalException) }
    public static var invalidAutomationStatusUpdateException: Self { .init(.invalidAutomationStatusUpdateException) }
    public static var invalidCommandId: Self { .init(.invalidCommandId) }
    public static var invalidDeleteInventoryParametersException: Self { .init(.invalidDeleteInventoryParametersException) }
    public static var invalidDeletionIdException: Self { .init(.invalidDeletionIdException) }
    public static var invalidDocument: Self { .init(.invalidDocument) }
    public static var invalidDocumentContent: Self { .init(.invalidDocumentContent) }
    public static var invalidDocumentOperation: Self { .init(.invalidDocumentOperation) }
    public static var invalidDocumentSchemaVersion: Self { .init(.invalidDocumentSchemaVersion) }
    public static var invalidDocumentType: Self { .init(.invalidDocumentType) }
    public static var invalidDocumentVersion: Self { .init(.invalidDocumentVersion) }
    public static var invalidFilter: Self { .init(.invalidFilter) }
    public static var invalidFilterKey: Self { .init(.invalidFilterKey) }
    public static var invalidFilterOption: Self { .init(.invalidFilterOption) }
    public static var invalidFilterValue: Self { .init(.invalidFilterValue) }
    public static var invalidInstanceId: Self { .init(.invalidInstanceId) }
    public static var invalidInstanceInformationFilterValue: Self { .init(.invalidInstanceInformationFilterValue) }
    public static var invalidInventoryGroupException: Self { .init(.invalidInventoryGroupException) }
    public static var invalidInventoryItemContextException: Self { .init(.invalidInventoryItemContextException) }
    public static var invalidInventoryRequestException: Self { .init(.invalidInventoryRequestException) }
    public static var invalidItemContentException: Self { .init(.invalidItemContentException) }
    public static var invalidKeyId: Self { .init(.invalidKeyId) }
    public static var invalidNextToken: Self { .init(.invalidNextToken) }
    public static var invalidNotificationConfig: Self { .init(.invalidNotificationConfig) }
    public static var invalidOptionException: Self { .init(.invalidOptionException) }
    public static var invalidOutputFolder: Self { .init(.invalidOutputFolder) }
    public static var invalidOutputLocation: Self { .init(.invalidOutputLocation) }
    public static var invalidParameters: Self { .init(.invalidParameters) }
    public static var invalidPermissionType: Self { .init(.invalidPermissionType) }
    public static var invalidPluginName: Self { .init(.invalidPluginName) }
    public static var invalidPolicyAttributeException: Self { .init(.invalidPolicyAttributeException) }
    public static var invalidPolicyTypeException: Self { .init(.invalidPolicyTypeException) }
    public static var invalidResourceId: Self { .init(.invalidResourceId) }
    public static var invalidResourceType: Self { .init(.invalidResourceType) }
    public static var invalidResultAttributeException: Self { .init(.invalidResultAttributeException) }
    public static var invalidRole: Self { .init(.invalidRole) }
    public static var invalidSchedule: Self { .init(.invalidSchedule) }
    public static var invalidTarget: Self { .init(.invalidTarget) }
    public static var invalidTypeNameException: Self { .init(.invalidTypeNameException) }
    public static var invalidUpdate: Self { .init(.invalidUpdate) }
    public static var invocationDoesNotExist: Self { .init(.invocationDoesNotExist) }
    public static var itemContentMismatchException: Self { .init(.itemContentMismatchException) }
    public static var itemSizeLimitExceededException: Self { .init(.itemSizeLimitExceededException) }
    public static var maxDocumentSizeExceeded: Self { .init(.maxDocumentSizeExceeded) }
    public static var opsItemAlreadyExistsException: Self { .init(.opsItemAlreadyExistsException) }
    public static var opsItemInvalidParameterException: Self { .init(.opsItemInvalidParameterException) }
    public static var opsItemLimitExceededException: Self { .init(.opsItemLimitExceededException) }
    public static var opsItemNotFoundException: Self { .init(.opsItemNotFoundException) }
    public static var parameterAlreadyExists: Self { .init(.parameterAlreadyExists) }
    public static var parameterLimitExceeded: Self { .init(.parameterLimitExceeded) }
    public static var parameterMaxVersionLimitExceeded: Self { .init(.parameterMaxVersionLimitExceeded) }
    public static var parameterNotFound: Self { .init(.parameterNotFound) }
    public static var parameterPatternMismatchException: Self { .init(.parameterPatternMismatchException) }
    public static var parameterVersionLabelLimitExceeded: Self { .init(.parameterVersionLabelLimitExceeded) }
    public static var parameterVersionNotFound: Self { .init(.parameterVersionNotFound) }
    public static var policiesLimitExceededException: Self { .init(.policiesLimitExceededException) }
    public static var resourceDataSyncAlreadyExistsException: Self { .init(.resourceDataSyncAlreadyExistsException) }
    public static var resourceDataSyncConflictException: Self { .init(.resourceDataSyncConflictException) }
    public static var resourceDataSyncCountExceededException: Self { .init(.resourceDataSyncCountExceededException) }
    public static var resourceDataSyncInvalidConfigurationException: Self { .init(.resourceDataSyncInvalidConfigurationException) }
    public static var resourceDataSyncNotFoundException: Self { .init(.resourceDataSyncNotFoundException) }
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    public static var serviceSettingNotFound: Self { .init(.serviceSettingNotFound) }
    public static var statusUnchanged: Self { .init(.statusUnchanged) }
    public static var subTypeCountLimitExceededException: Self { .init(.subTypeCountLimitExceededException) }
    public static var targetInUseException: Self { .init(.targetInUseException) }
    public static var targetNotConnected: Self { .init(.targetNotConnected) }
    public static var tooManyTagsError: Self { .init(.tooManyTagsError) }
    public static var tooManyUpdates: Self { .init(.tooManyUpdates) }
    public static var totalSizeLimitExceededException: Self { .init(.totalSizeLimitExceededException) }
    public static var unsupportedCalendarException: Self { .init(.unsupportedCalendarException) }
    public static var unsupportedFeatureRequiredException: Self { .init(.unsupportedFeatureRequiredException) }
    public static var unsupportedInventoryItemContextException: Self { .init(.unsupportedInventoryItemContextException) }
    public static var unsupportedInventorySchemaVersionException: Self { .init(.unsupportedInventorySchemaVersionException) }
    public static var unsupportedOperatingSystem: Self { .init(.unsupportedOperatingSystem) }
    public static var unsupportedParameterType: Self { .init(.unsupportedParameterType) }
    public static var unsupportedPlatformType: Self { .init(.unsupportedPlatformType) }
}

extension SSMErrorType: Equatable {
    public static func == (lhs: SSMErrorType, rhs: SSMErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SSMErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}

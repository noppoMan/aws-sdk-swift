//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import SotoCore

extension IoTSiteWise {
    // MARK: Enums

    public enum AggregateType: String, CustomStringConvertible, Codable {
        case average = "AVERAGE"
        case count = "COUNT"
        case maximum = "MAXIMUM"
        case minimum = "MINIMUM"
        case sum = "SUM"
        case standardDeviation = "STANDARD_DEVIATION"
        public var description: String { return self.rawValue }
    }

    public enum AssetErrorCode: String, CustomStringConvertible, Codable {
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum AssetModelState: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case active = "ACTIVE"
        case updating = "UPDATING"
        case propagating = "PROPAGATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum AssetState: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case active = "ACTIVE"
        case updating = "UPDATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum AuthMode: String, CustomStringConvertible, Codable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum BatchPutAssetPropertyValueErrorCode: String, CustomStringConvertible, Codable {
        case resourcenotfoundexception = "ResourceNotFoundException"
        case invalidrequestexception = "InvalidRequestException"
        case internalfailureexception = "InternalFailureException"
        case serviceunavailableexception = "ServiceUnavailableException"
        case throttlingexception = "ThrottlingException"
        case limitexceededexception = "LimitExceededException"
        case conflictingoperationexception = "ConflictingOperationException"
        case timestampoutofrangeexception = "TimestampOutOfRangeException"
        case accessdeniedexception = "AccessDeniedException"
        public var description: String { return self.rawValue }
    }

    public enum CapabilitySyncStatus: String, CustomStringConvertible, Codable {
        case inSync = "IN_SYNC"
        case outOfSync = "OUT_OF_SYNC"
        case syncFailed = "SYNC_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable {
        case validationError = "VALIDATION_ERROR"
        case internalFailure = "INTERNAL_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable {
        case user = "USER"
        case group = "GROUP"
        case iam = "IAM"
        public var description: String { return self.rawValue }
    }

    public enum ImageFileType: String, CustomStringConvertible, Codable {
        case png = "PNG"
        public var description: String { return self.rawValue }
    }

    public enum ListAssetsFilter: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case topLevel = "TOP_LEVEL"
        public var description: String { return self.rawValue }
    }

    public enum LoggingLevel: String, CustomStringConvertible, Codable {
        case error = "ERROR"
        case info = "INFO"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum MonitorErrorCode: String, CustomStringConvertible, Codable {
        case internalFailure = "INTERNAL_FAILURE"
        case validationError = "VALIDATION_ERROR"
        case limitExceeded = "LIMIT_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable {
        case administrator = "ADMINISTRATOR"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum PortalState: String, CustomStringConvertible, Codable {
        case creating = "CREATING"
        case updating = "UPDATING"
        case deleting = "DELETING"
        case active = "ACTIVE"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum PropertyDataType: String, CustomStringConvertible, Codable {
        case string = "STRING"
        case integer = "INTEGER"
        case double = "DOUBLE"
        case boolean = "BOOLEAN"
        public var description: String { return self.rawValue }
    }

    public enum PropertyNotificationState: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum Quality: String, CustomStringConvertible, Codable {
        case good = "GOOD"
        case bad = "BAD"
        case uncertain = "UNCERTAIN"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable {
        case portal = "PORTAL"
        case project = "PROJECT"
        public var description: String { return self.rawValue }
    }

    public enum TimeOrdering: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TraversalDirection: String, CustomStringConvertible, Codable {
        case parent = "PARENT"
        case child = "CHILD"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPolicySummary: AWSDecodableShape {

        /// The date the access policy was created, in Unix epoch time.
        public let creationDate: Date?
        /// The ID of the access policy.
        public let id: String
        /// The identity (an AWS SSO user, an AWS SSO group, or an IAM user).
        public let identity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let permission: Permission
        /// The AWS IoT SiteWise Monitor resource (a portal or project).
        public let resource: Resource

        public init(creationDate: Date? = nil, id: String, identity: Identity, lastUpdateDate: Date? = nil, permission: Permission, resource: Resource) {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case id = "id"
            case identity = "identity"
            case lastUpdateDate = "lastUpdateDate"
            case permission = "permission"
            case resource = "resource"
        }
    }

    public struct AggregatedValue: AWSDecodableShape {

        /// The quality of the aggregated data.
        public let quality: Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        public let timestamp: Date
        /// The value of the aggregates.
        public let value: Aggregates

        public init(quality: Quality? = nil, timestamp: Date, value: Aggregates) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case quality = "quality"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct Aggregates: AWSDecodableShape {

        /// The average (mean) value of the time series over a time interval window.
        public let average: Double?
        /// The count of data points in the time series over a time interval window.
        public let count: Double?
        /// The maximum value of the time series over a time interval window.
        public let maximum: Double?
        /// The minimum value of the time series over a time interval window.
        public let minimum: Double?
        /// The standard deviation of the time series over a time interval window.
        public let standardDeviation: Double?
        /// The sum of the time series over a time interval window.
        public let sum: Double?

        public init(average: Double? = nil, count: Double? = nil, maximum: Double? = nil, minimum: Double? = nil, standardDeviation: Double? = nil, sum: Double? = nil) {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }

        private enum CodingKeys: String, CodingKey {
            case average = "average"
            case count = "count"
            case maximum = "maximum"
            case minimum = "minimum"
            case standardDeviation = "standardDeviation"
            case sum = "sum"
        }
    }

    public struct AssetErrorDetails: AWSDecodableShape {

        /// The ID of the asset.
        public let assetId: String
        /// The error code.
        public let code: AssetErrorCode
        /// The error message.
        public let message: String

        public init(assetId: String, code: AssetErrorCode, message: String) {
            self.assetId = assetId
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case code = "code"
            case message = "message"
        }
    }

    public struct AssetHierarchy: AWSDecodableShape {

        /// The ID of the hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The hierarchy name provided in the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(id: String? = nil, name: String) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelHierarchy: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the asset model. All assets in this hierarchy must be instances of the childAssetModelId asset model.
        public let childAssetModelId: String
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.
        public let id: String?
        /// The name of the asset model hierarchy that you specify by using the CreateAssetModel or UpdateAssetModel API operation.
        public let name: String

        public init(childAssetModelId: String, id: String? = nil, name: String) {
            self.childAssetModelId = childAssetModelId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId = "childAssetModelId"
            case id = "id"
            case name = "name"
        }
    }

    public struct AssetModelHierarchyDefinition: AWSEncodableShape {

        /// The ID of an asset model for this hierarchy.
        public let childAssetModelId: String
        /// The name of the asset model hierarchy definition (as specified in the CreateAssetModel or UpdateAssetModel API operation).
        public let name: String

        public init(childAssetModelId: String, name: String) {
            self.childAssetModelId = childAssetModelId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, max: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, min: 36)
            try self.validate(self.childAssetModelId, name: "childAssetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetModelId = "childAssetModelId"
            case name = "name"
        }
    }

    public struct AssetModelProperty: AWSEncodableShape & AWSDecodableShape {

        /// The data type of the asset model property.
        public let dataType: PropertyDataType
        /// The ID of the asset model property.
        public let id: String?
        /// The name of the asset model property.
        public let name: String
        /// The property type (see PropertyType).
        public let `type`: PropertyType
        /// The unit of the asset model property, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, id: String? = nil, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.id = id
            self.name = name
            self.`type` = `type`
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.`type`.validate(name: "\(name).`type`")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case id = "id"
            case name = "name"
            case `type` = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelPropertyDefinition: AWSEncodableShape {

        /// The data type of the property definition.
        public let dataType: PropertyDataType
        /// The name of the property definition.
        public let name: String
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        public let `type`: PropertyType
        /// The unit of the property definition, such as Newtons or RPM.
        public let unit: String?

        public init(dataType: PropertyDataType, name: String, type: PropertyType, unit: String? = nil) {
            self.dataType = dataType
            self.name = name
            self.`type` = `type`
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.`type`.validate(name: "\(name).`type`")
            try self.validate(self.unit, name: "unit", parent: name, max: 256)
            try self.validate(self.unit, name: "unit", parent: name, min: 1)
            try self.validate(self.unit, name: "unit", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case name = "name"
            case `type` = "type"
            case unit = "unit"
        }
    }

    public struct AssetModelStatus: AWSDecodableShape {

        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current state of the asset model.
        public let state: AssetModelState

        public init(error: ErrorDetails? = nil, state: AssetModelState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct AssetModelSummary: AWSDecodableShape {

        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId} 
        public let arn: String
        /// The date the asset model was created, in Unix epoch time.
        public let creationDate: Date
        /// The asset model description.
        public let description: String
        /// The ID of the asset model (used with AWS IoT SiteWise APIs).
        public let id: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset model.
        public let name: String
        /// The current status of the asset model.
        public let status: AssetModelStatus

        public init(arn: String, creationDate: Date, description: String, id: String, lastUpdateDate: Date, name: String, status: AssetModelStatus) {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssetProperty: AWSDecodableShape {

        /// The property alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the AWS IoT SiteWise User Guide.
        public let alias: String?
        /// The data type of the asset property.
        public let dataType: PropertyDataType
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, id: String, name: String, notification: PropertyNotification? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.id = id
            self.name = name
            self.notification = notification
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case dataType = "dataType"
            case id = "id"
            case name = "name"
            case notification = "notification"
            case unit = "unit"
        }
    }

    public struct AssetPropertyValue: AWSEncodableShape & AWSDecodableShape {

        /// The quality of the asset property value.
        public let quality: Quality?
        /// The timestamp of the asset property value.
        public let timestamp: TimeInNanos
        /// The value of the asset property (see Variant).
        public let value: Variant

        public init(quality: Quality? = nil, timestamp: TimeInNanos, value: Variant) {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }

        public func validate(name: String) throws {
            try self.timestamp.validate(name: "\(name).timestamp")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case quality = "quality"
            case timestamp = "timestamp"
            case value = "value"
        }
    }

    public struct AssetStatus: AWSDecodableShape {

        /// Contains associated error information, if any.
        public let error: ErrorDetails?
        /// The current status of the asset.
        public let state: AssetState

        public init(error: ErrorDetails? = nil, state: AssetState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct AssetSummary: AWSDecodableShape {

        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId} 
        public let arn: String
        /// The ID of the asset model used to create this asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelId = "assetModelId"
            case creationDate = "creationDate"
            case hierarchies = "hierarchies"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssociateAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the parent asset.
        public let assetId: String
        /// The ID of the child asset to be associated.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see Asset hierarchies in the AWS IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = AssociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case clientToken = "clientToken"
            case hierarchyId = "hierarchyId"
        }
    }

    public struct AssociatedAssetsSummary: AWSDecodableShape {

        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId} 
        public let arn: String
        /// The ID of the asset model used to create the asset.
        public let assetModelId: String
        /// The date the asset was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let hierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let id: String
        /// The date the asset was last updated, in Unix epoch time.
        public let lastUpdateDate: Date
        /// The name of the asset.
        public let name: String
        /// The current status of the asset.
        public let status: AssetStatus

        public init(arn: String, assetModelId: String, creationDate: Date, hierarchies: [AssetHierarchy], id: String, lastUpdateDate: Date, name: String, status: AssetStatus) {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case assetModelId = "assetModelId"
            case creationDate = "creationDate"
            case hierarchies = "hierarchies"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case status = "status"
        }
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {

        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see Updating attribute values in the AWS IoT SiteWise User Guide.
        public let defaultValue: String?

        public init(defaultValue: String? = nil) {
            self.defaultValue = defaultValue
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 1024)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, min: 1)
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
        }
    }

    public struct BatchAssociateProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The IDs of the assets to be associated to the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project to which to associate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchAssociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case clientToken = "clientToken"
        }
    }

    public struct BatchAssociateProjectAssetsResponse: AWSDecodableShape {

        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchDisassociateProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The IDs of the assets to be disassociated from the project.
        public let assetIds: [String]
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project from which to disassociate the assets.
        public let projectId: String

        public init(assetIds: [String], clientToken: String? = BatchDisassociateProjectAssetsRequest.idempotencyToken(), projectId: String) {
            self.assetIds = assetIds
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.assetIds.forEach {
                try validate($0, name: "assetIds[]", parent: name, max: 36)
                try validate($0, name: "assetIds[]", parent: name, min: 36)
                try validate($0, name: "assetIds[]", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            }
            try self.validate(self.assetIds, name: "assetIds", parent: name, max: 100)
            try self.validate(self.assetIds, name: "assetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case clientToken = "clientToken"
        }
    }

    public struct BatchDisassociateProjectAssetsResponse: AWSDecodableShape {

        /// A list of associated error information, if any.
        public let errors: [AssetErrorDetails]?

        public init(errors: [AssetErrorDetails]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchPutAssetPropertyError: AWSDecodableShape {

        /// The error code.
        public let errorCode: BatchPutAssetPropertyValueErrorCode
        /// The associated error message.
        public let errorMessage: String
        /// A list of timestamps for each error, if any.
        public let timestamps: [TimeInNanos]

        public init(errorCode: BatchPutAssetPropertyValueErrorCode, errorMessage: String, timestamps: [TimeInNanos]) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case timestamps = "timestamps"
        }
    }

    public struct BatchPutAssetPropertyErrorEntry: AWSDecodableShape {

        /// The ID of the failed entry.
        public let entryId: String
        /// The list of update property value errors.
        public let errors: [BatchPutAssetPropertyError]

        public init(entryId: String, errors: [BatchPutAssetPropertyError]) {
            self.entryId = entryId
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case entryId = "entryId"
            case errors = "errors"
        }
    }

    public struct BatchPutAssetPropertyValueRequest: AWSEncodableShape {

        /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
        public let entries: [PutAssetPropertyValueEntry]

        public init(entries: [PutAssetPropertyValueEntry]) {
            self.entries = entries
        }

        public func validate(name: String) throws {
            try self.entries.forEach {
                try $0.validate(name: "\(name).entries[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case entries = "entries"
        }
    }

    public struct BatchPutAssetPropertyValueResponse: AWSDecodableShape {

        /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
        public let errorEntries: [BatchPutAssetPropertyErrorEntry]

        public init(errorEntries: [BatchPutAssetPropertyErrorEntry]) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "errorEntries"
        }
    }

    public struct CreateAccessPolicyRequest: AWSEncodableShape {

        /// The identity for this access policy. Choose an AWS SSO user, an AWS SSO group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The AWS IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the access policy. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = CreateAccessPolicyRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAccessPolicyResponse: AWSDecodableShape {

        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId} 
        public let accessPolicyArn: String
        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyArn: String, accessPolicyId: String) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyId = accessPolicyId
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn = "accessPolicyArn"
            case accessPolicyId = "accessPolicyId"
        }
    }

    public struct CreateAssetModelRequest: AWSEncodableShape {

        /// A description for the asset model.
        public let assetModelDescription: String?
        /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the AWS IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the AWS IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchyDefinition]?
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The property definitions of the asset model. For more information, see Asset properties in the AWS IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the AWS IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelPropertyDefinition]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset model. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetModelDescription: String? = nil, assetModelHierarchies: [AssetModelHierarchyDefinition]? = nil, assetModelName: String, assetModelProperties: [AssetModelPropertyDefinition]? = nil, clientToken: String? = CreateAssetModelRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelDescription = "assetModelDescription"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssetModelResponse: AWSDecodableShape {

        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId} 
        public let assetModelArn: String
        /// The ID of the asset model. You can use this ID when you call other AWS IoT SiteWise APIs.
        public let assetModelId: String
        /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelArn: String, assetModelId: String, assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelId = assetModelId
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn = "assetModelArn"
            case assetModelId = "assetModelId"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct CreateAssetRequest: AWSEncodableShape {

        /// The ID of the asset model from which to create the asset.
        public let assetModelId: String
        /// A unique, friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A list of key-value pairs that contain metadata for the asset. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(assetModelId: String, assetName: String, clientToken: String? = CreateAssetRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateAssetResponse: AWSDecodableShape {

        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId} 
        public let assetArn: String
        /// The ID of the asset. This ID uniquely identifies the asset within AWS IoT SiteWise and can be used with other AWS IoT SiteWise APIs.
        public let assetId: String
        /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetId: String, assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetId = assetId
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn = "assetArn"
            case assetId = "assetId"
            case assetStatus = "assetStatus"
        }
    }

    public struct CreateDashboardRequest: AWSEncodableShape {

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The dashboard definition specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the AWS IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A description for the dashboard.
        public let dashboardDescription: String?
        /// A friendly name for the dashboard.
        public let dashboardName: String
        /// The ID of the project in which to create the dashboard.
        public let projectId: String
        /// A list of key-value pairs that contain metadata for the dashboard. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardName: String, projectId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardName = dashboardName
            self.projectId = projectId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, min: 0)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: ".+")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardName = "dashboardName"
            case projectId = "projectId"
            case tags = "tags"
        }
    }

    public struct CreateDashboardResponse: AWSDecodableShape {

        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId} 
        public let dashboardArn: String
        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardArn: String, dashboardId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardId = dashboardId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "dashboardArn"
            case dashboardId = "dashboardId"
        }
    }

    public struct CreateGatewayRequest: AWSEncodableShape {

        /// A unique, friendly name for the gateway.
        public let gatewayName: String
        /// The gateway's platform. You can only specify one platform in a gateway.
        public let gatewayPlatform: GatewayPlatform
        /// A list of key-value pairs that contain metadata for the gateway. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(gatewayName: String, gatewayPlatform: GatewayPlatform, tags: [String: String]? = nil) {
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.gatewayPlatform.validate(name: "\(name).gatewayPlatform")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case tags = "tags"
        }
    }

    public struct CreateGatewayResponse: AWSDecodableShape {

        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId} 
        public let gatewayArn: String
        /// The ID of the gateway device. You can use this ID when you call other AWS IoT SiteWise APIs.
        public let gatewayId: String

        public init(gatewayArn: String, gatewayId: String) {
            self.gatewayArn = gatewayArn
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn = "gatewayArn"
            case gatewayId = "gatewayId"
        }
    }

    public struct CreatePortalRequest: AWSEncodableShape {

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The service to use to authenticate users to the portal. Choose from the following options:    SSO – The portal uses AWS Single Sign-On to authenticate users and manage user permissions. Before you can create a portal that uses AWS SSO, you must enable AWS SSO. For more information, see Enabling AWS SSO in the AWS IoT SiteWise User Guide. This option is only available in AWS Regions other than the China Regions.    IAM – The portal uses AWS Identity and Access Management (IAM) to authenticate users and manage user permissions. IAM users must have the iotsitewise:CreatePresignedPortalUrl permission to sign in to the portal. This option is only available in the China Regions.   You can't change this value after you create a portal. Default: SSO 
        public let portalAuthMode: AuthMode?
        /// The AWS administrator's contact email address.
        public let portalContactEmail: String
        /// A description for the portal.
        public let portalDescription: String?
        /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
        public let portalLogoImageFile: ImageFile?
        /// A friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your AWS IoT SiteWise resources on your behalf. For more information, see Using service roles for AWS IoT SiteWise Monitor in the AWS IoT SiteWise User Guide.
        public let roleArn: String
        /// A list of key-value pairs that contain metadata for the portal. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreatePortalRequest.idempotencyToken(), portalAuthMode: AuthMode? = nil, portalContactEmail: String, portalDescription: String? = nil, portalLogoImageFile: ImageFile? = nil, portalName: String, roleArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.portalAuthMode = portalAuthMode
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalLogoImageFile = portalLogoImageFile
            self.portalName = portalName
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "[^@]+@[^@]+")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.portalLogoImageFile?.validate(name: "\(name).portalLogoImageFile")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case portalAuthMode = "portalAuthMode"
            case portalContactEmail = "portalContactEmail"
            case portalDescription = "portalDescription"
            case portalLogoImageFile = "portalLogoImageFile"
            case portalName = "portalName"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreatePortalResponse: AWSDecodableShape {

        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId} 
        public let portalArn: String
        /// The ID of the created portal.
        public let portalId: String
        /// The URL for the AWS IoT SiteWise Monitor portal. You can use this URL to access portals that use AWS SSO for authentication. For portals that use IAM for authentication, you must use the CreatePresignedPortalUrl operation to create a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus
        /// The associated AWS SSO application ID, if the portal uses AWS SSO.
        public let ssoApplicationId: String

        public init(portalArn: String, portalId: String, portalStartUrl: String, portalStatus: PortalStatus, ssoApplicationId: String) {
            self.portalArn = portalArn
            self.portalId = portalId
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.ssoApplicationId = ssoApplicationId
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case portalId = "portalId"
            case portalStartUrl = "portalStartUrl"
            case portalStatus = "portalStatus"
            case ssoApplicationId = "ssoApplicationId"
        }
    }

    public struct CreatePresignedPortalUrlRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "portalId", location: .uri(locationName: "portalId")), 
            AWSMemberEncoding(label: "sessionDurationSeconds", location: .querystring(locationName: "sessionDurationSeconds"))
        ]

        /// The ID of the portal to access.
        public let portalId: String
        /// The duration (in seconds) for which the session at the URL is valid. Default: 900 seconds (15 minutes)
        public let sessionDurationSeconds: Int?

        public init(portalId: String, sessionDurationSeconds: Int? = nil) {
            self.portalId = portalId
            self.sessionDurationSeconds = sessionDurationSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.sessionDurationSeconds, name: "sessionDurationSeconds", parent: name, max: 43200)
            try self.validate(self.sessionDurationSeconds, name: "sessionDurationSeconds", parent: name, min: 900)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreatePresignedPortalUrlResponse: AWSDecodableShape {

        /// The pre-signed URL to the portal. The URL contains the portal ID and a session token that lets you access the portal. The URL has the following format.  https://&lt;portal-id&gt;.app.iotsitewise.aws/auth?token=&lt;encrypted-token&gt; 
        public let presignedPortalUrl: String

        public init(presignedPortalUrl: String) {
            self.presignedPortalUrl = presignedPortalUrl
        }

        private enum CodingKeys: String, CodingKey {
            case presignedPortalUrl = "presignedPortalUrl"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal in which to create the project.
        public let portalId: String
        /// A description for the project.
        public let projectDescription: String?
        /// A friendly name for the project.
        public let projectName: String
        /// A list of key-value pairs that contain metadata for the project. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateProjectRequest.idempotencyToken(), portalId: String, projectDescription: String? = nil, projectName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.portalId = portalId
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case portalId = "portalId"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
            case tags = "tags"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {

        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId} 
        public let projectArn: String
        /// The ID of the project.
        public let projectId: String

        public init(projectArn: String, projectId: String) {
            self.projectArn = projectArn
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "projectArn"
            case projectId = "projectId"
        }
    }

    public struct DashboardSummary: AWSDecodableShape {

        /// The date the dashboard was created, in Unix epoch time.
        public let creationDate: Date?
        /// The dashboard's description.
        public let description: String?
        /// The ID of the dashboard.
        public let id: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the dashboard
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
        }
    }

    public struct DeleteAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri(locationName: "accessPolicyId")), 
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        /// The ID of the access policy to be deleted.
        public let accessPolicyId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, clientToken: String? = DeleteAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPolicyResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri(locationName: "assetModelId")), 
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        /// The ID of the asset model to delete.
        public let assetModelId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelId: String, clientToken: String? = DeleteAssetModelRequest.idempotencyToken()) {
            self.assetModelId = assetModelId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetModelResponse: AWSDecodableShape {

        /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")), 
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        /// The ID of the asset to delete.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetId: String, clientToken: String? = DeleteAssetRequest.idempotencyToken()) {
            self.assetId = assetId
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetResponse: AWSDecodableShape {

        /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus = "assetStatus"
        }
    }

    public struct DeleteDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken")), 
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "dashboardId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the dashboard to delete.
        public let dashboardId: String

        public init(clientToken: String? = DeleteDashboardRequest.idempotencyToken(), dashboardId: String) {
            self.clientToken = clientToken
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDashboardResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The ID of the gateway to delete.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken")), 
            AWSMemberEncoding(label: "portalId", location: .uri(locationName: "portalId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the portal to delete.
        public let portalId: String

        public init(clientToken: String? = DeletePortalRequest.idempotencyToken(), portalId: String) {
            self.clientToken = clientToken
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePortalResponse: AWSDecodableShape {

        /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus = "portalStatus"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken")), 
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(clientToken: String? = DeleteProjectRequest.idempotencyToken(), projectId: String) {
            self.clientToken = clientToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DescribeAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri(locationName: "accessPolicyId"))
        ]

        /// The ID of the access policy.
        public let accessPolicyId: String

        public init(accessPolicyId: String) {
            self.accessPolicyId = accessPolicyId
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAccessPolicyResponse: AWSDecodableShape {

        /// The ARN of the access policy, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId} 
        public let accessPolicyArn: String
        /// The date the access policy was created, in Unix epoch time.
        public let accessPolicyCreationDate: Date
        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity (AWS SSO user, AWS SSO group, or IAM user) to which this access policy applies.
        public let accessPolicyIdentity: Identity
        /// The date the access policy was last updated, in Unix epoch time.
        public let accessPolicyLastUpdateDate: Date
        /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The AWS IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
        public let accessPolicyResource: Resource

        public init(accessPolicyArn: String, accessPolicyCreationDate: Date, accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyLastUpdateDate: Date, accessPolicyPermission: Permission, accessPolicyResource: Resource) {
            self.accessPolicyArn = accessPolicyArn
            self.accessPolicyCreationDate = accessPolicyCreationDate
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyArn = "accessPolicyArn"
            case accessPolicyCreationDate = "accessPolicyCreationDate"
            case accessPolicyId = "accessPolicyId"
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyLastUpdateDate = "accessPolicyLastUpdateDate"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
        }
    }

    public struct DescribeAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri(locationName: "assetModelId"))
        ]

        /// The ID of the asset model.
        public let assetModelId: String

        public init(assetModelId: String) {
            self.assetModelId = assetModelId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetModelResponse: AWSDecodableShape {

        /// The ARN of the asset model, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId} 
        public let assetModelArn: String
        /// The date the asset model was created, in Unix epoch time.
        public let assetModelCreationDate: Date
        /// The asset model's description.
        public let assetModelDescription: String
        /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
        public let assetModelHierarchies: [AssetModelHierarchy]
        /// The ID of the asset model.
        public let assetModelId: String
        /// The date the asset model was last updated, in Unix epoch time.
        public let assetModelLastUpdateDate: Date
        /// The name of the asset model.
        public let assetModelName: String
        /// The list of asset properties for the asset model.
        public let assetModelProperties: [AssetModelProperty]
        /// The current status of the asset model, which contains a state and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelArn: String, assetModelCreationDate: Date, assetModelDescription: String, assetModelHierarchies: [AssetModelHierarchy], assetModelId: String, assetModelLastUpdateDate: Date, assetModelName: String, assetModelProperties: [AssetModelProperty], assetModelStatus: AssetModelStatus) {
            self.assetModelArn = assetModelArn
            self.assetModelCreationDate = assetModelCreationDate
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelLastUpdateDate = assetModelLastUpdateDate
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelArn = "assetModelArn"
            case assetModelCreationDate = "assetModelCreationDate"
            case assetModelDescription = "assetModelDescription"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelId = "assetModelId"
            case assetModelLastUpdateDate = "assetModelLastUpdateDate"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct DescribeAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")), 
            AWSMemberEncoding(label: "propertyId", location: .uri(locationName: "propertyId"))
        ]

        /// The ID of the asset.
        public let assetId: String
        /// The ID of the asset property.
        public let propertyId: String

        public init(assetId: String, propertyId: String) {
            self.assetId = assetId
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetPropertyResponse: AWSDecodableShape {

        /// The ID of the asset.
        public let assetId: String
        /// The ID of the asset model.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The asset property's definition, alias, and notification state.
        public let assetProperty: Property

        public init(assetId: String, assetModelId: String, assetName: String, assetProperty: Property) {
            self.assetId = assetId
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperty = assetProperty
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case assetProperty = "assetProperty"
        }
    }

    public struct DescribeAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the asset.
        public let assetId: String

        public init(assetId: String) {
            self.assetId = assetId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetResponse: AWSDecodableShape {

        /// The ARN of the asset, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId} 
        public let assetArn: String
        /// The date the asset was created, in Unix epoch time.
        public let assetCreationDate: Date
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        public let assetHierarchies: [AssetHierarchy]
        /// The ID of the asset.
        public let assetId: String
        /// The date the asset was last updated, in Unix epoch time.
        public let assetLastUpdateDate: Date
        /// The ID of the asset model that was used to create the asset.
        public let assetModelId: String
        /// The name of the asset.
        public let assetName: String
        /// The list of asset properties for the asset.
        public let assetProperties: [AssetProperty]
        /// The current status of the asset, which contains a state and any error message.
        public let assetStatus: AssetStatus

        public init(assetArn: String, assetCreationDate: Date, assetHierarchies: [AssetHierarchy], assetId: String, assetLastUpdateDate: Date, assetModelId: String, assetName: String, assetProperties: [AssetProperty], assetStatus: AssetStatus) {
            self.assetArn = assetArn
            self.assetCreationDate = assetCreationDate
            self.assetHierarchies = assetHierarchies
            self.assetId = assetId
            self.assetLastUpdateDate = assetLastUpdateDate
            self.assetModelId = assetModelId
            self.assetName = assetName
            self.assetProperties = assetProperties
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetArn = "assetArn"
            case assetCreationDate = "assetCreationDate"
            case assetHierarchies = "assetHierarchies"
            case assetId = "assetId"
            case assetLastUpdateDate = "assetLastUpdateDate"
            case assetModelId = "assetModelId"
            case assetName = "assetName"
            case assetProperties = "assetProperties"
            case assetStatus = "assetStatus"
        }
    }

    public struct DescribeDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "dashboardId"))
        ]

        /// The ID of the dashboard.
        public let dashboardId: String

        public init(dashboardId: String) {
            self.dashboardId = dashboardId
        }

        public func validate(name: String) throws {
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDashboardResponse: AWSDecodableShape {

        /// The ARN of the dashboard, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId} 
        public let dashboardArn: String
        /// The date the dashboard was created, in Unix epoch time.
        public let dashboardCreationDate: Date
        /// The dashboard's definition JSON literal. For detailed information, see Creating dashboards (CLI) in the AWS IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// The dashboard's description.
        public let dashboardDescription: String?
        /// The ID of the dashboard.
        public let dashboardId: String
        /// The date the dashboard was last updated, in Unix epoch time.
        public let dashboardLastUpdateDate: Date
        /// The name of the dashboard.
        public let dashboardName: String
        /// The ID of the project that the dashboard is in.
        public let projectId: String

        public init(dashboardArn: String, dashboardCreationDate: Date, dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardLastUpdateDate: Date, dashboardName: String, projectId: String) {
            self.dashboardArn = dashboardArn
            self.dashboardCreationDate = dashboardCreationDate
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardLastUpdateDate = dashboardLastUpdateDate
            self.dashboardName = dashboardName
            self.projectId = projectId
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardArn = "dashboardArn"
            case dashboardCreationDate = "dashboardCreationDate"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardId = "dashboardId"
            case dashboardLastUpdateDate = "dashboardLastUpdateDate"
            case dashboardName = "dashboardName"
            case projectId = "projectId"
        }
    }

    public struct DescribeGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "capabilityNamespace", location: .uri(locationName: "capabilityNamespace")), 
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the AWS IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityNamespace: String, gatewayId: String) {
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayCapabilityConfigurationResponse: AWSDecodableShape {

        /// The JSON document that defines the gateway capability's configuration. For more information, see Configuring data sources (CLI) in the AWS IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.  
        public let capabilitySyncStatus: CapabilitySyncStatus
        /// The ID of the gateway that defines the capability configuration.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
            self.gatewayId = gatewayId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration = "capabilityConfiguration"
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
            case gatewayId = "gatewayId"
        }
    }

    public struct DescribeGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The ID of the gateway device.
        public let gatewayId: String

        public init(gatewayId: String) {
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayResponse: AWSDecodableShape {

        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// The ARN of the gateway, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId} 
        public let gatewayArn: String
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the gateway.
        public let gatewayName: String
        /// The gateway's platform.
        public let gatewayPlatform: GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayArn: String, gatewayCapabilitySummaries: [GatewayCapabilitySummary], gatewayId: String, gatewayName: String, gatewayPlatform: GatewayPlatform? = nil, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayArn = gatewayArn
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case gatewayArn = "gatewayArn"
            case gatewayCapabilitySummaries = "gatewayCapabilitySummaries"
            case gatewayId = "gatewayId"
            case gatewayName = "gatewayName"
            case gatewayPlatform = "gatewayPlatform"
            case lastUpdateDate = "lastUpdateDate"
        }
    }

    public struct DescribeLoggingOptionsRequest: AWSEncodableShape {


        public init() {
        }

    }

    public struct DescribeLoggingOptionsResponse: AWSDecodableShape {

        /// The current logging options.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions = "loggingOptions"
        }
    }

    public struct DescribePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "portalId", location: .uri(locationName: "portalId"))
        ]

        /// The ID of the portal.
        public let portalId: String

        public init(portalId: String) {
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePortalResponse: AWSDecodableShape {

        /// The ARN of the portal, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId} 
        public let portalArn: String
        /// The service to use to authenticate users to the portal.
        public let portalAuthMode: AuthMode?
        /// The AWS SSO application generated client ID (used with AWS SSO APIs). AWS IoT SiteWise includes portalClientId for only portals that use AWS SSO to authenticate users.
        public let portalClientId: String
        /// The AWS administrator's contact email address.
        public let portalContactEmail: String
        /// The date the portal was created, in Unix epoch time.
        public let portalCreationDate: Date
        /// The portal's description.
        public let portalDescription: String?
        /// The ID of the portal.
        public let portalId: String
        /// The date the portal was last updated, in Unix epoch time.
        public let portalLastUpdateDate: Date
        /// The portal's logo image, which is available at a URL.
        public let portalLogoImageLocation: ImageLocation?
        /// The name of the portal.
        public let portalName: String
        /// The URL for the AWS IoT SiteWise Monitor portal. You can use this URL to access portals that use AWS SSO for authentication. For portals that use IAM for authentication, you must use the CreatePresignedPortalUrl operation to create a URL that you can use to access the portal.
        public let portalStartUrl: String
        /// The current status of the portal, which contains a state and any error message.
        public let portalStatus: PortalStatus
        /// The ARN of the service role that allows the portal's users to access your AWS IoT SiteWise resources on your behalf. For more information, see Using service roles for AWS IoT SiteWise Monitor in the AWS IoT SiteWise User Guide.
        public let roleArn: String?

        public init(portalArn: String, portalAuthMode: AuthMode? = nil, portalClientId: String, portalContactEmail: String, portalCreationDate: Date, portalDescription: String? = nil, portalId: String, portalLastUpdateDate: Date, portalLogoImageLocation: ImageLocation? = nil, portalName: String, portalStartUrl: String, portalStatus: PortalStatus, roleArn: String? = nil) {
            self.portalArn = portalArn
            self.portalAuthMode = portalAuthMode
            self.portalClientId = portalClientId
            self.portalContactEmail = portalContactEmail
            self.portalCreationDate = portalCreationDate
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLastUpdateDate = portalLastUpdateDate
            self.portalLogoImageLocation = portalLogoImageLocation
            self.portalName = portalName
            self.portalStartUrl = portalStartUrl
            self.portalStatus = portalStatus
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case portalArn = "portalArn"
            case portalAuthMode = "portalAuthMode"
            case portalClientId = "portalClientId"
            case portalContactEmail = "portalContactEmail"
            case portalCreationDate = "portalCreationDate"
            case portalDescription = "portalDescription"
            case portalId = "portalId"
            case portalLastUpdateDate = "portalLastUpdateDate"
            case portalLogoImageLocation = "portalLogoImageLocation"
            case portalName = "portalName"
            case portalStartUrl = "portalStartUrl"
            case portalStatus = "portalStatus"
            case roleArn = "roleArn"
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The ID of the project.
        public let projectId: String

        public init(projectId: String) {
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {

        /// The ID of the portal that the project is in.
        public let portalId: String
        /// The ARN of the project, which has the following format.  arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId} 
        public let projectArn: String
        /// The date the project was created, in Unix epoch time.
        public let projectCreationDate: Date
        /// The project's description.
        public let projectDescription: String?
        /// The ID of the project.
        public let projectId: String
        /// The date the project was last updated, in Unix epoch time.
        public let projectLastUpdateDate: Date
        /// The name of the project.
        public let projectName: String

        public init(portalId: String, projectArn: String, projectCreationDate: Date, projectDescription: String? = nil, projectId: String, projectLastUpdateDate: Date, projectName: String) {
            self.portalId = portalId
            self.projectArn = projectArn
            self.projectCreationDate = projectCreationDate
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectLastUpdateDate = projectLastUpdateDate
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case portalId = "portalId"
            case projectArn = "projectArn"
            case projectCreationDate = "projectCreationDate"
            case projectDescription = "projectDescription"
            case projectId = "projectId"
            case projectLastUpdateDate = "projectLastUpdateDate"
            case projectName = "projectName"
        }
    }

    public struct DisassociateAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the parent asset from which to disassociate the child asset.
        public let assetId: String
        /// The ID of the child asset to disassociate.
        public let childAssetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see Asset hierarchies in the AWS IoT SiteWise User Guide.
        public let hierarchyId: String

        public init(assetId: String, childAssetId: String, clientToken: String? = DisassociateAssetsRequest.idempotencyToken(), hierarchyId: String) {
            self.assetId = assetId
            self.childAssetId = childAssetId
            self.clientToken = clientToken
            self.hierarchyId = hierarchyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, max: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, min: 36)
            try self.validate(self.childAssetId, name: "childAssetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case childAssetId = "childAssetId"
            case clientToken = "clientToken"
            case hierarchyId = "hierarchyId"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {

        /// The error code.
        public let code: ErrorCode
        /// The error message.
        public let message: String

        public init(code: ErrorCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ExpressionVariable: AWSEncodableShape & AWSDecodableShape {

        /// The friendly name of the variable to be used in the expression.
        public let name: String
        /// The variable that identifies an asset property from which to use values.
        public let value: VariableValue

        public init(name: String, value: VariableValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct GatewayCapabilitySummary: AWSDecodableShape {

        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the AWS IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.  
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
        }
    }

    public struct GatewayPlatform: AWSEncodableShape & AWSDecodableShape {

        /// A gateway that runs on AWS IoT Greengrass.
        public let greengrass: Greengrass

        public init(greengrass: Greengrass) {
            self.greengrass = greengrass
        }

        public func validate(name: String) throws {
            try self.greengrass.validate(name: "\(name).greengrass")
        }

        private enum CodingKeys: String, CodingKey {
            case greengrass = "greengrass"
        }
    }

    public struct GatewaySummary: AWSDecodableShape {

        /// The date the gateway was created, in Unix epoch time.
        public let creationDate: Date
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use DescribeGatewayCapabilityConfiguration.
        public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        public let gatewayId: String
        /// The name of the asset.
        public let gatewayName: String
        /// The date the gateway was last updated, in Unix epoch time.
        public let lastUpdateDate: Date

        public init(creationDate: Date, gatewayCapabilitySummaries: [GatewayCapabilitySummary]? = nil, gatewayId: String, gatewayName: String, lastUpdateDate: Date) {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.lastUpdateDate = lastUpdateDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case gatewayCapabilitySummaries = "gatewayCapabilitySummaries"
            case gatewayId = "gatewayId"
            case gatewayName = "gatewayName"
            case lastUpdateDate = "lastUpdateDate"
        }
    }

    public struct GetAssetPropertyAggregatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "aggregateTypes", location: .querystring(locationName: "aggregateTypes")), 
            AWSMemberEncoding(label: "assetId", location: .querystring(locationName: "assetId")), 
            AWSMemberEncoding(label: "endDate", location: .querystring(locationName: "endDate")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "propertyAlias", location: .querystring(locationName: "propertyAlias")), 
            AWSMemberEncoding(label: "propertyId", location: .querystring(locationName: "propertyId")), 
            AWSMemberEncoding(label: "qualities", location: .querystring(locationName: "qualities")), 
            AWSMemberEncoding(label: "resolution", location: .querystring(locationName: "resolution")), 
            AWSMemberEncoding(label: "startDate", location: .querystring(locationName: "startDate")), 
            AWSMemberEncoding(label: "timeOrdering", location: .querystring(locationName: "timeOrdering"))
        ]

        /// The data aggregating function.
        public let aggregateTypes: [AggregateType]
        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date
        /// The maximum number of results to be returned per paginated request. Default: 100
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The property alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the AWS IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The time interval over which to aggregate data.
        public let resolution: String
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date
        /// The chronological sorting order of the requested information. Default: ASCENDING 
        public let timeOrdering: TimeOrdering?

        public init(aggregateTypes: [AggregateType], assetId: String? = nil, endDate: Date, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, resolution: String, startDate: Date, timeOrdering: TimeOrdering? = nil) {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregateTypes, name: "aggregateTypes", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
            try self.validate(self.resolution, name: "resolution", parent: name, max: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, min: 2)
            try self.validate(self.resolution, name: "resolution", parent: name, pattern: "1m|1h|1d")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyAggregatesResponse: AWSDecodableShape {

        /// The requested aggregated values.
        public let aggregatedValues: [AggregatedValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(aggregatedValues: [AggregatedValue], nextToken: String? = nil) {
            self.aggregatedValues = aggregatedValues
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case aggregatedValues = "aggregatedValues"
            case nextToken = "nextToken"
        }
    }

    public struct GetAssetPropertyValueHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring(locationName: "assetId")), 
            AWSMemberEncoding(label: "endDate", location: .querystring(locationName: "endDate")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "propertyAlias", location: .querystring(locationName: "propertyAlias")), 
            AWSMemberEncoding(label: "propertyId", location: .querystring(locationName: "propertyId")), 
            AWSMemberEncoding(label: "qualities", location: .querystring(locationName: "qualities")), 
            AWSMemberEncoding(label: "startDate", location: .querystring(locationName: "startDate")), 
            AWSMemberEncoding(label: "timeOrdering", location: .querystring(locationName: "timeOrdering"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let endDate: Date?
        /// The maximum number of results to be returned per paginated request. Default: 100
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The property alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the AWS IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?
        /// The quality by which to filter asset data.
        public let qualities: [Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public let startDate: Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING 
        public let timeOrdering: TimeOrdering?

        public init(assetId: String? = nil, endDate: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil, qualities: [Quality]? = nil, startDate: Date? = nil, timeOrdering: TimeOrdering? = nil) {
            self.assetId = assetId
            self.endDate = endDate
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.qualities, name: "qualities", parent: name, max: 1)
            try self.validate(self.qualities, name: "qualities", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueHistoryResponse: AWSDecodableShape {

        /// The asset property's value history.
        public let assetPropertyValueHistory: [AssetPropertyValue]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetPropertyValueHistory: [AssetPropertyValue], nextToken: String? = nil) {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetPropertyValueHistory = "assetPropertyValueHistory"
            case nextToken = "nextToken"
        }
    }

    public struct GetAssetPropertyValueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .querystring(locationName: "assetId")), 
            AWSMemberEncoding(label: "propertyAlias", location: .querystring(locationName: "propertyAlias")), 
            AWSMemberEncoding(label: "propertyId", location: .querystring(locationName: "propertyId"))
        ]

        /// The ID of the asset.
        public let assetId: String?
        /// The property alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the AWS IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property.
        public let propertyId: String?

        public init(assetId: String? = nil, propertyAlias: String? = nil, propertyId: String? = nil) {
            self.assetId = assetId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetPropertyValueResponse: AWSDecodableShape {

        /// The current asset property value.
        public let propertyValue: AssetPropertyValue?

        public init(propertyValue: AssetPropertyValue? = nil) {
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyValue = "propertyValue"
        }
    }

    public struct Greengrass: AWSEncodableShape & AWSDecodableShape {

        /// The ARN of the Greengrass group. For more information about how to find a group's ARN, see ListGroups and GetGroup in the AWS IoT Greengrass API Reference.
        public let groupArn: String

        public init(groupArn: String) {
            self.groupArn = groupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.groupArn, name: "groupArn", parent: name, max: 1600)
            try self.validate(self.groupArn, name: "groupArn", parent: name, min: 1)
            try self.validate(self.groupArn, name: "groupArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case groupArn = "groupArn"
        }
    }

    public struct GroupIdentity: AWSEncodableShape & AWSDecodableShape {

        /// The AWS SSO ID of the group.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct IAMUserIdentity: AWSEncodableShape & AWSDecodableShape {

        /// The ARN of the IAM user. IAM users must have the iotsitewise:CreatePresignedPortalUrl permission to sign in to the portal. For more information, see IAM ARNs in the IAM User Guide.  If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists. 
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1600)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Identity: AWSEncodableShape & AWSDecodableShape {

        /// An AWS SSO group identity.
        public let group: GroupIdentity?
        /// An IAM user identity.
        public let iamUser: IAMUserIdentity?
        /// An AWS SSO user identity.
        public let user: UserIdentity?

        public init(group: GroupIdentity? = nil, iamUser: IAMUserIdentity? = nil, user: UserIdentity? = nil) {
            self.group = group
            self.iamUser = iamUser
            self.user = user
        }

        public func validate(name: String) throws {
            try self.group?.validate(name: "\(name).group")
            try self.iamUser?.validate(name: "\(name).iamUser")
            try self.user?.validate(name: "\(name).user")
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case iamUser = "iamUser"
            case user = "user"
        }
    }

    public struct Image: AWSEncodableShape {

        public let file: ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public let id: String?

        public init(file: ImageFile? = nil, id: String? = nil) {
            self.file = file
            self.id = id
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
            case id = "id"
        }
    }

    public struct ImageFile: AWSEncodableShape {

        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        public let data: Data
        /// The file type of the image.
        public let `type`: ImageFileType

        public init(data: Data, type: ImageFileType) {
            self.data = data
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try self.validate(self.data, name: "data", parent: name, max: 1500000)
            try self.validate(self.data, name: "data", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case `type` = "type"
        }
    }

    public struct ImageLocation: AWSDecodableShape {

        /// The ID of the image.
        public let id: String
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        public let url: String

        public init(id: String, url: String) {
            self.id = id
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case url = "url"
        }
    }

    public struct ListAccessPoliciesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "iamArn", location: .querystring(locationName: "iamArn")), 
            AWSMemberEncoding(label: "identityId", location: .querystring(locationName: "identityId")), 
            AWSMemberEncoding(label: "identityType", location: .querystring(locationName: "identityType")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "resourceId", location: .querystring(locationName: "resourceId")), 
            AWSMemberEncoding(label: "resourceType", location: .querystring(locationName: "resourceType"))
        ]

        /// The ARN of the IAM user. For more information, see IAM ARNs in the IAM User Guide. This parameter is required if you specify IAM for identityType.
        public let iamArn: String?
        /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
        public let identityId: String?
        /// The type of identity (AWS SSO user, AWS SSO group, or IAM user). This parameter is required if you specify identityId.
        public let identityType: IdentityType?
        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the resource. This parameter is required if you specify resourceType.
        public let resourceId: String?
        /// The type of resource (portal or project). This parameter is required if you specify resourceId.
        public let resourceType: ResourceType?

        public init(iamArn: String? = nil, identityId: String? = nil, identityType: IdentityType? = nil, maxResults: Int? = nil, nextToken: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.iamArn = iamArn
            self.identityId = identityId
            self.identityType = identityType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.iamArn, name: "iamArn", parent: name, max: 1600)
            try self.validate(self.iamArn, name: "iamArn", parent: name, min: 1)
            try self.validate(self.iamArn, name: "iamArn", parent: name, pattern: ".*")
            try self.validate(self.identityId, name: "identityId", parent: name, max: 256)
            try self.validate(self.identityId, name: "identityId", parent: name, min: 1)
            try self.validate(self.identityId, name: "identityId", parent: name, pattern: "\\S+")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 36)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPoliciesResponse: AWSDecodableShape {

        /// A list that summarizes each access policy.
        public let accessPolicySummaries: [AccessPolicySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(accessPolicySummaries: [AccessPolicySummary], nextToken: String? = nil) {
            self.accessPolicySummaries = accessPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicySummaries = "accessPolicySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetModelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetModelsResponse: AWSDecodableShape {

        /// A list that summarizes each asset model.
        public let assetModelSummaries: [AssetModelSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetModelSummaries: [AssetModelSummary], nextToken: String? = nil) {
            self.assetModelSummaries = assetModelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelSummaries = "assetModelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .querystring(locationName: "assetModelId")), 
            AWSMemberEncoding(label: "filter", location: .querystring(locationName: "filter")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter.
        public let assetModelId: String?
        /// The filter for the requested list of assets. Choose one of the following options:    ALL – The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.    TOP_LEVEL – The list includes only top-level assets in the asset hierarchy tree.   Default: ALL 
        public let filter: ListAssetsFilter?
        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(assetModelId: String? = nil, filter: ListAssetsFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.assetModelId = assetModelId
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsResponse: AWSDecodableShape {

        /// A list that summarizes each asset.
        public let assetSummaries: [AssetSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssetSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries = "assetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssociatedAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")), 
            AWSMemberEncoding(label: "hierarchyId", location: .querystring(locationName: "hierarchyId")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "traversalDirection", location: .querystring(locationName: "traversalDirection"))
        ]

        /// The ID of the asset to query.
        public let assetId: String
        /// The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the DescribeAsset or DescribeAssetModel operations. This parameter is required if you choose CHILD for traversalDirection. For more information, see Asset hierarchies in the AWS IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The direction to list associated assets. Choose one of the following options:    CHILD – The list includes all child assets associated to the asset. The hierarchyId parameter is required if you choose CHILD.    PARENT – The list includes the asset's parent asset.   Default: CHILD 
        public let traversalDirection: TraversalDirection?

        public init(assetId: String, hierarchyId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, traversalDirection: TraversalDirection? = nil) {
            self.assetId = assetId
            self.hierarchyId = hierarchyId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.traversalDirection = traversalDirection
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 36)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedAssetsResponse: AWSDecodableShape {

        /// A list that summarizes the associated assets.
        public let assetSummaries: [AssociatedAssetsSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetSummaries: [AssociatedAssetsSummary], nextToken: String? = nil) {
            self.assetSummaries = assetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetSummaries = "assetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDashboardsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "projectId", location: .querystring(locationName: "projectId"))
        ]

        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDashboardsResponse: AWSDecodableShape {

        /// A list that summarizes each dashboard in the project.
        public let dashboardSummaries: [DashboardSummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(dashboardSummaries: [DashboardSummary], nextToken: String? = nil) {
            self.dashboardSummaries = dashboardSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dashboardSummaries = "dashboardSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewaysResponse: AWSDecodableShape {

        /// A list that summarizes each gateway.
        public let gatewaySummaries: [GatewaySummary]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(gatewaySummaries: [GatewaySummary], nextToken: String? = nil) {
            self.gatewaySummaries = gatewaySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewaySummaries = "gatewaySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPortalsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPortalsResponse: AWSDecodableShape {

        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each portal.
        public let portalSummaries: [PortalSummary]?

        public init(nextToken: String? = nil, portalSummaries: [PortalSummary]? = nil) {
            self.nextToken = nextToken
            self.portalSummaries = portalSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case portalSummaries = "portalSummaries"
        }
    }

    public struct ListProjectAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the project.
        public let projectId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectId = projectId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectAssetsResponse: AWSDecodableShape {

        /// A list that contains the IDs of each asset associated with the project.
        public let assetIds: [String]
        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?

        public init(assetIds: [String], nextToken: String? = nil) {
            self.assetIds = assetIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetIds = "assetIds"
            case nextToken = "nextToken"
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "portalId", location: .querystring(locationName: "portalId"))
        ]

        /// The maximum number of results to be returned per paginated request. Default: 50
        public let maxResults: Int?
        /// The token to be used for the next set of paginated results.
        public let nextToken: String?
        /// The ID of the portal.
        public let portalId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, portalId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.portalId = portalId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 250)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "[A-Za-z0-9+/=]+")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {

        /// The token for the next set of results, or null if there are no additional results.
        public let nextToken: String?
        /// A list that summarizes each project in the portal.
        public let projectSummaries: [ProjectSummary]

        public init(nextToken: String? = nil, projectSummaries: [ProjectSummary]) {
            self.nextToken = nextToken
            self.projectSummaries = projectSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case projectSummaries = "projectSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        /// The list of key-value pairs that contain metadata for the resource. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LoggingOptions: AWSEncodableShape & AWSDecodableShape {

        /// The AWS IoT SiteWise logging verbosity level.
        public let level: LoggingLevel

        public init(level: LoggingLevel) {
            self.level = level
        }

        private enum CodingKeys: String, CodingKey {
            case level = "level"
        }
    }

    public struct Measurement: AWSEncodableShape & AWSDecodableShape {


        public init() {
        }

    }

    public struct Metric: AWSEncodableShape & AWSDecodableShape {

        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the AWS IoT SiteWise User Guide.
        public let expression: String
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]
        /// The window (time interval) over which AWS IoT SiteWise computes the metric's aggregation expression. AWS IoT SiteWise computes one data point per window.
        public let window: MetricWindow

        public init(expression: String, variables: [ExpressionVariable], window: MetricWindow) {
            self.expression = expression
            self.variables = variables
            self.window = window
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[a-z0-9._+\\-*%/^, ()]+$")
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
            try self.window.validate(name: "\(name).window")
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case variables = "variables"
            case window = "window"
        }
    }

    public struct MetricWindow: AWSEncodableShape & AWSDecodableShape {

        /// The tumbling time interval window.
        public let tumbling: TumblingWindow?

        public init(tumbling: TumblingWindow? = nil) {
            self.tumbling = tumbling
        }

        public func validate(name: String) throws {
            try self.tumbling?.validate(name: "\(name).tumbling")
        }

        private enum CodingKeys: String, CodingKey {
            case tumbling = "tumbling"
        }
    }

    public struct MonitorErrorDetails: AWSDecodableShape {

        /// The error code.
        public let code: MonitorErrorCode?
        /// The error message.
        public let message: String?

        public init(code: MonitorErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct PortalResource: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the portal.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct PortalStatus: AWSDecodableShape {

        /// Contains associated error information, if any.
        public let error: MonitorErrorDetails?
        /// The current state of the portal.
        public let state: PortalState

        public init(error: MonitorErrorDetails? = nil, state: PortalState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct PortalSummary: AWSDecodableShape {

        /// The date the portal was created, in Unix epoch time.
        public let creationDate: Date?
        /// The portal's description.
        public let description: String?
        /// The ID of the portal.
        public let id: String
        /// The date the portal was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the portal.
        public let name: String
        /// The ARN of the service role that allows the portal's users to access your AWS IoT SiteWise resources on your behalf. For more information, see Using service roles for AWS IoT SiteWise Monitor in the AWS IoT SiteWise User Guide.
        public let roleArn: String?
        /// The URL for the AWS IoT SiteWise Monitor portal. You can use this URL to access portals that use AWS SSO for authentication. For portals that use IAM for authentication, you must use the CreatePresignedPortalUrl operation to create a URL that you can use to access the portal.
        public let startUrl: String
        public let status: PortalStatus

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String, roleArn: String? = nil, startUrl: String, status: PortalStatus) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
            case roleArn = "roleArn"
            case startUrl = "startUrl"
            case status = "status"
        }
    }

    public struct ProjectResource: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the project.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct ProjectSummary: AWSDecodableShape {

        /// The date the project was created, in Unix epoch time.
        public let creationDate: Date?
        /// The project's description.
        public let description: String?
        /// The ID of the project.
        public let id: String
        /// The date the project was last updated, in Unix epoch time.
        public let lastUpdateDate: Date?
        /// The name of the project.
        public let name: String

        public init(creationDate: Date? = nil, description: String? = nil, id: String, lastUpdateDate: Date? = nil, name: String) {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case description = "description"
            case id = "id"
            case lastUpdateDate = "lastUpdateDate"
            case name = "name"
        }
    }

    public struct Property: AWSDecodableShape {

        /// The property alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the AWS IoT SiteWise User Guide.
        public let alias: String?
        /// The property data type.
        public let dataType: PropertyDataType
        /// The ID of the asset property.
        public let id: String
        /// The name of the property.
        public let name: String
        /// The asset property's notification topic and state. For more information, see UpdateAssetProperty.
        public let notification: PropertyNotification?
        /// The property type (see PropertyType). A property contains one type.
        public let `type`: PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public let unit: String?

        public init(alias: String? = nil, dataType: PropertyDataType, id: String, name: String, notification: PropertyNotification? = nil, type: PropertyType? = nil, unit: String? = nil) {
            self.alias = alias
            self.dataType = dataType
            self.id = id
            self.name = name
            self.notification = notification
            self.`type` = `type`
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case dataType = "dataType"
            case id = "id"
            case name = "name"
            case notification = "notification"
            case `type` = "type"
            case unit = "unit"
        }
    }

    public struct PropertyNotification: AWSDecodableShape {

        /// The current notification state.
        public let state: PropertyNotificationState
        /// The MQTT topic to which AWS IoT SiteWise publishes property value update notifications.
        public let topic: String

        public init(state: PropertyNotificationState, topic: String) {
            self.state = state
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case topic = "topic"
        }
    }

    public struct PropertyType: AWSEncodableShape & AWSDecodableShape {

        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an IIoT wind turbine.
        public let attribute: Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public let measurement: Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public let metric: Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public let transform: Transform?

        public init(attribute: Attribute? = nil, measurement: Measurement? = nil, metric: Metric? = nil, transform: Transform? = nil) {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }

        public func validate(name: String) throws {
            try self.attribute?.validate(name: "\(name).attribute")
            try self.metric?.validate(name: "\(name).metric")
            try self.transform?.validate(name: "\(name).transform")
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case measurement = "measurement"
            case metric = "metric"
            case transform = "transform"
        }
    }

    public struct PutAssetPropertyValueEntry: AWSEncodableShape {

        /// The ID of the asset to update.
        public let assetId: String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        public let entryId: String
        /// The property alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the AWS IoT SiteWise User Guide.
        public let propertyAlias: String?
        /// The ID of the asset property for this entry.
        public let propertyId: String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements. 
        public let propertyValues: [AssetPropertyValue]

        public init(assetId: String? = nil, entryId: String, propertyAlias: String? = nil, propertyId: String? = nil, propertyValues: [AssetPropertyValue]) {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.entryId, name: "entryId", parent: name, max: 64)
            try self.validate(self.entryId, name: "entryId", parent: name, min: 1)
            try self.validate(self.entryId, name: "entryId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, max: 2048)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.propertyValues.forEach {
                try $0.validate(name: "\(name).propertyValues[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case entryId = "entryId"
            case propertyAlias = "propertyAlias"
            case propertyId = "propertyId"
            case propertyValues = "propertyValues"
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {

        /// The logging options to set.
        public let loggingOptions: LoggingOptions

        public init(loggingOptions: LoggingOptions) {
            self.loggingOptions = loggingOptions
        }

        private enum CodingKeys: String, CodingKey {
            case loggingOptions = "loggingOptions"
        }
    }

    public struct PutLoggingOptionsResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {

        /// A portal resource.
        public let portal: PortalResource?
        /// A project resource.
        public let project: ProjectResource?

        public init(portal: PortalResource? = nil, project: ProjectResource? = nil) {
            self.portal = portal
            self.project = project
        }

        public func validate(name: String) throws {
            try self.portal?.validate(name: "\(name).portal")
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case portal = "portal"
            case project = "project"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The ARN of the resource to tag.
        public let resourceArn: String
        /// A list of key-value pairs that contain metadata for the resource. For more information, see Tagging your AWS IoT SiteWise resources in the AWS IoT SiteWise User Guide.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct TimeInNanos: AWSEncodableShape & AWSDecodableShape {

        /// The nanosecond offset from timeInSeconds.
        public let offsetInNanos: Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        public let timeInSeconds: Int64

        public init(offsetInNanos: Int? = nil, timeInSeconds: Int64) {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, max: 999999999)
            try self.validate(self.offsetInNanos, name: "offsetInNanos", parent: name, min: 0)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, max: 31556889864403199)
            try self.validate(self.timeInSeconds, name: "timeInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case offsetInNanos = "offsetInNanos"
            case timeInSeconds = "timeInSeconds"
        }
    }

    public struct Transform: AWSEncodableShape & AWSDecodableShape {

        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression.  For more information, see Quotas in the AWS IoT SiteWise User Guide.
        public let expression: String
        /// The list of variables used in the expression.
        public let variables: [ExpressionVariable]

        public init(expression: String, variables: [ExpressionVariable]) {
            self.expression = expression
            self.variables = variables
        }

        public func validate(name: String) throws {
            try self.validate(self.expression, name: "expression", parent: name, max: 1024)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, pattern: "^[a-z0-9._+\\-*%/^, ()]+$")
            try self.variables.forEach {
                try $0.validate(name: "\(name).variables[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case variables = "variables"
        }
    }

    public struct TumblingWindow: AWSEncodableShape & AWSDecodableShape {

        /// The time interval for the tumbling window. Note that w represents weeks, d represents days, h represents hours, and m represents minutes. AWS IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on.  When AWS IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. AWS IoT SiteWise places the computed data point at the end of the interval.
        public let interval: String

        public init(interval: String) {
            self.interval = interval
        }

        public func validate(name: String) throws {
            try self.validate(self.interval, name: "interval", parent: name, max: 3)
            try self.validate(self.interval, name: "interval", parent: name, min: 2)
            try self.validate(self.interval, name: "interval", parent: name, pattern: "1w|1d|1h|15m|5m|1m")
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "interval"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The ARN of the resource to untag.
        public let resourceArn: String
        /// A list of keys for tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateAccessPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accessPolicyId", location: .uri(locationName: "accessPolicyId"))
        ]

        /// The ID of the access policy.
        public let accessPolicyId: String
        /// The identity for this access policy. Choose an AWS SSO user, an AWS SSO group, or an IAM user.
        public let accessPolicyIdentity: Identity
        /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        public let accessPolicyPermission: Permission
        /// The AWS IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
        public let accessPolicyResource: Resource
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(accessPolicyId: String, accessPolicyIdentity: Identity, accessPolicyPermission: Permission, accessPolicyResource: Resource, clientToken: String? = UpdateAccessPolicyRequest.idempotencyToken()) {
            self.accessPolicyId = accessPolicyId
            self.accessPolicyIdentity = accessPolicyIdentity
            self.accessPolicyPermission = accessPolicyPermission
            self.accessPolicyResource = accessPolicyResource
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, max: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, min: 36)
            try self.validate(self.accessPolicyId, name: "accessPolicyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.accessPolicyIdentity.validate(name: "\(name).accessPolicyIdentity")
            try self.accessPolicyResource.validate(name: "\(name).accessPolicyResource")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyIdentity = "accessPolicyIdentity"
            case accessPolicyPermission = "accessPolicyPermission"
            case accessPolicyResource = "accessPolicyResource"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAccessPolicyResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateAssetModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetModelId", location: .uri(locationName: "assetModelId"))
        ]

        /// A description for the asset model.
        public let assetModelDescription: String?
        /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see Asset hierarchies in the AWS IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see Quotas in the AWS IoT SiteWise User Guide.
        public let assetModelHierarchies: [AssetModelHierarchy]?
        /// The ID of the asset model to update.
        public let assetModelId: String
        /// A unique, friendly name for the asset model.
        public let assetModelName: String
        /// The updated property definitions of the asset model. For more information, see Asset properties in the AWS IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see Quotas in the AWS IoT SiteWise User Guide.
        public let assetModelProperties: [AssetModelProperty]?
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetModelDescription: String? = nil, assetModelHierarchies: [AssetModelHierarchy]? = nil, assetModelId: String, assetModelName: String, assetModelProperties: [AssetModelProperty]? = nil, clientToken: String? = UpdateAssetModelRequest.idempotencyToken()) {
            self.assetModelDescription = assetModelDescription
            self.assetModelHierarchies = assetModelHierarchies
            self.assetModelId = assetModelId
            self.assetModelName = assetModelName
            self.assetModelProperties = assetModelProperties
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, max: 2048)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, min: 1)
            try self.validate(self.assetModelDescription, name: "assetModelDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelHierarchies?.forEach {
                try $0.validate(name: "\(name).assetModelHierarchies[]")
            }
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, max: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, min: 36)
            try self.validate(self.assetModelId, name: "assetModelId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, max: 256)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, min: 1)
            try self.validate(self.assetModelName, name: "assetModelName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.assetModelProperties?.forEach {
                try $0.validate(name: "\(name).assetModelProperties[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelDescription = "assetModelDescription"
            case assetModelHierarchies = "assetModelHierarchies"
            case assetModelName = "assetModelName"
            case assetModelProperties = "assetModelProperties"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetModelResponse: AWSDecodableShape {

        /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetModelStatus: AssetModelStatus

        public init(assetModelStatus: AssetModelStatus) {
            self.assetModelStatus = assetModelStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetModelStatus = "assetModelStatus"
        }
    }

    public struct UpdateAssetPropertyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId")), 
            AWSMemberEncoding(label: "propertyId", location: .uri(locationName: "propertyId"))
        ]

        /// The ID of the asset to be updated.
        public let assetId: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The property alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see Mapping industrial data streams to asset properties in the AWS IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
        public let propertyAlias: String?
        /// The ID of the asset property to be updated.
        public let propertyId: String
        /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, AWS IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see Interacting with other services in the AWS IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
        public let propertyNotificationState: PropertyNotificationState?

        public init(assetId: String, clientToken: String? = UpdateAssetPropertyRequest.idempotencyToken(), propertyAlias: String? = nil, propertyId: String, propertyNotificationState: PropertyNotificationState? = nil) {
            self.assetId = assetId
            self.clientToken = clientToken
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyNotificationState = propertyNotificationState
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, min: 1)
            try self.validate(self.propertyAlias, name: "propertyAlias", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 36)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case propertyAlias = "propertyAlias"
            case propertyNotificationState = "propertyNotificationState"
        }
    }

    public struct UpdateAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "assetId", location: .uri(locationName: "assetId"))
        ]

        /// The ID of the asset to update.
        public let assetId: String
        /// A unique, friendly name for the asset.
        public let assetName: String
        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?

        public init(assetId: String, assetName: String, clientToken: String? = UpdateAssetRequest.idempotencyToken()) {
            self.assetId = assetId
            self.assetName = assetName
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 36)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.assetName, name: "assetName", parent: name, max: 256)
            try self.validate(self.assetName, name: "assetName", parent: name, min: 1)
            try self.validate(self.assetName, name: "assetName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
        }

        private enum CodingKeys: String, CodingKey {
            case assetName = "assetName"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateAssetResponse: AWSDecodableShape {

        /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let assetStatus: AssetStatus

        public init(assetStatus: AssetStatus) {
            self.assetStatus = assetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case assetStatus = "assetStatus"
        }
    }

    public struct UpdateDashboardRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dashboardId", location: .uri(locationName: "dashboardId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The new dashboard definition, as specified in a JSON literal. For detailed information, see Creating dashboards (CLI) in the AWS IoT SiteWise User Guide.
        public let dashboardDefinition: String
        /// A new description for the dashboard.
        public let dashboardDescription: String?
        /// The ID of the dashboard to update.
        public let dashboardId: String
        /// A new friendly name for the dashboard.
        public let dashboardName: String

        public init(clientToken: String? = UpdateDashboardRequest.idempotencyToken(), dashboardDefinition: String, dashboardDescription: String? = nil, dashboardId: String, dashboardName: String) {
            self.clientToken = clientToken
            self.dashboardDefinition = dashboardDefinition
            self.dashboardDescription = dashboardDescription
            self.dashboardId = dashboardId
            self.dashboardName = dashboardName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, max: 204800)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, min: 0)
            try self.validate(self.dashboardDefinition, name: "dashboardDefinition", parent: name, pattern: ".+")
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, max: 2048)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, min: 1)
            try self.validate(self.dashboardDescription, name: "dashboardDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, max: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, min: 36)
            try self.validate(self.dashboardId, name: "dashboardId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, max: 256)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, min: 1)
            try self.validate(self.dashboardName, name: "dashboardName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case dashboardDefinition = "dashboardDefinition"
            case dashboardDescription = "dashboardDescription"
            case dashboardName = "dashboardName"
        }
    }

    public struct UpdateDashboardResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateGatewayCapabilityConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The JSON document that defines the configuration for the gateway capability. For more information, see Configuring data sources (CLI) in the AWS IoT SiteWise User Guide.
        public let capabilityConfiguration: String
        /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the AWS IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        public let capabilityNamespace: String
        /// The ID of the gateway to be updated.
        public let gatewayId: String

        public init(capabilityConfiguration: String, capabilityNamespace: String, gatewayId: String) {
            self.capabilityConfiguration = capabilityConfiguration
            self.capabilityNamespace = capabilityNamespace
            self.gatewayId = gatewayId
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, max: 204800)
            try self.validate(self.capabilityConfiguration, name: "capabilityConfiguration", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, max: 512)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, min: 1)
            try self.validate(self.capabilityNamespace, name: "capabilityNamespace", parent: name, pattern: "^[a-zA-Z]+:[a-zA-Z]+:[0-9]+$")
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityConfiguration = "capabilityConfiguration"
            case capabilityNamespace = "capabilityNamespace"
        }
    }

    public struct UpdateGatewayCapabilityConfigurationResponse: AWSDecodableShape {

        /// The namespace of the gateway capability.
        public let capabilityNamespace: String
        /// The synchronization status of the capability configuration. The sync status can be one of the following:    IN_SYNC – The gateway is running the capability configuration.    OUT_OF_SYNC – The gateway hasn't received the capability configuration.    SYNC_FAILED – The gateway rejected the capability configuration.   After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
        public let capabilitySyncStatus: CapabilitySyncStatus

        public init(capabilityNamespace: String, capabilitySyncStatus: CapabilitySyncStatus) {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityNamespace = "capabilityNamespace"
            case capabilitySyncStatus = "capabilitySyncStatus"
        }
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayId", location: .uri(locationName: "gatewayId"))
        ]

        /// The ID of the gateway to update.
        public let gatewayId: String
        /// A unique, friendly name for the gateway.
        public let gatewayName: String

        public init(gatewayId: String, gatewayName: String) {
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, max: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, min: 36)
            try self.validate(self.gatewayId, name: "gatewayId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, max: 256)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, min: 1)
            try self.validate(self.gatewayName, name: "gatewayName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayName = "gatewayName"
        }
    }

    public struct UpdatePortalRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "portalId", location: .uri(locationName: "portalId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// The AWS administrator's contact email address.
        public let portalContactEmail: String
        /// A new description for the portal.
        public let portalDescription: String?
        /// The ID of the portal to update.
        public let portalId: String
        public let portalLogoImage: Image?
        /// A new friendly name for the portal.
        public let portalName: String
        /// The ARN of a service role that allows the portal's users to access your AWS IoT SiteWise resources on your behalf. For more information, see Using service roles for AWS IoT SiteWise Monitor in the AWS IoT SiteWise User Guide.
        public let roleArn: String

        public init(clientToken: String? = UpdatePortalRequest.idempotencyToken(), portalContactEmail: String, portalDescription: String? = nil, portalId: String, portalLogoImage: Image? = nil, portalName: String, roleArn: String) {
            self.clientToken = clientToken
            self.portalContactEmail = portalContactEmail
            self.portalDescription = portalDescription
            self.portalId = portalId
            self.portalLogoImage = portalLogoImage
            self.portalName = portalName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, max: 255)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, min: 1)
            try self.validate(self.portalContactEmail, name: "portalContactEmail", parent: name, pattern: "[^@]+@[^@]+")
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, max: 2048)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, min: 1)
            try self.validate(self.portalDescription, name: "portalDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.portalId, name: "portalId", parent: name, max: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, min: 36)
            try self.validate(self.portalId, name: "portalId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.portalLogoImage?.validate(name: "\(name).portalLogoImage")
            try self.validate(self.portalName, name: "portalName", parent: name, max: 256)
            try self.validate(self.portalName, name: "portalName", parent: name, min: 1)
            try self.validate(self.portalName, name: "portalName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1600)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case portalContactEmail = "portalContactEmail"
            case portalDescription = "portalDescription"
            case portalLogoImage = "portalLogoImage"
            case portalName = "portalName"
            case roleArn = "roleArn"
        }
    }

    public struct UpdatePortalResponse: AWSDecodableShape {

        /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
        public let portalStatus: PortalStatus

        public init(portalStatus: PortalStatus) {
            self.portalStatus = portalStatus
        }

        private enum CodingKeys: String, CodingKey {
            case portalStatus = "portalStatus"
        }
    }

    public struct UpdateProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectId", location: .uri(locationName: "projectId"))
        ]

        /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
        public let clientToken: String?
        /// A new description for the project.
        public let projectDescription: String?
        /// The ID of the project to update.
        public let projectId: String
        /// A new friendly name for the project.
        public let projectName: String

        public init(clientToken: String? = UpdateProjectRequest.idempotencyToken(), projectDescription: String? = nil, projectId: String, projectName: String) {
            self.clientToken = clientToken
            self.projectDescription = projectDescription
            self.projectId = projectId
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 36)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S{36,64}")
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, max: 2048)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, min: 1)
            try self.validate(self.projectDescription, name: "projectDescription", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.projectId, name: "projectId", parent: name, max: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, min: 36)
            try self.validate(self.projectId, name: "projectId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 256)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case projectDescription = "projectDescription"
            case projectName = "projectName"
        }
    }

    public struct UpdateProjectResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UserIdentity: AWSEncodableShape & AWSDecodableShape {

        /// The AWS SSO ID of the user.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct VariableValue: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see Asset hierarchies in the AWS IoT SiteWise User Guide.
        public let hierarchyId: String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model.
        public let propertyId: String

        public init(hierarchyId: String? = nil, propertyId: String) {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
        }

        public func validate(name: String) throws {
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, max: 256)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, min: 1)
            try self.validate(self.hierarchyId, name: "hierarchyId", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
            try self.validate(self.propertyId, name: "propertyId", parent: name, max: 256)
            try self.validate(self.propertyId, name: "propertyId", parent: name, min: 1)
            try self.validate(self.propertyId, name: "propertyId", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyId = "hierarchyId"
            case propertyId = "propertyId"
        }
    }

    public struct Variant: AWSEncodableShape & AWSDecodableShape {

        /// Asset property data of type Boolean (true or false).
        public let booleanValue: Bool?
        /// Asset property data of type double (floating point number).
        public let doubleValue: Double?
        /// Asset property data of type integer (whole number).
        public let integerValue: Int?
        /// Asset property data of type string (sequence of characters).
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, integerValue: Int? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 1024)
            try self.validate(self.stringValue, name: "stringValue", parent: name, min: 1)
            try self.validate(self.stringValue, name: "stringValue", parent: name, pattern: "[^\\u0000-\\u001F\\u007F]+")
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "booleanValue"
            case doubleValue = "doubleValue"
            case integerValue = "integerValue"
            case stringValue = "stringValue"
        }
    }
}

//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import AWSSDKSwiftCore
import Foundation

extension AppSync {
    //MARK: Enums

    public enum ApiCacheStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case modifying = "MODIFYING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ApiCacheType: String, CustomStringConvertible, Codable {
        case t2Small = "T2_SMALL"
        case t2Medium = "T2_MEDIUM"
        case r4Large = "R4_LARGE"
        case r4Xlarge = "R4_XLARGE"
        case r42Xlarge = "R4_2XLARGE"
        case r44Xlarge = "R4_4XLARGE"
        case r48Xlarge = "R4_8XLARGE"
        public var description: String { return self.rawValue }
    }

    public enum ApiCachingBehavior: String, CustomStringConvertible, Codable {
        case fullRequestCaching = "FULL_REQUEST_CACHING"
        case perResolverCaching = "PER_RESOLVER_CACHING"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable {
        case apiKey = "API_KEY"
        case awsIam = "AWS_IAM"
        case amazonCognitoUserPools = "AMAZON_COGNITO_USER_POOLS"
        case openidConnect = "OPENID_CONNECT"
        public var description: String { return self.rawValue }
    }

    public enum AuthorizationType: String, CustomStringConvertible, Codable {
        case awsIam = "AWS_IAM"
        public var description: String { return self.rawValue }
    }

    public enum ConflictDetectionType: String, CustomStringConvertible, Codable {
        case version = "VERSION"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ConflictHandlerType: String, CustomStringConvertible, Codable {
        case optimisticConcurrency = "OPTIMISTIC_CONCURRENCY"
        case lambda = "LAMBDA"
        case automerge = "AUTOMERGE"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceType: String, CustomStringConvertible, Codable {
        case awsLambda = "AWS_LAMBDA"
        case amazonDynamodb = "AMAZON_DYNAMODB"
        case amazonElasticsearch = "AMAZON_ELASTICSEARCH"
        case none = "NONE"
        case http = "HTTP"
        case relationalDatabase = "RELATIONAL_DATABASE"
        public var description: String { return self.rawValue }
    }

    public enum DefaultAction: String, CustomStringConvertible, Codable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum FieldLogLevel: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case error = "ERROR"
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum OutputType: String, CustomStringConvertible, Codable {
        case sdl = "SDL"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    public enum RelationalDatabaseSourceType: String, CustomStringConvertible, Codable {
        case rdsHttpEndpoint = "RDS_HTTP_ENDPOINT"
        public var description: String { return self.rawValue }
    }

    public enum ResolverKind: String, CustomStringConvertible, Codable {
        case unit = "UNIT"
        case pipeline = "PIPELINE"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatus: String, CustomStringConvertible, Codable {
        case processing = "PROCESSING"
        case active = "ACTIVE"
        case deleting = "DELETING"
        case failed = "FAILED"
        case success = "SUCCESS"
        case notApplicable = "NOT_APPLICABLE"
        public var description: String { return self.rawValue }
    }

    public enum TypeDefinitionFormat: String, CustomStringConvertible, Codable {
        case sdl = "SDL"
        case json = "JSON"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AdditionalAuthenticationProvider: AWSEncodableShape & AWSDecodableShape {

        /// The authentication type: API key, AWS IAM, OIDC, or Amazon Cognito user pools.
        public let authenticationType: AuthenticationType?
        /// The OpenID Connect configuration.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// The Amazon Cognito user pool configuration.
        public let userPoolConfig: CognitoUserPoolConfig?

        public init(authenticationType: AuthenticationType? = nil, openIDConnectConfig: OpenIDConnectConfig? = nil, userPoolConfig: CognitoUserPoolConfig? = nil) {
            self.authenticationType = authenticationType
            self.openIDConnectConfig = openIDConnectConfig
            self.userPoolConfig = userPoolConfig
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case openIDConnectConfig = "openIDConnectConfig"
            case userPoolConfig = "userPoolConfig"
        }
    }

    public struct ApiCache: AWSDecodableShape {

        /// Caching behavior.    FULL_REQUEST_CACHING: All requests are fully cached.    PER_RESOLVER_CACHING: Individual resovlers that you specify are cached.  
        public let apiCachingBehavior: ApiCachingBehavior?
        /// At rest encryption flag for cache. This setting cannot be updated after creation.
        public let atRestEncryptionEnabled: Bool?
        /// The cache instance status.    AVAILABLE: The instance is available for use.    CREATING: The instance is currently creating.    DELETING: The instance is currently deleting.    MODIFYING: The instance is currently modifying.    FAILED: The instance has failed creation.  
        public let status: ApiCacheStatus?
        /// Transit encryption flag when connecting to cache. This setting cannot be updated after creation.
        public let transitEncryptionEnabled: Bool?
        /// TTL in seconds for cache entries. Valid values are between 1 and 3600 seconds.
        public let ttl: Int64?
        /// The cache instance type.    T2_SMALL: A t2.small instance type.    T2_MEDIUM: A t2.medium instance type.    R4_LARGE: A r4.large instance type.    R4_XLARGE: A r4.xlarge instance type.    R4_2XLARGE: A r4.2xlarge instance type.    R4_4XLARGE: A r4.4xlarge instance type.    R4_8XLARGE: A r4.8xlarge instance type.  
        public let `type`: ApiCacheType?

        public init(apiCachingBehavior: ApiCachingBehavior? = nil, atRestEncryptionEnabled: Bool? = nil, status: ApiCacheStatus? = nil, transitEncryptionEnabled: Bool? = nil, ttl: Int64? = nil, type: ApiCacheType? = nil) {
            self.apiCachingBehavior = apiCachingBehavior
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.status = status
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case apiCachingBehavior = "apiCachingBehavior"
            case atRestEncryptionEnabled = "atRestEncryptionEnabled"
            case status = "status"
            case transitEncryptionEnabled = "transitEncryptionEnabled"
            case ttl = "ttl"
            case `type` = "type"
        }
    }

    public struct ApiKey: AWSDecodableShape {

        /// A description of the purpose of the API key.
        public let description: String?
        /// The time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour.
        public let expires: Int64?
        /// The API key ID.
        public let id: String?

        public init(description: String? = nil, expires: Int64? = nil, id: String? = nil) {
            self.description = description
            self.expires = expires
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case expires = "expires"
            case id = "id"
        }
    }

    public struct AuthorizationConfig: AWSEncodableShape & AWSDecodableShape {

        /// The authorization type required by the HTTP endpoint.    AWS_IAM: The authorization type is Sigv4.  
        public let authorizationType: AuthorizationType
        /// The AWS IAM settings.
        public let awsIamConfig: AwsIamConfig?

        public init(authorizationType: AuthorizationType, awsIamConfig: AwsIamConfig? = nil) {
            self.authorizationType = authorizationType
            self.awsIamConfig = awsIamConfig
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationType = "authorizationType"
            case awsIamConfig = "awsIamConfig"
        }
    }

    public struct AwsIamConfig: AWSEncodableShape & AWSDecodableShape {

        /// The signing region for AWS IAM authorization.
        public let signingRegion: String?
        /// The signing service name for AWS IAM authorization.
        public let signingServiceName: String?

        public init(signingRegion: String? = nil, signingServiceName: String? = nil) {
            self.signingRegion = signingRegion
            self.signingServiceName = signingServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case signingRegion = "signingRegion"
            case signingServiceName = "signingServiceName"
        }
    }

    public struct CachingConfig: AWSEncodableShape & AWSDecodableShape {

        /// The caching keys for a resolver that has caching enabled. Valid values are entries from the $context.identity and $context.arguments maps.
        public let cachingKeys: [String]?
        /// The TTL in seconds for a resolver that has caching enabled. Valid values are between 1 and 3600 seconds.
        public let ttl: Int64?

        public init(cachingKeys: [String]? = nil, ttl: Int64? = nil) {
            self.cachingKeys = cachingKeys
            self.ttl = ttl
        }

        private enum CodingKeys: String, CodingKey {
            case cachingKeys = "cachingKeys"
            case ttl = "ttl"
        }
    }

    public struct CognitoUserPoolConfig: AWSEncodableShape & AWSDecodableShape {

        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID.
        public let appIdClientRegex: String?
        /// The AWS Region in which the user pool was created.
        public let awsRegion: String
        /// The user pool ID.
        public let userPoolId: String

        public init(appIdClientRegex: String? = nil, awsRegion: String, userPoolId: String) {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.userPoolId = userPoolId
        }

        private enum CodingKeys: String, CodingKey {
            case appIdClientRegex = "appIdClientRegex"
            case awsRegion = "awsRegion"
            case userPoolId = "userPoolId"
        }
    }

    public struct CreateApiCacheRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// Caching behavior.    FULL_REQUEST_CACHING: All requests are fully cached.    PER_RESOLVER_CACHING: Individual resovlers that you specify are cached.  
        public let apiCachingBehavior: ApiCachingBehavior
        /// The GraphQL API Id.
        public let apiId: String
        /// At rest encryption flag for cache. This setting cannot be updated after creation.
        public let atRestEncryptionEnabled: Bool?
        /// Transit encryption flag when connecting to cache. This setting cannot be updated after creation.
        public let transitEncryptionEnabled: Bool?
        /// TTL in seconds for cache entries. Valid values are between 1 and 3600 seconds.
        public let ttl: Int64
        /// The cache instance type.    T2_SMALL: A t2.small instance type.    T2_MEDIUM: A t2.medium instance type.    R4_LARGE: A r4.large instance type.    R4_XLARGE: A r4.xlarge instance type.    R4_2XLARGE: A r4.2xlarge instance type.    R4_4XLARGE: A r4.4xlarge instance type.    R4_8XLARGE: A r4.8xlarge instance type.  
        public let `type`: ApiCacheType

        public init(apiCachingBehavior: ApiCachingBehavior, apiId: String, atRestEncryptionEnabled: Bool? = nil, transitEncryptionEnabled: Bool? = nil, ttl: Int64, type: ApiCacheType) {
            self.apiCachingBehavior = apiCachingBehavior
            self.apiId = apiId
            self.atRestEncryptionEnabled = atRestEncryptionEnabled
            self.transitEncryptionEnabled = transitEncryptionEnabled
            self.ttl = ttl
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case apiCachingBehavior = "apiCachingBehavior"
            case atRestEncryptionEnabled = "atRestEncryptionEnabled"
            case transitEncryptionEnabled = "transitEncryptionEnabled"
            case ttl = "ttl"
            case `type` = "type"
        }
    }

    public struct CreateApiCacheResponse: AWSDecodableShape {

        /// The ApiCache object.
        public let apiCache: ApiCache?

        public init(apiCache: ApiCache? = nil) {
            self.apiCache = apiCache
        }

        private enum CodingKeys: String, CodingKey {
            case apiCache = "apiCache"
        }
    }

    public struct CreateApiKeyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The ID for your GraphQL API.
        public let apiId: String
        /// A description of the purpose of the API key.
        public let description: String?
        /// The time from creation time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .
        public let expires: Int64?

        public init(apiId: String, description: String? = nil, expires: Int64? = nil) {
            self.apiId = apiId
            self.description = description
            self.expires = expires
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case expires = "expires"
        }
    }

    public struct CreateApiKeyResponse: AWSDecodableShape {

        /// The API key.
        public let apiKey: ApiKey?

        public init(apiKey: ApiKey? = nil) {
            self.apiKey = apiKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID for the GraphQL API for the DataSource.
        public let apiId: String
        /// A description of the DataSource.
        public let description: String?
        /// Amazon DynamoDB settings.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// Amazon Elasticsearch Service settings.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// HTTP endpoint settings.
        public let httpConfig: HttpDataSourceConfig?
        /// AWS Lambda settings.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// A user-supplied name for the DataSource.
        public let name: String
        /// Relational database settings.
        public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
        /// The AWS IAM service role ARN for the data source. The system assumes this role when accessing the data source.
        public let serviceRoleArn: String?
        /// The type of the DataSource.
        public let `type`: DataSourceType

        public init(apiId: String, description: String? = nil, dynamodbConfig: DynamodbDataSourceConfig? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, httpConfig: HttpDataSourceConfig? = nil, lambdaConfig: LambdaDataSourceConfig? = nil, name: String, relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil, serviceRoleArn: String? = nil, type: DataSourceType) {
            self.apiId = apiId
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.name = name
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.name, name: "name", parent: name, max: 65536)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dynamodbConfig = "dynamodbConfig"
            case elasticsearchConfig = "elasticsearchConfig"
            case httpConfig = "httpConfig"
            case lambdaConfig = "lambdaConfig"
            case name = "name"
            case relationalDatabaseConfig = "relationalDatabaseConfig"
            case serviceRoleArn = "serviceRoleArn"
            case `type` = "type"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {

        /// The DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct CreateFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The GraphQL API ID.
        public let apiId: String
        /// The Function DataSource name.
        public let dataSourceName: String
        /// The Function description.
        public let description: String?
        /// The version of the request mapping template. Currently the supported value is 2018-05-29. 
        public let functionVersion: String
        /// The Function name. The function name does not have to be unique.
        public let name: String
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public let requestMappingTemplate: String
        /// The Function response mapping template. 
        public let responseMappingTemplate: String?

        public init(apiId: String, dataSourceName: String, description: String? = nil, functionVersion: String, name: String, requestMappingTemplate: String, responseMappingTemplate: String? = nil) {
            self.apiId = apiId
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionVersion = functionVersion
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
        }

        public func validate(name: String) throws {
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.name, name: "name", parent: name, max: 65536)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceName = "dataSourceName"
            case description = "description"
            case functionVersion = "functionVersion"
            case name = "name"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
        }
    }

    public struct CreateFunctionResponse: AWSDecodableShape {

        /// The Function object.
        public let functionConfiguration: FunctionConfiguration?

        public init(functionConfiguration: FunctionConfiguration? = nil) {
            self.functionConfiguration = functionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case functionConfiguration = "functionConfiguration"
        }
    }

    public struct CreateGraphqlApiRequest: AWSEncodableShape {

        /// A list of additional authentication providers for the GraphqlApi API.
        public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
        /// The authentication type: API key, AWS IAM, OIDC, or Amazon Cognito user pools.
        public let authenticationType: AuthenticationType
        /// The Amazon CloudWatch Logs configuration.
        public let logConfig: LogConfig?
        /// A user-supplied name for the GraphqlApi.
        public let name: String
        /// The OpenID Connect configuration.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// A TagMap object.
        public let tags: [String: String]?
        /// The Amazon Cognito user pool configuration.
        public let userPoolConfig: UserPoolConfig?
        /// A flag indicating whether to enable X-Ray tracing for the GraphqlApi.
        public let xrayEnabled: Bool?

        public init(additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil, authenticationType: AuthenticationType, logConfig: LogConfig? = nil, name: String, openIDConnectConfig: OpenIDConnectConfig? = nil, tags: [String: String]? = nil, userPoolConfig: UserPoolConfig? = nil, xrayEnabled: Bool? = nil) {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.authenticationType = authenticationType
            self.logConfig = logConfig
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.tags = tags
            self.userPoolConfig = userPoolConfig
            self.xrayEnabled = xrayEnabled
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthenticationProviders = "additionalAuthenticationProviders"
            case authenticationType = "authenticationType"
            case logConfig = "logConfig"
            case name = "name"
            case openIDConnectConfig = "openIDConnectConfig"
            case tags = "tags"
            case userPoolConfig = "userPoolConfig"
            case xrayEnabled = "xrayEnabled"
        }
    }

    public struct CreateGraphqlApiResponse: AWSDecodableShape {

        /// The GraphqlApi.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct CreateResolverRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The ID for the GraphQL API for which the resolver is being created.
        public let apiId: String
        /// The caching configuration for the resolver.
        public let cachingConfig: CachingConfig?
        /// The name of the data source for which the resolver is being created.
        public let dataSourceName: String?
        /// The name of the field to attach the resolver to.
        public let fieldName: String
        /// The resolver type.    UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. A UNIT resolver enables you to execute a GraphQL query against a single data source.    PIPELINE: A PIPELINE resolver type. A PIPELINE resolver enables you to execute a series of Function in a serial manner. You can use a pipeline resolver to execute a GraphQL query against multiple data sources.  
        public let kind: ResolverKind?
        /// The PipelineConfig.
        public let pipelineConfig: PipelineConfig?
        /// The mapping template to be used for requests. A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).
        public let requestMappingTemplate: String
        /// The mapping template to be used for responses from the data source.
        public let responseMappingTemplate: String?
        /// The SyncConfig for a resolver attached to a versioned datasource.
        public let syncConfig: SyncConfig?
        /// The name of the Type.
        public let typeName: String

        public init(apiId: String, cachingConfig: CachingConfig? = nil, dataSourceName: String? = nil, fieldName: String, kind: ResolverKind? = nil, pipelineConfig: PipelineConfig? = nil, requestMappingTemplate: String, responseMappingTemplate: String? = nil, syncConfig: SyncConfig? = nil, typeName: String) {
            self.apiId = apiId
            self.cachingConfig = cachingConfig
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.syncConfig = syncConfig
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try validate(self.fieldName, name: "fieldName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try validate(self.typeName, name: "typeName", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case cachingConfig = "cachingConfig"
            case dataSourceName = "dataSourceName"
            case fieldName = "fieldName"
            case kind = "kind"
            case pipelineConfig = "pipelineConfig"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
            case syncConfig = "syncConfig"
        }
    }

    public struct CreateResolverResponse: AWSDecodableShape {

        /// The Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct CreateTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID.
        public let apiId: String
        /// The type definition, in GraphQL Schema Definition Language (SDL) format. For more information, see the GraphQL SDL documentation.
        public let definition: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat

        public init(apiId: String, definition: String, format: TypeDefinitionFormat) {
            self.apiId = apiId
            self.definition = definition
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case format = "format"
        }
    }

    public struct CreateTypeResponse: AWSDecodableShape {

        /// The Type object.
        public let `type`: `Type`?

        public init(type: `Type`? = nil) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct DataSource: AWSDecodableShape {

        /// The data source ARN.
        public let dataSourceArn: String?
        /// The description of the data source.
        public let description: String?
        /// Amazon DynamoDB settings.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// Amazon Elasticsearch Service settings.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// HTTP endpoint settings.
        public let httpConfig: HttpDataSourceConfig?
        /// AWS Lambda settings.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// The name of the data source.
        public let name: String?
        /// Relational database settings.
        public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
        /// The AWS IAM service role ARN for the data source. The system assumes this role when accessing the data source.
        public let serviceRoleArn: String?
        /// The type of the data source.    AMAZON_DYNAMODB: The data source is an Amazon DynamoDB table.    AMAZON_ELASTICSEARCH: The data source is an Amazon Elasticsearch Service domain.    AWS_LAMBDA: The data source is an AWS Lambda function.    NONE: There is no data source. This type is used when you wish to invoke a GraphQL operation without connecting to a data source, such as performing data transformation with resolvers or triggering a subscription to be invoked from a mutation.    HTTP: The data source is an HTTP endpoint.    RELATIONAL_DATABASE: The data source is a relational database.  
        public let `type`: DataSourceType?

        public init(dataSourceArn: String? = nil, description: String? = nil, dynamodbConfig: DynamodbDataSourceConfig? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, httpConfig: HttpDataSourceConfig? = nil, lambdaConfig: LambdaDataSourceConfig? = nil, name: String? = nil, relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil, serviceRoleArn: String? = nil, type: DataSourceType? = nil) {
            self.dataSourceArn = dataSourceArn
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.name = name
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "dataSourceArn"
            case description = "description"
            case dynamodbConfig = "dynamodbConfig"
            case elasticsearchConfig = "elasticsearchConfig"
            case httpConfig = "httpConfig"
            case lambdaConfig = "lambdaConfig"
            case name = "name"
            case relationalDatabaseConfig = "relationalDatabaseConfig"
            case serviceRoleArn = "serviceRoleArn"
            case `type` = "type"
        }
    }

    public struct DeleteApiCacheRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApiCacheResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteApiKeyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        /// The API ID.
        public let apiId: String
        /// The ID for the API key.
        public let id: String

        public init(apiId: String, id: String) {
            self.apiId = apiId
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApiKeyResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The API ID.
        public let apiId: String
        /// The name of the data source.
        public let name: String

        public init(apiId: String, name: String) {
            self.apiId = apiId
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.name, name: "name", parent: name, max: 65536)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "functionId", location: .uri(locationName: "functionId"))
        ]

        /// The GraphQL API ID.
        public let apiId: String
        /// The Function ID.
        public let functionId: String

        public init(apiId: String, functionId: String) {
            self.apiId = apiId
            self.functionId = functionId
        }

        public func validate(name: String) throws {
            try validate(self.functionId, name: "functionId", parent: name, max: 65536)
            try validate(self.functionId, name: "functionId", parent: name, min: 1)
            try validate(self.functionId, name: "functionId", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFunctionResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteGraphqlApiRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGraphqlApiResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteResolverRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "fieldName", location: .uri(locationName: "fieldName")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The API ID.
        public let apiId: String
        /// The resolver field name.
        public let fieldName: String
        /// The name of the resolver type.
        public let typeName: String

        public init(apiId: String, fieldName: String, typeName: String) {
            self.apiId = apiId
            self.fieldName = fieldName
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try validate(self.fieldName, name: "fieldName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try validate(self.typeName, name: "typeName", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResolverResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeleteTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The API ID.
        public let apiId: String
        /// The type name.
        public let typeName: String

        public init(apiId: String, typeName: String) {
            self.apiId = apiId
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try validate(self.typeName, name: "typeName", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTypeResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct DeltaSyncConfig: AWSEncodableShape & AWSDecodableShape {

        /// The number of minutes an Item is stored in the datasource.
        public let baseTableTTL: Int64?
        /// The Delta Sync table name.
        public let deltaSyncTableName: String?
        /// The number of minutes a Delta Sync log entry is stored in the Delta Sync table.
        public let deltaSyncTableTTL: Int64?

        public init(baseTableTTL: Int64? = nil, deltaSyncTableName: String? = nil, deltaSyncTableTTL: Int64? = nil) {
            self.baseTableTTL = baseTableTTL
            self.deltaSyncTableName = deltaSyncTableName
            self.deltaSyncTableTTL = deltaSyncTableTTL
        }

        private enum CodingKeys: String, CodingKey {
            case baseTableTTL = "baseTableTTL"
            case deltaSyncTableName = "deltaSyncTableName"
            case deltaSyncTableTTL = "deltaSyncTableTTL"
        }
    }

    public struct DynamodbDataSourceConfig: AWSEncodableShape & AWSDecodableShape {

        /// The AWS Region.
        public let awsRegion: String
        /// The DeltaSyncConfig for a versioned datasource.
        public let deltaSyncConfig: DeltaSyncConfig?
        /// The table name.
        public let tableName: String
        /// Set to TRUE to use Amazon Cognito credentials with this data source.
        public let useCallerCredentials: Bool?
        /// Set to TRUE to use Conflict Detection and Resolution with this data source.
        public let versioned: Bool?

        public init(awsRegion: String, deltaSyncConfig: DeltaSyncConfig? = nil, tableName: String, useCallerCredentials: Bool? = nil, versioned: Bool? = nil) {
            self.awsRegion = awsRegion
            self.deltaSyncConfig = deltaSyncConfig
            self.tableName = tableName
            self.useCallerCredentials = useCallerCredentials
            self.versioned = versioned
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case deltaSyncConfig = "deltaSyncConfig"
            case tableName = "tableName"
            case useCallerCredentials = "useCallerCredentials"
            case versioned = "versioned"
        }
    }

    public struct ElasticsearchDataSourceConfig: AWSEncodableShape & AWSDecodableShape {

        /// The AWS Region.
        public let awsRegion: String
        /// The endpoint.
        public let endpoint: String

        public init(awsRegion: String, endpoint: String) {
            self.awsRegion = awsRegion
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case endpoint = "endpoint"
        }
    }

    public struct FlushApiCacheRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct FlushApiCacheResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct FunctionConfiguration: AWSDecodableShape {

        /// The name of the DataSource.
        public let dataSourceName: String?
        /// The Function description.
        public let description: String?
        /// The ARN of the Function object.
        public let functionArn: String?
        /// A unique ID representing the Function object.
        public let functionId: String?
        /// The version of the request mapping template. Currently only the 2018-05-29 version of the template is supported.
        public let functionVersion: String?
        /// The name of the Function object.
        public let name: String?
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public let requestMappingTemplate: String?
        /// The Function response mapping template.
        public let responseMappingTemplate: String?

        public init(dataSourceName: String? = nil, description: String? = nil, functionArn: String? = nil, functionId: String? = nil, functionVersion: String? = nil, name: String? = nil, requestMappingTemplate: String? = nil, responseMappingTemplate: String? = nil) {
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionArn = functionArn
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceName = "dataSourceName"
            case description = "description"
            case functionArn = "functionArn"
            case functionId = "functionId"
            case functionVersion = "functionVersion"
            case name = "name"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
        }
    }

    public struct GetApiCacheRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApiCacheResponse: AWSDecodableShape {

        /// The ApiCache object.
        public let apiCache: ApiCache?

        public init(apiCache: ApiCache? = nil) {
            self.apiCache = apiCache
        }

        private enum CodingKeys: String, CodingKey {
            case apiCache = "apiCache"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The API ID.
        public let apiId: String
        /// The name of the data source.
        public let name: String

        public init(apiId: String, name: String) {
            self.apiId = apiId
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.name, name: "name", parent: name, max: 65536)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {

        /// The DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct GetFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "functionId", location: .uri(locationName: "functionId"))
        ]

        /// The GraphQL API ID.
        public let apiId: String
        /// The Function ID.
        public let functionId: String

        public init(apiId: String, functionId: String) {
            self.apiId = apiId
            self.functionId = functionId
        }

        public func validate(name: String) throws {
            try validate(self.functionId, name: "functionId", parent: name, max: 65536)
            try validate(self.functionId, name: "functionId", parent: name, min: 1)
            try validate(self.functionId, name: "functionId", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFunctionResponse: AWSDecodableShape {

        /// The Function object.
        public let functionConfiguration: FunctionConfiguration?

        public init(functionConfiguration: FunctionConfiguration? = nil) {
            self.functionConfiguration = functionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case functionConfiguration = "functionConfiguration"
        }
    }

    public struct GetGraphqlApiRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID for the GraphQL API.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGraphqlApiResponse: AWSDecodableShape {

        /// The GraphqlApi object.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct GetIntrospectionSchemaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")), 
            AWSMemberEncoding(label: "includeDirectives", location: .querystring(locationName: "includeDirectives"))
        ]

        /// The API ID.
        public let apiId: String
        /// The schema format: SDL or JSON.
        public let format: OutputType
        /// A flag that specifies whether the schema introspection should contain directives.
        public let includeDirectives: Bool?

        public init(apiId: String, format: OutputType, includeDirectives: Bool? = nil) {
            self.apiId = apiId
            self.format = format
            self.includeDirectives = includeDirectives
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIntrospectionSchemaResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "schema"
        public static let _payloadOptions: PayloadOptions = [.raw]

        /// The schema, in GraphQL Schema Definition Language (SDL) format. For more information, see the GraphQL SDL documentation.
        public let schema: AWSPayload?

        public init(schema: AWSPayload? = nil) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct GetResolverRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "fieldName", location: .uri(locationName: "fieldName")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The API ID.
        public let apiId: String
        /// The resolver field name.
        public let fieldName: String
        /// The resolver type name.
        public let typeName: String

        public init(apiId: String, fieldName: String, typeName: String) {
            self.apiId = apiId
            self.fieldName = fieldName
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try validate(self.fieldName, name: "fieldName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try validate(self.typeName, name: "typeName", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResolverResponse: AWSDecodableShape {

        /// The Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct GetSchemaCreationStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID.
        public let apiId: String

        public init(apiId: String) {
            self.apiId = apiId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaCreationStatusResponse: AWSDecodableShape {

        /// Detailed information about the status of the schema creation operation.
        public let details: String?
        /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
        public let status: SchemaStatus?

        public init(details: String? = nil, status: SchemaStatus? = nil) {
            self.details = details
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case status = "status"
        }
    }

    public struct GetTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The API ID.
        public let apiId: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat
        /// The type name.
        public let typeName: String

        public init(apiId: String, format: TypeDefinitionFormat, typeName: String) {
            self.apiId = apiId
            self.format = format
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try validate(self.typeName, name: "typeName", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTypeResponse: AWSDecodableShape {

        /// The Type object.
        public let `type`: `Type`?

        public init(type: `Type`? = nil) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct GraphqlApi: AWSDecodableShape {

        /// A list of additional authentication providers for the GraphqlApi API.
        public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
        /// The API ID.
        public let apiId: String?
        /// The ARN.
        public let arn: String?
        /// The authentication type.
        public let authenticationType: AuthenticationType?
        /// The Amazon CloudWatch Logs configuration.
        public let logConfig: LogConfig?
        /// The API name.
        public let name: String?
        /// The OpenID Connect configuration.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// The tags.
        public let tags: [String: String]?
        /// The URIs.
        public let uris: [String: String]?
        /// The Amazon Cognito user pool configuration.
        public let userPoolConfig: UserPoolConfig?
        /// A flag representing whether X-Ray tracing is enabled for this GraphqlApi.
        public let xrayEnabled: Bool?

        public init(additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil, apiId: String? = nil, arn: String? = nil, authenticationType: AuthenticationType? = nil, logConfig: LogConfig? = nil, name: String? = nil, openIDConnectConfig: OpenIDConnectConfig? = nil, tags: [String: String]? = nil, uris: [String: String]? = nil, userPoolConfig: UserPoolConfig? = nil, xrayEnabled: Bool? = nil) {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.arn = arn
            self.authenticationType = authenticationType
            self.logConfig = logConfig
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.tags = tags
            self.uris = uris
            self.userPoolConfig = userPoolConfig
            self.xrayEnabled = xrayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthenticationProviders = "additionalAuthenticationProviders"
            case apiId = "apiId"
            case arn = "arn"
            case authenticationType = "authenticationType"
            case logConfig = "logConfig"
            case name = "name"
            case openIDConnectConfig = "openIDConnectConfig"
            case tags = "tags"
            case uris = "uris"
            case userPoolConfig = "userPoolConfig"
            case xrayEnabled = "xrayEnabled"
        }
    }

    public struct HttpDataSourceConfig: AWSEncodableShape & AWSDecodableShape {

        /// The authorization config in case the HTTP endpoint requires authorization.
        public let authorizationConfig: AuthorizationConfig?
        /// The HTTP URL endpoint. You can either specify the domain name or IP, and port combination, and the URL scheme must be HTTP or HTTPS. If the port is not specified, AWS AppSync uses the default port 80 for the HTTP endpoint and port 443 for HTTPS endpoints.
        public let endpoint: String?

        public init(authorizationConfig: AuthorizationConfig? = nil, endpoint: String? = nil) {
            self.authorizationConfig = authorizationConfig
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationConfig = "authorizationConfig"
            case endpoint = "endpoint"
        }
    }

    public struct LambdaConflictHandlerConfig: AWSEncodableShape & AWSDecodableShape {

        /// The Arn for the Lambda function to use as the Conflict Handler.
        public let lambdaConflictHandlerArn: String?

        public init(lambdaConflictHandlerArn: String? = nil) {
            self.lambdaConflictHandlerArn = lambdaConflictHandlerArn
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaConflictHandlerArn = "lambdaConflictHandlerArn"
        }
    }

    public struct LambdaDataSourceConfig: AWSEncodableShape & AWSDecodableShape {

        /// The ARN for the Lambda function.
        public let lambdaFunctionArn: String

        public init(lambdaFunctionArn: String) {
            self.lambdaFunctionArn = lambdaFunctionArn
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctionArn = "lambdaFunctionArn"
        }
    }

    public struct ListApiKeysRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The API ID.
        public let apiId: String
        /// The maximum number of results you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "[\\\\S]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApiKeysResponse: AWSDecodableShape {

        /// The ApiKey objects.
        public let apiKeys: [ApiKey]?
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(apiKeys: [ApiKey]? = nil, nextToken: String? = nil) {
            self.apiKeys = apiKeys
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeys = "apiKeys"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The API ID.
        public let apiId: String
        /// The maximum number of results you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "[\\\\S]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {

        /// The DataSource objects.
        public let dataSources: [DataSource]?
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(dataSources: [DataSource]? = nil, nextToken: String? = nil) {
            self.dataSources = dataSources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "dataSources"
            case nextToken = "nextToken"
        }
    }

    public struct ListFunctionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The GraphQL API ID.
        public let apiId: String
        /// The maximum number of results you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "[\\\\S]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFunctionsResponse: AWSDecodableShape {

        /// A list of Function objects.
        public let functions: [FunctionConfiguration]?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
        public let nextToken: String?

        public init(functions: [FunctionConfiguration]? = nil, nextToken: String? = nil) {
            self.functions = functions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "functions"
            case nextToken = "nextToken"
        }
    }

    public struct ListGraphqlApisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "[\\\\S]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGraphqlApisResponse: AWSDecodableShape {

        /// The GraphqlApi objects.
        public let graphqlApis: [GraphqlApi]?
        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?

        public init(graphqlApis: [GraphqlApi]? = nil, nextToken: String? = nil) {
            self.graphqlApis = graphqlApis
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApis = "graphqlApis"
            case nextToken = "nextToken"
        }
    }

    public struct ListResolversByFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "functionId", location: .uri(locationName: "functionId")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The API ID.
        public let apiId: String
        /// The Function ID.
        public let functionId: String
        /// The maximum number of results you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
        public let nextToken: String?

        public init(apiId: String, functionId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.functionId = functionId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "[\\\\S]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResolversByFunctionResponse: AWSDecodableShape {

        /// An identifier that can be used to return the next set of items in the list.
        public let nextToken: String?
        /// The list of resolvers.
        public let resolvers: [Resolver]?

        public init(nextToken: String? = nil, resolvers: [Resolver]? = nil) {
            self.nextToken = nextToken
            self.resolvers = resolvers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resolvers = "resolvers"
        }
    }

    public struct ListResolversRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The API ID.
        public let apiId: String
        /// The maximum number of results you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?
        /// The type name.
        public let typeName: String

        public init(apiId: String, maxResults: Int? = nil, nextToken: String? = nil, typeName: String) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "[\\\\S]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResolversResponse: AWSDecodableShape {

        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// The Resolver objects.
        public let resolvers: [Resolver]?

        public init(nextToken: String? = nil, resolvers: [Resolver]? = nil) {
            self.nextToken = nextToken
            self.resolvers = resolvers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resolvers = "resolvers"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The GraphqlApi ARN.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, max: 75)
            try validate(self.resourceArn, name: "resourceArn", parent: name, min: 70)
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\\d{12}:apis/[0-9A-Za-z_-]{26}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        /// A TagMap object.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "format", location: .querystring(locationName: "format")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The API ID.
        public let apiId: String
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat
        /// The maximum number of results you want the request to return.
        public let maxResults: Int?
        /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list. 
        public let nextToken: String?

        public init(apiId: String, format: TypeDefinitionFormat, maxResults: Int? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.format = format
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try validate(self.nextToken, name: "nextToken", parent: name, max: 65536)
            try validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try validate(self.nextToken, name: "nextToken", parent: name, pattern: "[\\\\S]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTypesResponse: AWSDecodableShape {

        /// An identifier to be passed in the next request to this operation to return the next set of items in the list.
        public let nextToken: String?
        /// The Type objects.
        public let types: [`Type`]?

        public init(nextToken: String? = nil, types: [`Type`]? = nil) {
            self.nextToken = nextToken
            self.types = types
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case types = "types"
        }
    }

    public struct LogConfig: AWSEncodableShape & AWSDecodableShape {

        /// The service role that AWS AppSync will assume to publish to Amazon CloudWatch logs in your account. 
        public let cloudWatchLogsRoleArn: String
        /// Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.
        public let excludeVerboseContent: Bool?
        /// The field logging level. Values can be NONE, ERROR, or ALL.     NONE: No field-level logs are captured.    ERROR: Logs the following information only for the fields that are in error:   The error section in the server response.   Field-level errors.   The generated request/response functions that got resolved for error fields.      ALL: The following information is logged for all fields in the query:   Field-level tracing information.   The generated request/response functions that got resolved for each field.    
        public let fieldLogLevel: FieldLogLevel

        public init(cloudWatchLogsRoleArn: String, excludeVerboseContent: Bool? = nil, fieldLogLevel: FieldLogLevel) {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsRoleArn = "cloudWatchLogsRoleArn"
            case excludeVerboseContent = "excludeVerboseContent"
            case fieldLogLevel = "fieldLogLevel"
        }
    }

    public struct OpenIDConnectConfig: AWSEncodableShape & AWSDecodableShape {

        /// The number of milliseconds a token is valid after being authenticated.
        public let authTTL: Int64?
        /// The client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
        public let clientId: String?
        /// The number of milliseconds a token is valid after being issued to a user.
        public let iatTTL: Int64?
        /// The issuer for the OpenID Connect configuration. The issuer returned by discovery must exactly match the value of iss in the ID token.
        public let issuer: String

        public init(authTTL: Int64? = nil, clientId: String? = nil, iatTTL: Int64? = nil, issuer: String) {
            self.authTTL = authTTL
            self.clientId = clientId
            self.iatTTL = iatTTL
            self.issuer = issuer
        }

        private enum CodingKeys: String, CodingKey {
            case authTTL = "authTTL"
            case clientId = "clientId"
            case iatTTL = "iatTTL"
            case issuer = "issuer"
        }
    }

    public struct PipelineConfig: AWSEncodableShape & AWSDecodableShape {

        /// A list of Function objects.
        public let functions: [String]?

        public init(functions: [String]? = nil) {
            self.functions = functions
        }

        private enum CodingKeys: String, CodingKey {
            case functions = "functions"
        }
    }

    public struct RdsHttpEndpointConfig: AWSEncodableShape & AWSDecodableShape {

        /// AWS Region for RDS HTTP endpoint.
        public let awsRegion: String?
        /// AWS secret store ARN for database credentials.
        public let awsSecretStoreArn: String?
        /// Logical database name.
        public let databaseName: String?
        /// Amazon RDS cluster identifier.
        public let dbClusterIdentifier: String?
        /// Logical schema name.
        public let schema: String?

        public init(awsRegion: String? = nil, awsSecretStoreArn: String? = nil, databaseName: String? = nil, dbClusterIdentifier: String? = nil, schema: String? = nil) {
            self.awsRegion = awsRegion
            self.awsSecretStoreArn = awsSecretStoreArn
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case awsRegion = "awsRegion"
            case awsSecretStoreArn = "awsSecretStoreArn"
            case databaseName = "databaseName"
            case dbClusterIdentifier = "dbClusterIdentifier"
            case schema = "schema"
        }
    }

    public struct RelationalDatabaseDataSourceConfig: AWSEncodableShape & AWSDecodableShape {

        /// Amazon RDS HTTP endpoint settings.
        public let rdsHttpEndpointConfig: RdsHttpEndpointConfig?
        /// Source type for the relational database.    RDS_HTTP_ENDPOINT: The relational database source type is an Amazon RDS HTTP endpoint.  
        public let relationalDatabaseSourceType: RelationalDatabaseSourceType?

        public init(rdsHttpEndpointConfig: RdsHttpEndpointConfig? = nil, relationalDatabaseSourceType: RelationalDatabaseSourceType? = nil) {
            self.rdsHttpEndpointConfig = rdsHttpEndpointConfig
            self.relationalDatabaseSourceType = relationalDatabaseSourceType
        }

        private enum CodingKeys: String, CodingKey {
            case rdsHttpEndpointConfig = "rdsHttpEndpointConfig"
            case relationalDatabaseSourceType = "relationalDatabaseSourceType"
        }
    }

    public struct Resolver: AWSDecodableShape {

        /// The caching configuration for the resolver.
        public let cachingConfig: CachingConfig?
        /// The resolver data source name.
        public let dataSourceName: String?
        /// The resolver field name.
        public let fieldName: String?
        /// The resolver type.    UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. A UNIT resolver enables you to execute a GraphQL query against a single data source.    PIPELINE: A PIPELINE resolver type. A PIPELINE resolver enables you to execute a series of Function in a serial manner. You can use a pipeline resolver to execute a GraphQL query against multiple data sources.  
        public let kind: ResolverKind?
        /// The PipelineConfig.
        public let pipelineConfig: PipelineConfig?
        /// The request mapping template.
        public let requestMappingTemplate: String?
        /// The resolver ARN.
        public let resolverArn: String?
        /// The response mapping template.
        public let responseMappingTemplate: String?
        /// The SyncConfig for a resolver attached to a versioned datasource.
        public let syncConfig: SyncConfig?
        /// The resolver type name.
        public let typeName: String?

        public init(cachingConfig: CachingConfig? = nil, dataSourceName: String? = nil, fieldName: String? = nil, kind: ResolverKind? = nil, pipelineConfig: PipelineConfig? = nil, requestMappingTemplate: String? = nil, resolverArn: String? = nil, responseMappingTemplate: String? = nil, syncConfig: SyncConfig? = nil, typeName: String? = nil) {
            self.cachingConfig = cachingConfig
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.resolverArn = resolverArn
            self.responseMappingTemplate = responseMappingTemplate
            self.syncConfig = syncConfig
            self.typeName = typeName
        }

        private enum CodingKeys: String, CodingKey {
            case cachingConfig = "cachingConfig"
            case dataSourceName = "dataSourceName"
            case fieldName = "fieldName"
            case kind = "kind"
            case pipelineConfig = "pipelineConfig"
            case requestMappingTemplate = "requestMappingTemplate"
            case resolverArn = "resolverArn"
            case responseMappingTemplate = "responseMappingTemplate"
            case syncConfig = "syncConfig"
            case typeName = "typeName"
        }
    }

    public struct StartSchemaCreationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// The API ID.
        public let apiId: String
        /// The schema definition, in GraphQL schema language format.
        public let definition: Data

        public init(apiId: String, definition: Data) {
            self.apiId = apiId
            self.definition = definition
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
        }
    }

    public struct StartSchemaCreationResponse: AWSDecodableShape {

        /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
        public let status: SchemaStatus?

        public init(status: SchemaStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct SyncConfig: AWSEncodableShape & AWSDecodableShape {

        /// The Conflict Detection strategy to use.    VERSION: Detect conflicts based on object versions for this resolver.    NONE: Do not detect conflicts when executing this resolver.  
        public let conflictDetection: ConflictDetectionType?
        /// The Conflict Resolution strategy to perform in the event of a conflict.    OPTIMISTIC_CONCURRENCY: Resolve conflicts by rejecting mutations when versions do not match the latest version at the server.    AUTOMERGE: Resolve conflicts with the Automerge conflict resolution strategy.    LAMBDA: Resolve conflicts with a Lambda function supplied in the LambdaConflictHandlerConfig.  
        public let conflictHandler: ConflictHandlerType?
        /// The LambdaConflictHandlerConfig when configuring LAMBDA as the Conflict Handler.
        public let lambdaConflictHandlerConfig: LambdaConflictHandlerConfig?

        public init(conflictDetection: ConflictDetectionType? = nil, conflictHandler: ConflictHandlerType? = nil, lambdaConflictHandlerConfig: LambdaConflictHandlerConfig? = nil) {
            self.conflictDetection = conflictDetection
            self.conflictHandler = conflictHandler
            self.lambdaConflictHandlerConfig = lambdaConflictHandlerConfig
        }

        private enum CodingKeys: String, CodingKey {
            case conflictDetection = "conflictDetection"
            case conflictHandler = "conflictHandler"
            case lambdaConflictHandlerConfig = "lambdaConflictHandlerConfig"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The GraphqlApi ARN.
        public let resourceArn: String
        /// A TagMap object.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, max: 75)
            try validate(self.resourceArn, name: "resourceArn", parent: name, min: 70)
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\\d{12}:apis/[0-9A-Za-z_-]{26}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct `Type`: AWSDecodableShape {

        /// The type ARN.
        public let arn: String?
        /// The type definition.
        public let definition: String?
        /// The type description.
        public let description: String?
        /// The type format: SDL or JSON.
        public let format: TypeDefinitionFormat?
        /// The type name.
        public let name: String?

        public init(arn: String? = nil, definition: String? = nil, description: String? = nil, format: TypeDefinitionFormat? = nil, name: String? = nil) {
            self.arn = arn
            self.definition = definition
            self.description = description
            self.format = format
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case definition = "definition"
            case description = "description"
            case format = "format"
            case name = "name"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The GraphqlApi ARN.
        public let resourceArn: String
        /// A list of TagKey objects.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name: "resourceArn", parent: name, max: 75)
            try validate(self.resourceArn, name: "resourceArn", parent: name, min: 70)
            try validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:appsync:[A-Za-z0-9_/.-]{0,63}:\\d{12}:apis/[0-9A-Za-z_-]{26}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateApiCacheRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// Caching behavior.    FULL_REQUEST_CACHING: All requests are fully cached.    PER_RESOLVER_CACHING: Individual resovlers that you specify are cached.  
        public let apiCachingBehavior: ApiCachingBehavior
        /// The GraphQL API Id.
        public let apiId: String
        /// TTL in seconds for cache entries. Valid values are between 1 and 3600 seconds.
        public let ttl: Int64
        /// The cache instance type.    T2_SMALL: A t2.small instance type.    T2_MEDIUM: A t2.medium instance type.    R4_LARGE: A r4.large instance type.    R4_XLARGE: A r4.xlarge instance type.    R4_2XLARGE: A r4.2xlarge instance type.    R4_4XLARGE: A r4.4xlarge instance type.    R4_8XLARGE: A r4.8xlarge instance type.  
        public let `type`: ApiCacheType

        public init(apiCachingBehavior: ApiCachingBehavior, apiId: String, ttl: Int64, type: ApiCacheType) {
            self.apiCachingBehavior = apiCachingBehavior
            self.apiId = apiId
            self.ttl = ttl
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case apiCachingBehavior = "apiCachingBehavior"
            case ttl = "ttl"
            case `type` = "type"
        }
    }

    public struct UpdateApiCacheResponse: AWSDecodableShape {

        /// The ApiCache object.
        public let apiCache: ApiCache?

        public init(apiCache: ApiCache? = nil) {
            self.apiCache = apiCache
        }

        private enum CodingKeys: String, CodingKey {
            case apiCache = "apiCache"
        }
    }

    public struct UpdateApiKeyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        /// The ID for the GraphQL API.
        public let apiId: String
        /// A description of the purpose of the API key.
        public let description: String?
        /// The time from update time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .
        public let expires: Int64?
        /// The API key ID.
        public let id: String

        public init(apiId: String, description: String? = nil, expires: Int64? = nil, id: String) {
            self.apiId = apiId
            self.description = description
            self.expires = expires
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case expires = "expires"
        }
    }

    public struct UpdateApiKeyResponse: AWSDecodableShape {

        /// The API key.
        public let apiKey: ApiKey?

        public init(apiKey: ApiKey? = nil) {
            self.apiKey = apiKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The API ID.
        public let apiId: String
        /// The new description for the data source.
        public let description: String?
        /// The new Amazon DynamoDB configuration.
        public let dynamodbConfig: DynamodbDataSourceConfig?
        /// The new Elasticsearch Service configuration.
        public let elasticsearchConfig: ElasticsearchDataSourceConfig?
        /// The new HTTP endpoint configuration.
        public let httpConfig: HttpDataSourceConfig?
        /// The new AWS Lambda configuration.
        public let lambdaConfig: LambdaDataSourceConfig?
        /// The new name for the data source.
        public let name: String
        /// The new relational database configuration.
        public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
        /// The new service role ARN for the data source.
        public let serviceRoleArn: String?
        /// The new data source type.
        public let `type`: DataSourceType

        public init(apiId: String, description: String? = nil, dynamodbConfig: DynamodbDataSourceConfig? = nil, elasticsearchConfig: ElasticsearchDataSourceConfig? = nil, httpConfig: HttpDataSourceConfig? = nil, lambdaConfig: LambdaDataSourceConfig? = nil, name: String, relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil, serviceRoleArn: String? = nil, type: DataSourceType) {
            self.apiId = apiId
            self.description = description
            self.dynamodbConfig = dynamodbConfig
            self.elasticsearchConfig = elasticsearchConfig
            self.httpConfig = httpConfig
            self.lambdaConfig = lambdaConfig
            self.name = name
            self.relationalDatabaseConfig = relationalDatabaseConfig
            self.serviceRoleArn = serviceRoleArn
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.name, name: "name", parent: name, max: 65536)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case dynamodbConfig = "dynamodbConfig"
            case elasticsearchConfig = "elasticsearchConfig"
            case httpConfig = "httpConfig"
            case lambdaConfig = "lambdaConfig"
            case relationalDatabaseConfig = "relationalDatabaseConfig"
            case serviceRoleArn = "serviceRoleArn"
            case `type` = "type"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {

        /// The updated DataSource object.
        public let dataSource: DataSource?

        public init(dataSource: DataSource? = nil) {
            self.dataSource = dataSource
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
        }
    }

    public struct UpdateFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "functionId", location: .uri(locationName: "functionId"))
        ]

        /// The GraphQL API ID.
        public let apiId: String
        /// The Function DataSource name.
        public let dataSourceName: String
        /// The Function description.
        public let description: String?
        /// The function ID.
        public let functionId: String
        /// The version of the request mapping template. Currently the supported value is 2018-05-29. 
        public let functionVersion: String
        /// The Function name.
        public let name: String
        /// The Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
        public let requestMappingTemplate: String
        /// The Function request mapping template. 
        public let responseMappingTemplate: String?

        public init(apiId: String, dataSourceName: String, description: String? = nil, functionId: String, functionVersion: String, name: String, requestMappingTemplate: String, responseMappingTemplate: String? = nil) {
            self.apiId = apiId
            self.dataSourceName = dataSourceName
            self.description = description
            self.functionId = functionId
            self.functionVersion = functionVersion
            self.name = name
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
        }

        public func validate(name: String) throws {
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.functionId, name: "functionId", parent: name, max: 65536)
            try validate(self.functionId, name: "functionId", parent: name, min: 1)
            try validate(self.functionId, name: "functionId", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.name, name: "name", parent: name, max: 65536)
            try validate(self.name, name: "name", parent: name, min: 1)
            try validate(self.name, name: "name", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceName = "dataSourceName"
            case description = "description"
            case functionVersion = "functionVersion"
            case name = "name"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
        }
    }

    public struct UpdateFunctionResponse: AWSDecodableShape {

        /// The Function object.
        public let functionConfiguration: FunctionConfiguration?

        public init(functionConfiguration: FunctionConfiguration? = nil) {
            self.functionConfiguration = functionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case functionConfiguration = "functionConfiguration"
        }
    }

    public struct UpdateGraphqlApiRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId"))
        ]

        /// A list of additional authentication providers for the GraphqlApi API.
        public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
        /// The API ID.
        public let apiId: String
        /// The new authentication type for the GraphqlApi object.
        public let authenticationType: AuthenticationType?
        /// The Amazon CloudWatch Logs configuration for the GraphqlApi object.
        public let logConfig: LogConfig?
        /// The new name for the GraphqlApi object.
        public let name: String
        /// The OpenID Connect configuration for the GraphqlApi object.
        public let openIDConnectConfig: OpenIDConnectConfig?
        /// The new Amazon Cognito user pool configuration for the GraphqlApi object.
        public let userPoolConfig: UserPoolConfig?
        /// A flag indicating whether to enable X-Ray tracing for the GraphqlApi.
        public let xrayEnabled: Bool?

        public init(additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil, apiId: String, authenticationType: AuthenticationType? = nil, logConfig: LogConfig? = nil, name: String, openIDConnectConfig: OpenIDConnectConfig? = nil, userPoolConfig: UserPoolConfig? = nil, xrayEnabled: Bool? = nil) {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.authenticationType = authenticationType
            self.logConfig = logConfig
            self.name = name
            self.openIDConnectConfig = openIDConnectConfig
            self.userPoolConfig = userPoolConfig
            self.xrayEnabled = xrayEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAuthenticationProviders = "additionalAuthenticationProviders"
            case authenticationType = "authenticationType"
            case logConfig = "logConfig"
            case name = "name"
            case openIDConnectConfig = "openIDConnectConfig"
            case userPoolConfig = "userPoolConfig"
            case xrayEnabled = "xrayEnabled"
        }
    }

    public struct UpdateGraphqlApiResponse: AWSDecodableShape {

        /// The updated GraphqlApi object.
        public let graphqlApi: GraphqlApi?

        public init(graphqlApi: GraphqlApi? = nil) {
            self.graphqlApi = graphqlApi
        }

        private enum CodingKeys: String, CodingKey {
            case graphqlApi = "graphqlApi"
        }
    }

    public struct UpdateResolverRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "fieldName", location: .uri(locationName: "fieldName")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The API ID.
        public let apiId: String
        /// The caching configuration for the resolver.
        public let cachingConfig: CachingConfig?
        /// The new data source name.
        public let dataSourceName: String?
        /// The new field name.
        public let fieldName: String
        /// The resolver type.    UNIT: A UNIT resolver type. A UNIT resolver is the default resolver type. A UNIT resolver enables you to execute a GraphQL query against a single data source.    PIPELINE: A PIPELINE resolver type. A PIPELINE resolver enables you to execute a series of Function in a serial manner. You can use a pipeline resolver to execute a GraphQL query against multiple data sources.  
        public let kind: ResolverKind?
        /// The PipelineConfig.
        public let pipelineConfig: PipelineConfig?
        /// The new request mapping template.
        public let requestMappingTemplate: String
        /// The new response mapping template.
        public let responseMappingTemplate: String?
        /// The SyncConfig for a resolver attached to a versioned datasource.
        public let syncConfig: SyncConfig?
        /// The new type name.
        public let typeName: String

        public init(apiId: String, cachingConfig: CachingConfig? = nil, dataSourceName: String? = nil, fieldName: String, kind: ResolverKind? = nil, pipelineConfig: PipelineConfig? = nil, requestMappingTemplate: String, responseMappingTemplate: String? = nil, syncConfig: SyncConfig? = nil, typeName: String) {
            self.apiId = apiId
            self.cachingConfig = cachingConfig
            self.dataSourceName = dataSourceName
            self.fieldName = fieldName
            self.kind = kind
            self.pipelineConfig = pipelineConfig
            self.requestMappingTemplate = requestMappingTemplate
            self.responseMappingTemplate = responseMappingTemplate
            self.syncConfig = syncConfig
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, max: 65536)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, min: 1)
            try validate(self.dataSourceName, name: "dataSourceName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.fieldName, name: "fieldName", parent: name, max: 65536)
            try validate(self.fieldName, name: "fieldName", parent: name, min: 1)
            try validate(self.fieldName, name: "fieldName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, max: 65536)
            try validate(self.requestMappingTemplate, name: "requestMappingTemplate", parent: name, min: 1)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, max: 65536)
            try validate(self.responseMappingTemplate, name: "responseMappingTemplate", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try validate(self.typeName, name: "typeName", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case cachingConfig = "cachingConfig"
            case dataSourceName = "dataSourceName"
            case kind = "kind"
            case pipelineConfig = "pipelineConfig"
            case requestMappingTemplate = "requestMappingTemplate"
            case responseMappingTemplate = "responseMappingTemplate"
            case syncConfig = "syncConfig"
        }
    }

    public struct UpdateResolverResponse: AWSDecodableShape {

        /// The updated Resolver object.
        public let resolver: Resolver?

        public init(resolver: Resolver? = nil) {
            self.resolver = resolver
        }

        private enum CodingKeys: String, CodingKey {
            case resolver = "resolver"
        }
    }

    public struct UpdateTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "apiId", location: .uri(locationName: "apiId")), 
            AWSMemberEncoding(label: "typeName", location: .uri(locationName: "typeName"))
        ]

        /// The API ID.
        public let apiId: String
        /// The new definition.
        public let definition: String?
        /// The new type format: SDL or JSON.
        public let format: TypeDefinitionFormat
        /// The new type name.
        public let typeName: String

        public init(apiId: String, definition: String? = nil, format: TypeDefinitionFormat, typeName: String) {
            self.apiId = apiId
            self.definition = definition
            self.format = format
            self.typeName = typeName
        }

        public func validate(name: String) throws {
            try validate(self.typeName, name: "typeName", parent: name, max: 65536)
            try validate(self.typeName, name: "typeName", parent: name, min: 1)
            try validate(self.typeName, name: "typeName", parent: name, pattern: "[_A-Za-z][_0-9A-Za-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case format = "format"
        }
    }

    public struct UpdateTypeResponse: AWSDecodableShape {

        /// The updated Type object.
        public let `type`: `Type`?

        public init(type: `Type`? = nil) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct UserPoolConfig: AWSEncodableShape & AWSDecodableShape {

        /// A regular expression for validating the incoming Amazon Cognito user pool app client ID.
        public let appIdClientRegex: String?
        /// The AWS Region in which the user pool was created.
        public let awsRegion: String
        /// The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pool authentication doesn't match the Amazon Cognito user pool configuration.
        public let defaultAction: DefaultAction
        /// The user pool ID.
        public let userPoolId: String

        public init(appIdClientRegex: String? = nil, awsRegion: String, defaultAction: DefaultAction, userPoolId: String) {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }

        private enum CodingKeys: String, CodingKey {
            case appIdClientRegex = "appIdClientRegex"
            case awsRegion = "awsRegion"
            case defaultAction = "defaultAction"
            case userPoolId = "userPoolId"
        }
    }
}

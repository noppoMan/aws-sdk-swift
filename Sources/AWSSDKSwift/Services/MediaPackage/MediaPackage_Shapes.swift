// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/noppoMan/aws-sdk-swift/blob/master/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension MediaPackage {

    public enum AdMarkers: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case scte35Enhanced = "SCTE35_ENHANCED"
        case passthrough = "PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum AdsOnDeliveryRestrictions: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case restricted = "RESTRICTED"
        case unrestricted = "UNRESTRICTED"
        case both = "BOTH"
        public var description: String { return self.rawValue }
    }

    public struct Channel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsIngest", location: .body(locationName: "hlsIngest"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// The Amazon Resource Name (ARN) assigned to the Channel.
        public let arn: String?
        /// A short text description of the Channel.
        public let description: String?
        public let hlsIngest: HlsIngest?
        /// The ID of the Channel.
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct ChannelCreateParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        /// A short text description of the Channel.
        public let description: String?
        /// The ID of the Channel. The ID must be unique within the region and it
        /// cannot be changed after a Channel is created.
        public let id: String
        public let tags: [String: String]?

        public init(description: String? = nil, id: String, tags: [String: String]? = nil) {
            self.description = description
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct ChannelList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        /// A list of Channel records.
        public let channels: [Channel]?
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?

        public init(channels: [Channel]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case nextToken = "nextToken"
        }
    }

    public struct ChannelUpdateParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string)
        ]
        /// A short text description of the Channel.
        public let description: String?

        public init(description: String? = nil) {
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct CmafEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KeyRotationIntervalSeconds", location: .body(locationName: "keyRotationIntervalSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]
        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int32?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(keyRotationIntervalSeconds: Int32? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct CmafPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsManifests", location: .body(locationName: "hlsManifests"), required: false, type: .list), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentPrefix", location: .body(locationName: "segmentPrefix"), required: false, type: .string), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure)
        ]
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifest]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int32?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifest]? = nil, segmentDurationSeconds: Int32? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentPrefix = "segmentPrefix"
            case streamSelection = "streamSelection"
        }
    }

    public struct CmafPackageCreateOrUpdateParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "HlsManifests", location: .body(locationName: "hlsManifests"), required: false, type: .list), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentPrefix", location: .body(locationName: "segmentPrefix"), required: false, type: .string), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure)
        ]
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations
        public let hlsManifests: [HlsManifestCreateOrUpdateParameters]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int32?
        /// An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
        public let segmentPrefix: String?
        public let streamSelection: StreamSelection?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifestCreateOrUpdateParameters]? = nil, segmentDurationSeconds: Int32? = nil, segmentPrefix: String? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentPrefix = segmentPrefix
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentPrefix = "segmentPrefix"
            case streamSelection = "streamSelection"
        }
    }

    public struct CreateChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        public let description: String?
        public let id: String
        public let tags: [String: String]?

        public init(description: String? = nil, id: String, tags: [String: String]? = nil) {
            self.description = description
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsIngest", location: .body(locationName: "hlsIngest"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateOriginEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelId", location: .body(locationName: "channelId"), required: true, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        public let channelId: String
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let startoverWindowSeconds: Int32?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int32?
        public let whitelist: [String]?

        public init(channelId: String, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int32? = nil, whitelist: [String]? = nil) {
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public struct CreateOriginEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "ChannelId", location: .body(locationName: "channelId"), required: false, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        public let arn: String?
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let startoverWindowSeconds: Int32?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int32?
        public let url: String?
        public let whitelist: [String]?

        public init(arn: String? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int32? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct DashEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KeyRotationIntervalSeconds", location: .body(locationName: "keyRotationIntervalSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]
        /// Time (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int32?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(keyRotationIntervalSeconds: Int32? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct DashPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdTriggers", location: .body(locationName: "adTriggers"), required: false, type: .list), 
            AWSShapeMember(label: "AdsOnDeliveryRestrictions", location: .body(locationName: "adsOnDeliveryRestrictions"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "ManifestLayout", location: .body(locationName: "manifestLayout"), required: false, type: .enum), 
            AWSShapeMember(label: "ManifestWindowSeconds", location: .body(locationName: "manifestWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "MinBufferTimeSeconds", location: .body(locationName: "minBufferTimeSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "MinUpdatePeriodSeconds", location: .body(locationName: "minUpdatePeriodSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "PeriodTriggers", location: .body(locationName: "periodTriggers"), required: false, type: .list), 
            AWSShapeMember(label: "Profile", location: .body(locationName: "profile"), required: false, type: .enum), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentTemplateFormat", location: .body(locationName: "segmentTemplateFormat"), required: false, type: .enum), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure), 
            AWSShapeMember(label: "SuggestedPresentationDelaySeconds", location: .body(locationName: "suggestedPresentationDelaySeconds"), required: false, type: .integer)
        ]
        public let adTriggers: [Adtriggerselement]?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let encryption: DashEncryption?
        /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public let manifestLayout: ManifestLayout?
        /// Time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int32?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public let minBufferTimeSeconds: Int32?
        /// Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
        public let minUpdatePeriodSeconds: Int32?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
        /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
        /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
        /// the Channel source contains SCTE-35 ad markers.
        public let periodTriggers: [Periodtriggerselement]?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public let profile: Profile?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int32?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public let segmentTemplateFormat: SegmentTemplateFormat?
        public let streamSelection: StreamSelection?
        /// Duration (in seconds) to delay live content before presentation.
        public let suggestedPresentationDelaySeconds: Int32?

        public init(adTriggers: [Adtriggerselement]? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, encryption: DashEncryption? = nil, manifestLayout: ManifestLayout? = nil, manifestWindowSeconds: Int32? = nil, minBufferTimeSeconds: Int32? = nil, minUpdatePeriodSeconds: Int32? = nil, periodTriggers: [Periodtriggerselement]? = nil, profile: Profile? = nil, segmentDurationSeconds: Int32? = nil, segmentTemplateFormat: SegmentTemplateFormat? = nil, streamSelection: StreamSelection? = nil, suggestedPresentationDelaySeconds: Int32? = nil) {
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.manifestLayout = manifestLayout
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.periodTriggers = periodTriggers
            self.profile = profile
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
            self.streamSelection = streamSelection
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adTriggers = "adTriggers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case encryption = "encryption"
            case manifestLayout = "manifestLayout"
            case manifestWindowSeconds = "manifestWindowSeconds"
            case minBufferTimeSeconds = "minBufferTimeSeconds"
            case minUpdatePeriodSeconds = "minUpdatePeriodSeconds"
            case periodTriggers = "periodTriggers"
            case profile = "profile"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentTemplateFormat = "segmentTemplateFormat"
            case streamSelection = "streamSelection"
            case suggestedPresentationDelaySeconds = "suggestedPresentationDelaySeconds"
        }
    }

    public struct DeleteChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteChannelResponse: AWSShape {

        public init() {
        }

    }

    public struct DeleteOriginEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DeleteOriginEndpointResponse: AWSShape {

        public init() {
        }

    }

    public struct DescribeChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribeChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsIngest", location: .body(locationName: "hlsIngest"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct DescribeOriginEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct DescribeOriginEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "ChannelId", location: .body(locationName: "channelId"), required: false, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        public let arn: String?
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let startoverWindowSeconds: Int32?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int32?
        public let url: String?
        public let whitelist: [String]?

        public init(arn: String? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int32? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public enum EncryptionMethod: String, CustomStringConvertible, Codable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public struct HlsEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConstantInitializationVector", location: .body(locationName: "constantInitializationVector"), required: false, type: .string), 
            AWSShapeMember(label: "EncryptionMethod", location: .body(locationName: "encryptionMethod"), required: false, type: .enum), 
            AWSShapeMember(label: "KeyRotationIntervalSeconds", location: .body(locationName: "keyRotationIntervalSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "RepeatExtXKey", location: .body(locationName: "repeatExtXKey"), required: false, type: .boolean), 
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]
        /// A constant initialization vector for encryption (optional).
        /// When not specified the initialization vector will be periodically rotated.
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod?
        /// Interval (in seconds) between each encryption key rotation.
        public let keyRotationIntervalSeconds: Int32?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public let repeatExtXKey: Bool?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod? = nil, keyRotationIntervalSeconds: Int32? = nil, repeatExtXKey: Bool? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.keyRotationIntervalSeconds = keyRotationIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case keyRotationIntervalSeconds = "keyRotationIntervalSeconds"
            case repeatExtXKey = "repeatExtXKey"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct HlsIngest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IngestEndpoints", location: .body(locationName: "ingestEndpoints"), required: false, type: .list)
        ]
        /// A list of endpoints to which the source stream should be sent.
        public let ingestEndpoints: [IngestEndpoint]?

        public init(ingestEndpoints: [IngestEndpoint]? = nil) {
            self.ingestEndpoints = ingestEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case ingestEndpoints = "ingestEndpoints"
        }
    }

    public struct HlsManifest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdMarkers", location: .body(locationName: "adMarkers"), required: false, type: .enum), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "IncludeIframeOnlyStream", location: .body(locationName: "includeIframeOnlyStream"), required: false, type: .boolean), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "PlaylistType", location: .body(locationName: "playlistType"), required: false, type: .enum), 
            AWSShapeMember(label: "PlaylistWindowSeconds", location: .body(locationName: "playlistWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramDateTimeIntervalSeconds", location: .body(locationName: "programDateTimeIntervalSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string)
        ]
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int32?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int32?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?

        public init(adMarkers: AdMarkers? = nil, id: String, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int32? = nil, programDateTimeIntervalSeconds: Int32? = nil, url: String? = nil) {
            self.adMarkers = adMarkers
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case id = "id"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case url = "url"
        }
    }

    public struct HlsManifestCreateOrUpdateParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdMarkers", location: .body(locationName: "adMarkers"), required: false, type: .enum), 
            AWSShapeMember(label: "AdTriggers", location: .body(locationName: "adTriggers"), required: false, type: .list), 
            AWSShapeMember(label: "AdsOnDeliveryRestrictions", location: .body(locationName: "adsOnDeliveryRestrictions"), required: false, type: .enum), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "IncludeIframeOnlyStream", location: .body(locationName: "includeIframeOnlyStream"), required: false, type: .boolean), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "PlaylistType", location: .body(locationName: "playlistType"), required: false, type: .enum), 
            AWSShapeMember(label: "PlaylistWindowSeconds", location: .body(locationName: "playlistWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramDateTimeIntervalSeconds", location: .body(locationName: "programDateTimeIntervalSeconds"), required: false, type: .integer)
        ]
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        public let adTriggers: [Adtriggerselement]?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        /// The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
        public let id: String
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
        public let manifestName: String?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int32?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int32?

        public init(adMarkers: AdMarkers? = nil, adTriggers: [Adtriggerselement]? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, id: String, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int32? = nil, programDateTimeIntervalSeconds: Int32? = nil) {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.id = id
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case adTriggers = "adTriggers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case id = "id"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        }
    }

    public struct HlsPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AdMarkers", location: .body(locationName: "adMarkers"), required: false, type: .enum), 
            AWSShapeMember(label: "AdTriggers", location: .body(locationName: "adTriggers"), required: false, type: .list), 
            AWSShapeMember(label: "AdsOnDeliveryRestrictions", location: .body(locationName: "adsOnDeliveryRestrictions"), required: false, type: .enum), 
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "IncludeIframeOnlyStream", location: .body(locationName: "includeIframeOnlyStream"), required: false, type: .boolean), 
            AWSShapeMember(label: "PlaylistType", location: .body(locationName: "playlistType"), required: false, type: .enum), 
            AWSShapeMember(label: "PlaylistWindowSeconds", location: .body(locationName: "playlistWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "ProgramDateTimeIntervalSeconds", location: .body(locationName: "programDateTimeIntervalSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure), 
            AWSShapeMember(label: "UseAudioRenditionGroup", location: .body(locationName: "useAudioRenditionGroup"), required: false, type: .boolean)
        ]
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        public let adTriggers: [Adtriggerselement]?
        public let adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions?
        public let encryption: HlsEncryption?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// The HTTP Live Streaming (HLS) playlist type.
        /// When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE
        /// entry will be included in the media playlist.
        public let playlistType: PlaylistType?
        /// Time window (in seconds) contained in each parent manifest.
        public let playlistWindowSeconds: Int32?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int32?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int32?
        public let streamSelection: StreamSelection?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public let useAudioRenditionGroup: Bool?

        public init(adMarkers: AdMarkers? = nil, adTriggers: [Adtriggerselement]? = nil, adsOnDeliveryRestrictions: AdsOnDeliveryRestrictions? = nil, encryption: HlsEncryption? = nil, includeIframeOnlyStream: Bool? = nil, playlistType: PlaylistType? = nil, playlistWindowSeconds: Int32? = nil, programDateTimeIntervalSeconds: Int32? = nil, segmentDurationSeconds: Int32? = nil, streamSelection: StreamSelection? = nil, useAudioRenditionGroup: Bool? = nil) {
            self.adMarkers = adMarkers
            self.adTriggers = adTriggers
            self.adsOnDeliveryRestrictions = adsOnDeliveryRestrictions
            self.encryption = encryption
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.playlistType = playlistType
            self.playlistWindowSeconds = playlistWindowSeconds
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case adTriggers = "adTriggers"
            case adsOnDeliveryRestrictions = "adsOnDeliveryRestrictions"
            case encryption = "encryption"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case playlistType = "playlistType"
            case playlistWindowSeconds = "playlistWindowSeconds"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case streamSelection = "streamSelection"
            case useAudioRenditionGroup = "useAudioRenditionGroup"
        }
    }

    public struct IngestEndpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Password", location: .body(locationName: "password"), required: false, type: .string), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "Username", location: .body(locationName: "username"), required: false, type: .string)
        ]
        /// The system generated unique identifier for the IngestEndpoint
        public let id: String?
        /// The system generated password for ingest authentication.
        public let password: String?
        /// The ingest URL to which the source stream should be sent.
        public let url: String?
        /// The system generated username for ingest authentication.
        public let username: String?

        public init(id: String? = nil, password: String? = nil, url: String? = nil, username: String? = nil) {
            self.id = id
            self.password = password
            self.url = url
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case password = "password"
            case url = "url"
            case username = "username"
        }
    }

    public struct ListChannelsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]
        public let maxResults: Int32?
        public let nextToken: String?

        public init(maxResults: Int32? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListChannelsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Channels", location: .body(locationName: "channels"), required: false, type: .list), 
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string)
        ]
        public let channels: [Channel]?
        public let nextToken: String?

        public init(channels: [Channel]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case nextToken = "nextToken"
        }
    }

    public struct ListOriginEndpointsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelId", location: .querystring(locationName: "channelId"), required: false, type: .string), 
            AWSShapeMember(label: "MaxResults", location: .querystring(locationName: "maxResults"), required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]
        public let channelId: String?
        public let maxResults: Int32?
        public let nextToken: String?

        public init(channelId: String? = nil, maxResults: Int32? = nil, nextToken: String? = nil) {
            self.channelId = channelId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelId = "channelId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListOriginEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "OriginEndpoints", location: .body(locationName: "originEndpoints"), required: false, type: .list)
        ]
        public let nextToken: String?
        public let originEndpoints: [OriginEndpoint]?

        public init(nextToken: String? = nil, originEndpoints: [OriginEndpoint]? = nil) {
            self.nextToken = nextToken
            self.originEndpoints = originEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case originEndpoints = "originEndpoints"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string)
        ]
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public enum ManifestLayout: String, CustomStringConvertible, Codable {
        case full = "FULL"
        case compact = "COMPACT"
        public var description: String { return self.rawValue }
    }

    public struct MssEncryption: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SpekeKeyProvider", location: .body(locationName: "spekeKeyProvider"), required: true, type: .structure)
        ]
        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct MssPackage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Encryption", location: .body(locationName: "encryption"), required: false, type: .structure), 
            AWSShapeMember(label: "ManifestWindowSeconds", location: .body(locationName: "manifestWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "SegmentDurationSeconds", location: .body(locationName: "segmentDurationSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "StreamSelection", location: .body(locationName: "streamSelection"), required: false, type: .structure)
        ]
        public let encryption: MssEncryption?
        /// The time window (in seconds) contained in each manifest.
        public let manifestWindowSeconds: Int32?
        /// The duration (in seconds) of each segment.
        public let segmentDurationSeconds: Int32?
        public let streamSelection: StreamSelection?

        public init(encryption: MssEncryption? = nil, manifestWindowSeconds: Int32? = nil, segmentDurationSeconds: Int32? = nil, streamSelection: StreamSelection? = nil) {
            self.encryption = encryption
            self.manifestWindowSeconds = manifestWindowSeconds
            self.segmentDurationSeconds = segmentDurationSeconds
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case manifestWindowSeconds = "manifestWindowSeconds"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case streamSelection = "streamSelection"
        }
    }

    public struct OriginEndpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "ChannelId", location: .body(locationName: "channelId"), required: false, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        /// The Amazon Resource Name (ARN) assigned to the OriginEndpoint.
        public let arn: String?
        /// The ID of the Channel the OriginEndpoint is associated with.
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.
        public let id: String?
        /// A short string appended to the end of the OriginEndpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int32?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int32?
        /// The URL of the packaged OriginEndpoint for consumption.
        public let url: String?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(arn: String? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int32? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public struct OriginEndpointCreateParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ChannelId", location: .body(locationName: "channelId"), required: true, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        /// The ID of the Channel that the OriginEndpoint will be associated with.
        /// This cannot be changed after the OriginEndpoint is created.
        public let channelId: String
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// The ID of the OriginEndpoint.  The ID must be unique within the region
        /// and it cannot be changed after the OriginEndpoint is created.
        public let id: String
        /// A short string that will be used as the filename of the OriginEndpoint URL (defaults to "index").
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Maximum duration (seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int32?
        public let tags: [String: String]?
        /// Amount of delay (seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int32?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(channelId: String, cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int32? = nil, whitelist: [String]? = nil) {
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public struct OriginEndpointList: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", location: .body(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "OriginEndpoints", location: .body(locationName: "originEndpoints"), required: false, type: .list)
        ]
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?
        /// A list of OriginEndpoint records.
        public let originEndpoints: [OriginEndpoint]?

        public init(nextToken: String? = nil, originEndpoints: [OriginEndpoint]? = nil) {
            self.nextToken = nextToken
            self.originEndpoints = originEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case originEndpoints = "originEndpoints"
        }
    }

    public struct OriginEndpointUpdateParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        /// A short text description of the OriginEndpoint.
        public let description: String?
        public let hlsPackage: HlsPackage?
        /// A short string that will be appended to the end of the Endpoint URL.
        public let manifestName: String?
        public let mssPackage: MssPackage?
        /// Maximum duration (in seconds) of content to retain for startover playback.
        /// If not specified, startover playback will be disabled for the OriginEndpoint.
        public let startoverWindowSeconds: Int32?
        /// Amount of delay (in seconds) to enforce on the playback of live content.
        /// If not specified, there will be no time delay in effect for the OriginEndpoint.
        public let timeDelaySeconds: Int32?
        /// A list of source IP CIDR blocks that will be allowed to access the OriginEndpoint.
        public let whitelist: [String]?

        public init(cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, timeDelaySeconds: Int32? = nil, whitelist: [String]? = nil) {
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public enum PlaylistType: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case event = "EVENT"
        case vod = "VOD"
        public var description: String { return self.rawValue }
    }

    public enum Profile: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case hbbtv15 = "HBBTV_1_5"
        public var description: String { return self.rawValue }
    }

    public struct RotateChannelCredentialsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct RotateChannelCredentialsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsIngest", location: .body(locationName: "hlsIngest"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct RotateIngestEndpointCredentialsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "IngestEndpointId", location: .uri(locationName: "ingest_endpoint_id"), required: true, type: .string)
        ]
        public let id: String
        public let ingestEndpointId: String

        public init(id: String, ingestEndpointId: String) {
            self.id = id
            self.ingestEndpointId = ingestEndpointId
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case ingestEndpointId = "ingest_endpoint_id"
        }
    }

    public struct RotateIngestEndpointCredentialsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsIngest", location: .body(locationName: "hlsIngest"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public enum SegmentTemplateFormat: String, CustomStringConvertible, Codable {
        case numberWithTimeline = "NUMBER_WITH_TIMELINE"
        case timeWithTimeline = "TIME_WITH_TIMELINE"
        case numberWithDuration = "NUMBER_WITH_DURATION"
        public var description: String { return self.rawValue }
    }

    public struct SpekeKeyProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", location: .body(locationName: "certificateArn"), required: false, type: .string), 
            AWSShapeMember(label: "ResourceId", location: .body(locationName: "resourceId"), required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", location: .body(locationName: "roleArn"), required: true, type: .string), 
            AWSShapeMember(label: "SystemIds", location: .body(locationName: "systemIds"), required: true, type: .list), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: true, type: .string)
        ]
        /// An Amazon Resource Name (ARN) of a Certificate Manager certificate
        /// that MediaPackage will use for enforcing secure end-to-end data
        /// transfer with the key provider service.
        public let certificateArn: String?
        /// The resource ID to include in key requests.
        public let resourceId: String
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        public let roleArn: String
        /// The system IDs to include in key requests.
        public let systemIds: [String]
        /// The URL of the external key provider service.
        public let url: String

        public init(certificateArn: String? = nil, resourceId: String, roleArn: String, systemIds: [String], url: String) {
            self.certificateArn = certificateArn
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
            case resourceId = "resourceId"
            case roleArn = "roleArn"
            case systemIds = "systemIds"
            case url = "url"
        }
    }

    public enum StreamOrder: String, CustomStringConvertible, Codable {
        case original = "ORIGINAL"
        case videoBitrateAscending = "VIDEO_BITRATE_ASCENDING"
        case videoBitrateDescending = "VIDEO_BITRATE_DESCENDING"
        public var description: String { return self.rawValue }
    }

    public struct StreamSelection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxVideoBitsPerSecond", location: .body(locationName: "maxVideoBitsPerSecond"), required: false, type: .integer), 
            AWSShapeMember(label: "MinVideoBitsPerSecond", location: .body(locationName: "minVideoBitsPerSecond"), required: false, type: .integer), 
            AWSShapeMember(label: "StreamOrder", location: .body(locationName: "streamOrder"), required: false, type: .enum)
        ]
        /// The maximum video bitrate (bps) to include in output.
        public let maxVideoBitsPerSecond: Int32?
        /// The minimum video bitrate (bps) to include in output.
        public let minVideoBitsPerSecond: Int32?
        /// A directive that determines the order of streams in the output.
        public let streamOrder: StreamOrder?

        public init(maxVideoBitsPerSecond: Int32? = nil, minVideoBitsPerSecond: Int32? = nil, streamOrder: StreamOrder? = nil) {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
            case minVideoBitsPerSecond = "minVideoBitsPerSecond"
            case streamOrder = "streamOrder"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: true, type: .map)
        ]
        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tags = "tags"
        }
    }

    public struct TagsModel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: true, type: .map)
        ]
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", location: .uri(locationName: "resource-arn"), required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", location: .querystring(locationName: "tagKeys"), required: true, type: .list)
        ]
        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resource-arn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UpdateChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string)
        ]
        public let description: String?
        public let id: String

        public init(description: String? = nil, id: String) {
            self.description = description
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
        }
    }

    public struct UpdateChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsIngest", location: .body(locationName: "hlsIngest"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map)
        ]
        public let arn: String?
        public let description: String?
        public let hlsIngest: HlsIngest?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, hlsIngest: HlsIngest? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.hlsIngest = hlsIngest
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case hlsIngest = "hlsIngest"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct UpdateOriginEndpointRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .uri(locationName: "id"), required: true, type: .string), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        public let cmafPackage: CmafPackageCreateOrUpdateParameters?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let startoverWindowSeconds: Int32?
        public let timeDelaySeconds: Int32?
        public let whitelist: [String]?

        public init(cmafPackage: CmafPackageCreateOrUpdateParameters? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, timeDelaySeconds: Int32? = nil, whitelist: [String]? = nil) {
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.timeDelaySeconds = timeDelaySeconds
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case timeDelaySeconds = "timeDelaySeconds"
            case whitelist = "whitelist"
        }
    }

    public struct UpdateOriginEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Arn", location: .body(locationName: "arn"), required: false, type: .string), 
            AWSShapeMember(label: "ChannelId", location: .body(locationName: "channelId"), required: false, type: .string), 
            AWSShapeMember(label: "CmafPackage", location: .body(locationName: "cmafPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "DashPackage", location: .body(locationName: "dashPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Description", location: .body(locationName: "description"), required: false, type: .string), 
            AWSShapeMember(label: "HlsPackage", location: .body(locationName: "hlsPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "Id", location: .body(locationName: "id"), required: false, type: .string), 
            AWSShapeMember(label: "ManifestName", location: .body(locationName: "manifestName"), required: false, type: .string), 
            AWSShapeMember(label: "MssPackage", location: .body(locationName: "mssPackage"), required: false, type: .structure), 
            AWSShapeMember(label: "StartoverWindowSeconds", location: .body(locationName: "startoverWindowSeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Tags", location: .body(locationName: "tags"), required: false, type: .map), 
            AWSShapeMember(label: "TimeDelaySeconds", location: .body(locationName: "timeDelaySeconds"), required: false, type: .integer), 
            AWSShapeMember(label: "Url", location: .body(locationName: "url"), required: false, type: .string), 
            AWSShapeMember(label: "Whitelist", location: .body(locationName: "whitelist"), required: false, type: .list)
        ]
        public let arn: String?
        public let channelId: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let description: String?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let manifestName: String?
        public let mssPackage: MssPackage?
        public let startoverWindowSeconds: Int32?
        public let tags: [String: String]?
        public let timeDelaySeconds: Int32?
        public let url: String?
        public let whitelist: [String]?

        public init(arn: String? = nil, channelId: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, description: String? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, manifestName: String? = nil, mssPackage: MssPackage? = nil, startoverWindowSeconds: Int32? = nil, tags: [String: String]? = nil, timeDelaySeconds: Int32? = nil, url: String? = nil, whitelist: [String]? = nil) {
            self.arn = arn
            self.channelId = channelId
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.description = description
            self.hlsPackage = hlsPackage
            self.id = id
            self.manifestName = manifestName
            self.mssPackage = mssPackage
            self.startoverWindowSeconds = startoverWindowSeconds
            self.tags = tags
            self.timeDelaySeconds = timeDelaySeconds
            self.url = url
            self.whitelist = whitelist
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelId = "channelId"
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case description = "description"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case manifestName = "manifestName"
            case mssPackage = "mssPackage"
            case startoverWindowSeconds = "startoverWindowSeconds"
            case tags = "tags"
            case timeDelaySeconds = "timeDelaySeconds"
            case url = "url"
            case whitelist = "whitelist"
        }
    }

    public enum Adtriggerselement: String, CustomStringConvertible, Codable {
        case spliceInsert = "SPLICE_INSERT"
        case `break` = "BREAK"
        case providerAdvertisement = "PROVIDER_ADVERTISEMENT"
        case distributorAdvertisement = "DISTRIBUTOR_ADVERTISEMENT"
        case providerPlacementOpportunity = "PROVIDER_PLACEMENT_OPPORTUNITY"
        case distributorPlacementOpportunity = "DISTRIBUTOR_PLACEMENT_OPPORTUNITY"
        case providerOverlayPlacementOpportunity = "PROVIDER_OVERLAY_PLACEMENT_OPPORTUNITY"
        case distributorOverlayPlacementOpportunity = "DISTRIBUTOR_OVERLAY_PLACEMENT_OPPORTUNITY"
        public var description: String { return self.rawValue }
    }

    public enum Periodtriggerselement: String, CustomStringConvertible, Codable {
        case ads = "ADS"
        public var description: String { return self.rawValue }
    }

}
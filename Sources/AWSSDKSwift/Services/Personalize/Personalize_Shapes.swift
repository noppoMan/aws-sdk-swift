// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Personalize {
    //MARK: Enums

    public enum RecipeProvider: String, CustomStringConvertible, Codable {
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum TrainingMode: String, CustomStringConvertible, Codable {
        case full = "FULL"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct Algorithm: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmArn", required: false, type: .string), 
            AWSShapeMember(label: "algorithmImage", required: false, type: .structure), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "defaultHyperParameterRanges", required: false, type: .structure), 
            AWSShapeMember(label: "defaultHyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "defaultResourceConfig", required: false, type: .map), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "trainingInputMode", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm.
        public let algorithmArn: String?
        /// The URI of the Docker container for the algorithm image.
        public let algorithmImage: AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public let creationDateTime: TimeStamp?
        /// Specifies the default hyperparameters, their ranges, and whether they are tunable. A tunable hyperparameter can have its value determined during hyperparameter optimization (HPO).
        public let defaultHyperParameterRanges: DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public let defaultHyperParameters: [String: String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public let defaultResourceConfig: [String: String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the algorithm.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the role.
        public let roleArn: String?
        /// The training input mode.
        public let trainingInputMode: String?

        public init(algorithmArn: String? = nil, algorithmImage: AlgorithmImage? = nil, creationDateTime: TimeStamp? = nil, defaultHyperParameterRanges: DefaultHyperParameterRanges? = nil, defaultHyperParameters: [String: String]? = nil, defaultResourceConfig: [String: String]? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, roleArn: String? = nil, trainingInputMode: String? = nil) {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
            case algorithmImage = "algorithmImage"
            case creationDateTime = "creationDateTime"
            case defaultHyperParameterRanges = "defaultHyperParameterRanges"
            case defaultHyperParameters = "defaultHyperParameters"
            case defaultResourceConfig = "defaultResourceConfig"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case roleArn = "roleArn"
            case trainingInputMode = "trainingInputMode"
        }
    }

    public struct AlgorithmImage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dockerURI", required: true, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// The URI of the Docker container for the algorithm image.
        public let dockerURI: String
        /// The name of the algorithm image.
        public let name: String?

        public init(dockerURI: String, name: String? = nil) {
            self.dockerURI = dockerURI
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dockerURI = "dockerURI"
            case name = "name"
        }
    }

    public struct AutoMLConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "metricName", required: false, type: .string), 
            AWSShapeMember(label: "recipeList", required: false, type: .list)
        ]

        /// The metric to optimize.
        public let metricName: String?
        /// The list of candidate recipes.
        public let recipeList: [String]?

        public init(metricName: String? = nil, recipeList: [String]? = nil) {
            self.metricName = metricName
            self.recipeList = recipeList
        }

        public func validate(name: String) throws {
            try validate(self.metricName, name:"metricName", parent: name, max: 256)
            try self.recipeList?.forEach {
                try validate($0, name: "recipeList[]", parent: name, max: 256)
                try validate($0, name: "recipeList[]", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            }
            try validate(self.recipeList, name:"recipeList", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "metricName"
            case recipeList = "recipeList"
        }
    }

    public struct AutoMLResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bestRecipeArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the best recipe.
        public let bestRecipeArn: String?

        public init(bestRecipeArn: String? = nil) {
            self.bestRecipeArn = bestRecipeArn
        }

        private enum CodingKeys: String, CodingKey {
            case bestRecipeArn = "bestRecipeArn"
        }
    }

    public struct BatchInferenceJob: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "batchInferenceJobArn", required: false, type: .string), 
            AWSShapeMember(label: "batchInferenceJobConfig", required: false, type: .structure), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "filterArn", required: false, type: .string), 
            AWSShapeMember(label: "jobInput", required: false, type: .structure), 
            AWSShapeMember(label: "jobName", required: false, type: .string), 
            AWSShapeMember(label: "jobOutput", required: false, type: .structure), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "numResults", required: false, type: .integer), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let batchInferenceJobArn: String?
        /// A string to string map of the configuration details of a batch inference job.
        public let batchInferenceJobConfig: BatchInferenceJobConfig?
        /// The time at which the batch inference job was created.
        public let creationDateTime: TimeStamp?
        /// If the batch inference job failed, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the filter used on the batch inference job.
        public let filterArn: String?
        /// The Amazon S3 path that leads to the input data used to generate the batch inference job.
        public let jobInput: BatchInferenceJobInput?
        /// The name of the batch inference job.
        public let jobName: String?
        /// The Amazon S3 bucket that contains the output data generated by the batch inference job.
        public let jobOutput: BatchInferenceJobOutput?
        /// The time at which the batch inference job was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The number of recommendations generated by the batch inference job. This number includes the error messages generated for failed input records.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference job was created.
        public let solutionVersionArn: String?
        /// The status of the batch inference job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED  
        public let status: String?

        public init(batchInferenceJobArn: String? = nil, batchInferenceJobConfig: BatchInferenceJobConfig? = nil, creationDateTime: TimeStamp? = nil, failureReason: String? = nil, filterArn: String? = nil, jobInput: BatchInferenceJobInput? = nil, jobName: String? = nil, jobOutput: BatchInferenceJobOutput? = nil, lastUpdatedDateTime: TimeStamp? = nil, numResults: Int? = nil, roleArn: String? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
            case batchInferenceJobConfig = "batchInferenceJobConfig"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case filterArn = "filterArn"
            case jobInput = "jobInput"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case numResults = "numResults"
            case roleArn = "roleArn"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct BatchInferenceJobConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "itemExplorationConfig", required: false, type: .map)
        ]

        /// A string to string map specifying the inference hyperparameters you wish to use for hyperparameter optimization. See customizing-solution-config-hpo.
        public let itemExplorationConfig: [String: String]?

        public init(itemExplorationConfig: [String: String]? = nil) {
            self.itemExplorationConfig = itemExplorationConfig
        }

        public func validate(name: String) throws {
            try self.itemExplorationConfig?.forEach {
                try validate($0.key, name:"itemExplorationConfig.key", parent: name, max: 256)
                try validate($0.value, name:"itemExplorationConfig[\"\($0.key)\"]", parent: name, max: 1000)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case itemExplorationConfig = "itemExplorationConfig"
        }
    }

    public struct BatchInferenceJobInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3DataSource", required: true, type: .structure)
        ]

        /// The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the same region as the API endpoint you are calling.
        public let s3DataSource: S3DataConfig

        public init(s3DataSource: S3DataConfig) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "s3DataSource"
        }
    }

    public struct BatchInferenceJobOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "s3DataDestination", required: true, type: .structure)
        ]

        /// Information on the Amazon S3 bucket in which the batch inference job's output is stored.
        public let s3DataDestination: S3DataConfig

        public init(s3DataDestination: S3DataConfig) {
            self.s3DataDestination = s3DataDestination
        }

        public func validate(name: String) throws {
            try self.s3DataDestination.validate(name: "\(name).s3DataDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataDestination = "s3DataDestination"
        }
    }

    public struct BatchInferenceJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "batchInferenceJobArn", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "jobName", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let batchInferenceJobArn: String?
        /// The time at which the batch inference job was created.
        public let creationDateTime: TimeStamp?
        /// If the batch inference job failed, the reason for the failure.
        public let failureReason: String?
        /// The name of the batch inference job.
        public let jobName: String?
        /// The time at which the batch inference job was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The ARN of the solution version used by the batch inference job.
        public let solutionVersionArn: String?
        /// The status of the batch inference job. The status is one of the following values:   PENDING   IN PROGRESS   ACTIVE   CREATE FAILED  
        public let status: String?

        public init(batchInferenceJobArn: String? = nil, creationDateTime: TimeStamp? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct Campaign: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string), 
            AWSShapeMember(label: "campaignConfig", required: false, type: .structure), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "latestCampaignUpdate", required: false, type: .structure), 
            AWSShapeMember(label: "minProvisionedTPS", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign. 
        public let campaignArn: String?
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// The date and time (in Unix format) that the campaign was created.
        public let creationDateTime: TimeStamp?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        public let latestCampaignUpdate: CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second.
        public let minProvisionedTPS: Int?
        /// The name of the campaign.
        public let name: String?
        /// The Amazon Resource Name (ARN) of a specific version of the solution.
        public let solutionVersionArn: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(campaignArn: String? = nil, campaignConfig: CampaignConfig? = nil, creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, latestCampaignUpdate: CampaignUpdateSummary? = nil, minProvisionedTPS: Int? = nil, name: String? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case campaignConfig = "campaignConfig"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestCampaignUpdate = "latestCampaignUpdate"
            case minProvisionedTPS = "minProvisionedTPS"
            case name = "name"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct CampaignConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "itemExplorationConfig", required: false, type: .map)
        ]

        /// A string to string map specifying the inference hyperparameters you wish to use for hyperparameter optimization. See customizing-solution-config-hpo.
        public let itemExplorationConfig: [String: String]?

        public init(itemExplorationConfig: [String: String]? = nil) {
            self.itemExplorationConfig = itemExplorationConfig
        }

        public func validate(name: String) throws {
            try self.itemExplorationConfig?.forEach {
                try validate($0.key, name:"itemExplorationConfig.key", parent: name, max: 256)
                try validate($0.value, name:"itemExplorationConfig[\"\($0.key)\"]", parent: name, max: 1000)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case itemExplorationConfig = "itemExplorationConfig"
        }
    }

    public struct CampaignSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?
        /// The date and time (in Unix time) that the campaign was created.
        public let creationDateTime: TimeStamp?
        /// If a campaign fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the campaign.
        public let name: String?
        /// The status of the campaign. A campaign can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(campaignArn: String? = nil, creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct CampaignUpdateSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignConfig", required: false, type: .structure), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "minProvisionedTPS", required: false, type: .integer), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        public let campaignConfig: CampaignConfig?
        /// The date and time (in Unix time) that the campaign update was created.
        public let creationDateTime: TimeStamp?
        /// If a campaign update fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public let solutionVersionArn: String?
        /// The status of the campaign update. A campaign update can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(campaignConfig: CampaignConfig? = nil, creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, minProvisionedTPS: Int? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case campaignConfig = "campaignConfig"
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case minProvisionedTPS = "minProvisionedTPS"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct CategoricalHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "values", required: false, type: .list)
        ]

        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 256)
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 1000)
            }
            try validate(self.values, name:"values", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct ContinuousHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxValue", required: false, type: .double), 
            AWSShapeMember(label: "minValue", required: false, type: .double), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.maxValue, name:"maxValue", parent: name, min: -1000000)
            try validate(self.minValue, name:"minValue", parent: name, min: -1000000)
            try validate(self.name, name:"name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct CreateBatchInferenceJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "batchInferenceJobConfig", required: false, type: .structure), 
            AWSShapeMember(label: "filterArn", required: false, type: .string), 
            AWSShapeMember(label: "jobInput", required: true, type: .structure), 
            AWSShapeMember(label: "jobName", required: true, type: .string), 
            AWSShapeMember(label: "jobOutput", required: true, type: .structure), 
            AWSShapeMember(label: "numResults", required: false, type: .integer), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "solutionVersionArn", required: true, type: .string)
        ]

        /// The configuration details of a batch inference job.
        public let batchInferenceJobConfig: BatchInferenceJobConfig?
        /// The ARN of the filter to apply to the batch inference job. For more information on using filters, see Using Filters with Amazon Personalize.
        public let filterArn: String?
        /// The Amazon S3 path that leads to the input file to base your recommendations on. The input material must be in JSON format.
        public let jobInput: BatchInferenceJobInput
        /// The name of the batch inference job to create.
        public let jobName: String
        /// The path to the Amazon S3 bucket where the job's output will be stored.
        public let jobOutput: BatchInferenceJobOutput
        /// The number of recommendations to retreive.
        public let numResults: Int?
        /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and out Amazon S3 buckets respectively.
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the solution version that will be used to generate the batch inference recommendations.
        public let solutionVersionArn: String

        public init(batchInferenceJobConfig: BatchInferenceJobConfig? = nil, filterArn: String? = nil, jobInput: BatchInferenceJobInput, jobName: String, jobOutput: BatchInferenceJobOutput, numResults: Int? = nil, roleArn: String, solutionVersionArn: String) {
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.batchInferenceJobConfig?.validate(name: "\(name).batchInferenceJobConfig")
            try validate(self.filterArn, name:"filterArn", parent: name, max: 256)
            try validate(self.filterArn, name:"filterArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.jobInput.validate(name: "\(name).jobInput")
            try validate(self.jobName, name:"jobName", parent: name, max: 63)
            try validate(self.jobName, name:"jobName", parent: name, min: 1)
            try validate(self.jobName, name:"jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try self.jobOutput.validate(name: "\(name).jobOutput")
            try validate(self.roleArn, name:"roleArn", parent: name, max: 256)
            try validate(self.roleArn, name:"roleArn", parent: name, pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, max: 256)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobConfig = "batchInferenceJobConfig"
            case filterArn = "filterArn"
            case jobInput = "jobInput"
            case jobName = "jobName"
            case jobOutput = "jobOutput"
            case numResults = "numResults"
            case roleArn = "roleArn"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct CreateBatchInferenceJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "batchInferenceJobArn", required: false, type: .string)
        ]

        /// The ARN of the batch inference job.
        public let batchInferenceJobArn: String?

        public init(batchInferenceJobArn: String? = nil) {
            self.batchInferenceJobArn = batchInferenceJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
        }
    }

    public struct CreateCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignConfig", required: false, type: .structure), 
            AWSShapeMember(label: "minProvisionedTPS", required: true, type: .integer), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "solutionVersionArn", required: true, type: .string)
        ]

        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int
        /// A name for the new campaign. The campaign name must be unique within your account.
        public let name: String
        /// The Amazon Resource Name (ARN) of the solution version to deploy.
        public let solutionVersionArn: String

        public init(campaignConfig: CampaignConfig? = nil, minProvisionedTPS: Int, name: String, solutionVersionArn: String) {
            self.campaignConfig = campaignConfig
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try self.campaignConfig?.validate(name: "\(name).campaignConfig")
            try validate(self.minProvisionedTPS, name:"minProvisionedTPS", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, max: 256)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignConfig = "campaignConfig"
            case minProvisionedTPS = "minProvisionedTPS"
            case name = "name"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct CreateCampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct CreateDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "kmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of a KMS key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The name for the new dataset group.
        public let name: String
        /// The ARN of the IAM role that has permissions to access the KMS key. Supplying an IAM role is only valid when also specifying a KMS key.
        public let roleArn: String?

        public init(kmsKeyArn: String? = nil, name: String, roleArn: String? = nil) {
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(self.roleArn, name:"roleArn", parent: name, max: 256)
            try validate(self.roleArn, name:"roleArn", parent: name, pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case roleArn = "roleArn"
        }
    }

    public struct CreateDatasetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the new dataset group.
        public let datasetGroupArn: String?

        public init(datasetGroupArn: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct CreateDatasetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: true, type: .string), 
            AWSShapeMember(label: "dataSource", required: true, type: .structure), 
            AWSShapeMember(label: "jobName", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string)
        ]

        /// The ARN of the dataset that receives the imported data.
        public let datasetArn: String
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource
        /// The name for the dataset import job.
        public let jobName: String
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String

        public init(datasetArn: String, dataSource: DataSource, jobName: String, roleArn: String) {
            self.datasetArn = datasetArn
            self.dataSource = dataSource
            self.jobName = jobName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetArn, name:"datasetArn", parent: name, max: 256)
            try validate(self.datasetArn, name:"datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.dataSource.validate(name: "\(name).dataSource")
            try validate(self.jobName, name:"jobName", parent: name, max: 63)
            try validate(self.jobName, name:"jobName", parent: name, min: 1)
            try validate(self.jobName, name:"jobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(self.roleArn, name:"roleArn", parent: name, max: 256)
            try validate(self.roleArn, name:"roleArn", parent: name, pattern: "arn:([a-z\\d-]+):iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case dataSource = "dataSource"
            case jobName = "jobName"
            case roleArn = "roleArn"
        }
    }

    public struct CreateDatasetImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJobArn", required: false, type: .string)
        ]

        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?

        public init(datasetImportJobArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "datasetImportJobArn"
        }
    }

    public struct CreateDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "datasetType", required: true, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "schemaArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
        public let datasetGroupArn: String
        /// The type of dataset. One of the following (case insensitive) values:   Interactions   Items   Users  
        public let datasetType: String
        /// The name for the dataset.
        public let name: String
        /// The ARN of the schema to associate with the dataset. The schema defines the dataset fields.
        public let schemaArn: String

        public init(datasetGroupArn: String, datasetType: String, name: String, schemaArn: String) {
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.name = name
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.datasetType, name:"datasetType", parent: name, max: 256)
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(self.schemaArn, name:"schemaArn", parent: name, max: 256)
            try validate(self.schemaArn, name:"schemaArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case datasetType = "datasetType"
            case name = "name"
            case schemaArn = "schemaArn"
        }
    }

    public struct CreateDatasetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: false, type: .string)
        ]

        /// The ARN of the dataset.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct CreateEventTrackerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String
        /// The name for the event tracker.
        public let name: String

        public init(datasetGroupArn: String, name: String) {
            self.datasetGroupArn = datasetGroupArn
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case name = "name"
        }
    }

    public struct CreateEventTrackerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackerArn", required: false, type: .string), 
            AWSShapeMember(label: "trackingId", required: false, type: .string)
        ]

        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(eventTrackerArn: String? = nil, trackingId: String? = nil) {
            self.eventTrackerArn = eventTrackerArn
            self.trackingId = trackingId
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
            case trackingId = "trackingId"
        }
    }

    public struct CreateFilterRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "filterExpression", required: true, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// The ARN of the dataset group that the filter will belong to.
        public let datasetGroupArn: String
        /// The filter expression that designates the interaction types that the filter will filter out. A filter expression must follow the following format:  EXCLUDE itemId WHERE INTERACTIONS.event_type in ("EVENT_TYPE")  Where "EVENT_TYPE" is the type of event to filter out. To filter out all items with any interactions history, set "*" as the EVENT_TYPE. For more information, see Using Filters with Amazon Personalize.
        public let filterExpression: String
        /// The name of the filter to create.
        public let name: String

        public init(datasetGroupArn: String, filterExpression: String, name: String) {
            self.datasetGroupArn = datasetGroupArn
            self.filterExpression = filterExpression
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.filterExpression, name:"filterExpression", parent: name, max: 2500)
            try validate(self.filterExpression, name:"filterExpression", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case filterExpression = "filterExpression"
            case name = "name"
        }
    }

    public struct CreateFilterResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "filterArn", required: false, type: .string)
        ]

        /// The ARN of the new filter.
        public let filterArn: String?

        public init(filterArn: String? = nil) {
            self.filterArn = filterArn
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn = "filterArn"
        }
    }

    public struct CreateSchemaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "schema", required: true, type: .string)
        ]

        /// The name for the schema.
        public let name: String
        /// A schema in Avro JSON format.
        public let schema: String

        public init(name: String, schema: String) {
            self.name = name
            self.schema = schema
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(self.schema, name:"schema", parent: name, max: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case schema = "schema"
        }
    }

    public struct CreateSchemaResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schemaArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the created schema.
        public let schemaArn: String?

        public init(schemaArn: String? = nil) {
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct CreateSolutionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "eventType", required: false, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "performAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "performHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionConfig", required: false, type: .structure)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String
        /// When your have multiple event types (using an EVENT_TYPE schema field), this parameter specifies which event type (for example, 'click' or 'like') is used for training the model.
        public let eventType: String?
        /// The name for the solution.
        public let name: String
        /// Whether to perform automated machine learning (AutoML). The default is false. For this case, you must specify recipeArn. When set to true, Amazon Personalize analyzes your training data and selects the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit recipeArn. Amazon Personalize determines the optimal recipe by running tests with different values for the hyperparameters. AutoML lengthens the training process as compared to selecting a specific recipe.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe. The default is false. When performing AutoML, this parameter is always true and you should not set it to false.
        public let performHPO: Bool?
        /// The ARN of the recipe to use for model training. Only specified when performAutoML is false.
        public let recipeArn: String?
        /// The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration.
        public let solutionConfig: SolutionConfig?

        public init(datasetGroupArn: String, eventType: String? = nil, name: String, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionConfig: SolutionConfig? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionConfig = solutionConfig
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.eventType, name:"eventType", parent: name, max: 256)
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9\\-_]*")
            try validate(self.recipeArn, name:"recipeArn", parent: name, max: 256)
            try validate(self.recipeArn, name:"recipeArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.solutionConfig?.validate(name: "\(name).solutionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case name = "name"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionConfig = "solutionConfig"
        }
    }

    public struct CreateSolutionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: false, type: .string)
        ]

        /// The ARN of the solution.
        public let solutionArn: String?

        public init(solutionArn: String? = nil) {
            self.solutionArn = solutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct CreateSolutionVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: true, type: .string), 
            AWSShapeMember(label: "trainingMode", required: false, type: .enum)
        ]

        /// The Amazon Resource Name (ARN) of the solution containing the training configuration information.
        public let solutionArn: String
        /// The scope of training to be performed when creating the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the data that has changed in comparison to the input solution. Choose UPDATE when you want to incrementally update your solution version instead of creating an entirely new one.  The UPDATE option can only be used when you already have an active solution version created from the input solution using the FULL option and the input solution was trained with the native-recipe-hrnn-coldstart recipe. 
        public let trainingMode: TrainingMode?

        public init(solutionArn: String, trainingMode: TrainingMode? = nil) {
            self.solutionArn = solutionArn
            self.trainingMode = trainingMode
        }

        public func validate(name: String) throws {
            try validate(self.solutionArn, name:"solutionArn", parent: name, max: 256)
            try validate(self.solutionArn, name:"solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
            case trainingMode = "trainingMode"
        }
    }

    public struct CreateSolutionVersionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string)
        ]

        /// The ARN of the new solution version.
        public let solutionVersionArn: String?

        public init(solutionVersionArn: String? = nil) {
            self.solutionVersionArn = solutionVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataLocation", required: false, type: .string)
        ]

        /// The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored. For example:   s3://bucket-name/training-data.csv 
        public let dataLocation: String?

        public init(dataLocation: String? = nil) {
            self.dataLocation = dataLocation
        }

        public func validate(name: String) throws {
            try validate(self.dataLocation, name:"dataLocation", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case dataLocation = "dataLocation"
        }
    }

    public struct Dataset: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetType", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "schemaArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the dataset.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public let datasetArn: String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// One of the following values:   Interactions   Items   Users  
        public let datasetType: String?
        /// A time stamp that shows when the dataset was updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset.
        public let name: String?
        /// The ARN of the associated schema.
        public let schemaArn: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetArn: String? = nil, datasetGroupArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, schemaArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetGroupArn = "datasetGroupArn"
            case datasetType = "datasetType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schemaArn = "schemaArn"
            case status = "status"
        }
    }

    public struct DatasetGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "kmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the dataset group.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// If creating a dataset group fails, provides the reason why.
        public let failureReason: String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the datasets.
        public let kmsKeyArn: String?
        /// The last update date and time (in Unix time) of the dataset group.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset group.
        public let name: String?
        /// The ARN of the IAM role that has permissions to create the dataset group.
        public let roleArn: String?
        /// The current status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, kmsKeyArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case kmsKeyArn = "kmsKeyArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DatasetGroupSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the dataset group was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// If creating a dataset group fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset group.
        public let name: String?
        /// The status of the dataset group. A dataset group can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct DatasetImportJob: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetImportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "dataSource", required: false, type: .structure), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "jobName", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the dataset import job.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public let datasetArn: String?
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?
        /// The Amazon S3 bucket that contains the training data to import.
        public let dataSource: DataSource?
        /// If a dataset import job fails, provides the reason why.
        public let failureReason: String?
        /// The name of the import job.
        public let jobName: String?
        /// The date and time (in Unix time) the dataset was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The ARN of the AWS Identity and Access Management (IAM) role that has permissions to read from the Amazon S3 data source.
        public let roleArn: String?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetArn: String? = nil, datasetImportJobArn: String? = nil, dataSource: DataSource? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, roleArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.dataSource = dataSource
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetImportJobArn = "datasetImportJobArn"
            case dataSource = "dataSource"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct DatasetImportJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetImportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "jobName", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the dataset import job was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?
        /// If a dataset import job fails, the reason behind the failure.
        public let failureReason: String?
        /// The name of the dataset import job.
        public let jobName: String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The status of the dataset import job. A dataset import job can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetImportJobArn: String? = nil, failureReason: String? = nil, jobName: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetImportJobArn = "datasetImportJobArn"
            case failureReason = "failureReason"
            case jobName = "jobName"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case status = "status"
        }
    }

    public struct DatasetSchema: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "schema", required: false, type: .string), 
            AWSShapeMember(label: "schemaArn", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the schema.
        public let name: String?
        /// The schema.
        public let schema: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, schema: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schema = "schema"
            case schemaArn = "schemaArn"
        }
    }

    public struct DatasetSchemaSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "schemaArn", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the schema was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the schema was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the schema.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the schema.
        public let schemaArn: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, schemaArn: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case schemaArn = "schemaArn"
        }
    }

    public struct DatasetSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "datasetType", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the dataset was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The dataset type. One of the following values:   Interactions   Items   Users   Event-Interactions  
        public let datasetType: String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the dataset.
        public let name: String?
        /// The status of the dataset. A dataset can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetArn: String? = nil, datasetType: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetArn = "datasetArn"
            case datasetType = "datasetType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct DefaultCategoricalHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isTunable", required: false, type: .boolean), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "values", required: false, type: .list)
        ]

        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The name of the hyperparameter.
        public let name: String?
        /// A list of the categories for the hyperparameter.
        public let values: [String]?

        public init(isTunable: Bool? = nil, name: String? = nil, values: [String]? = nil) {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case name = "name"
            case values = "values"
        }
    }

    public struct DefaultContinuousHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isTunable", required: false, type: .boolean), 
            AWSShapeMember(label: "maxValue", required: false, type: .double), 
            AWSShapeMember(label: "minValue", required: false, type: .double), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// Whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Double?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Double?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Double? = nil, minValue: Double? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct DefaultHyperParameterRanges: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "categoricalHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "continuousHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "integerHyperParameterRanges", required: false, type: .list)
        ]

        /// The categorical hyperparameters and their default ranges.
        public let categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public let continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public let integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [DefaultCategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [DefaultContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [DefaultIntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges = "categoricalHyperParameterRanges"
            case continuousHyperParameterRanges = "continuousHyperParameterRanges"
            case integerHyperParameterRanges = "integerHyperParameterRanges"
        }
    }

    public struct DefaultIntegerHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isTunable", required: false, type: .boolean), 
            AWSShapeMember(label: "maxValue", required: false, type: .integer), 
            AWSShapeMember(label: "minValue", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// Indicates whether the hyperparameter is tunable.
        public let isTunable: Bool?
        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int?
        /// The name of the hyperparameter.
        public let name: String?

        public init(isTunable: Bool? = nil, maxValue: Int? = nil, minValue: Int? = nil, name: String? = nil) {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case isTunable = "isTunable"
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct DeleteCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign to delete.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate(name: String) throws {
            try validate(self.campaignArn, name:"campaignArn", parent: name, max: 256)
            try validate(self.campaignArn, name:"campaignArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct DeleteDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string)
        ]

        /// The ARN of the dataset group to delete.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct DeleteDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset to delete.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetArn, name:"datasetArn", parent: name, max: 256)
            try validate(self.datasetArn, name:"datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct DeleteEventTrackerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackerArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the event tracker to delete.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate(name: String) throws {
            try validate(self.eventTrackerArn, name:"eventTrackerArn", parent: name, max: 256)
            try validate(self.eventTrackerArn, name:"eventTrackerArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
        }
    }

    public struct DeleteFilterRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "filterArn", required: true, type: .string)
        ]

        /// The ARN of the filter to delete.
        public let filterArn: String

        public init(filterArn: String) {
            self.filterArn = filterArn
        }

        public func validate(name: String) throws {
            try validate(self.filterArn, name:"filterArn", parent: name, max: 256)
            try validate(self.filterArn, name:"filterArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn = "filterArn"
        }
    }

    public struct DeleteSchemaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schemaArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the schema to delete.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try validate(self.schemaArn, name:"schemaArn", parent: name, max: 256)
            try validate(self.schemaArn, name:"schemaArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct DeleteSolutionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: true, type: .string)
        ]

        /// The ARN of the solution to delete.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try validate(self.solutionArn, name:"solutionArn", parent: name, max: 256)
            try validate(self.solutionArn, name:"solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct DescribeAlgorithmRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm to describe.
        public let algorithmArn: String

        public init(algorithmArn: String) {
            self.algorithmArn = algorithmArn
        }

        public func validate(name: String) throws {
            try validate(self.algorithmArn, name:"algorithmArn", parent: name, max: 256)
            try validate(self.algorithmArn, name:"algorithmArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
        }
    }

    public struct DescribeAlgorithmResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithm", required: false, type: .structure)
        ]

        /// A listing of the properties of the algorithm.
        public let algorithm: Algorithm?

        public init(algorithm: Algorithm? = nil) {
            self.algorithm = algorithm
        }

        private enum CodingKeys: String, CodingKey {
            case algorithm = "algorithm"
        }
    }

    public struct DescribeBatchInferenceJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "batchInferenceJobArn", required: true, type: .string)
        ]

        /// The ARN of the batch inference job to describe.
        public let batchInferenceJobArn: String

        public init(batchInferenceJobArn: String) {
            self.batchInferenceJobArn = batchInferenceJobArn
        }

        public func validate(name: String) throws {
            try validate(self.batchInferenceJobArn, name:"batchInferenceJobArn", parent: name, max: 256)
            try validate(self.batchInferenceJobArn, name:"batchInferenceJobArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobArn = "batchInferenceJobArn"
        }
    }

    public struct DescribeBatchInferenceJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "batchInferenceJob", required: false, type: .structure)
        ]

        /// Information on the specified batch inference job.
        public let batchInferenceJob: BatchInferenceJob?

        public init(batchInferenceJob: BatchInferenceJob? = nil) {
            self.batchInferenceJob = batchInferenceJob
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJob = "batchInferenceJob"
        }
    }

    public struct DescribeCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String

        public init(campaignArn: String) {
            self.campaignArn = campaignArn
        }

        public func validate(name: String) throws {
            try validate(self.campaignArn, name:"campaignArn", parent: name, max: 256)
            try validate(self.campaignArn, name:"campaignArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }

    public struct DescribeCampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaign", required: false, type: .structure)
        ]

        /// The properties of the campaign.
        public let campaign: Campaign?

        public init(campaign: Campaign? = nil) {
            self.campaign = campaign
        }

        private enum CodingKeys: String, CodingKey {
            case campaign = "campaign"
        }
    }

    public struct DescribeDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group to describe.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
        }
    }

    public struct DescribeDatasetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroup", required: false, type: .structure)
        ]

        /// A listing of the dataset group's properties.
        public let datasetGroup: DatasetGroup?

        public init(datasetGroup: DatasetGroup? = nil) {
            self.datasetGroup = datasetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroup = "datasetGroup"
        }
    }

    public struct DescribeDatasetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJobArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset import job to describe.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetImportJobArn, name:"datasetImportJobArn", parent: name, max: 256)
            try validate(self.datasetImportJobArn, name:"datasetImportJobArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "datasetImportJobArn"
        }
    }

    public struct DescribeDatasetImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJob", required: false, type: .structure)
        ]

        /// Information about the dataset import job, including the status. The status is one of the following values:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED  
        public let datasetImportJob: DatasetImportJob?

        public init(datasetImportJob: DatasetImportJob? = nil) {
            self.datasetImportJob = datasetImportJob
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJob = "datasetImportJob"
        }
    }

    public struct DescribeDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset to describe.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetArn, name:"datasetArn", parent: name, max: 256)
            try validate(self.datasetArn, name:"datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
        }
    }

    public struct DescribeDatasetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataset", required: false, type: .structure)
        ]

        /// A listing of the dataset's properties.
        public let dataset: Dataset?

        public init(dataset: Dataset? = nil) {
            self.dataset = dataset
        }

        private enum CodingKeys: String, CodingKey {
            case dataset = "dataset"
        }
    }

    public struct DescribeEventTrackerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackerArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the event tracker to describe.
        public let eventTrackerArn: String

        public init(eventTrackerArn: String) {
            self.eventTrackerArn = eventTrackerArn
        }

        public func validate(name: String) throws {
            try validate(self.eventTrackerArn, name:"eventTrackerArn", parent: name, max: 256)
            try validate(self.eventTrackerArn, name:"eventTrackerArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackerArn = "eventTrackerArn"
        }
    }

    public struct DescribeEventTrackerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTracker", required: false, type: .structure)
        ]

        /// An object that describes the event tracker.
        public let eventTracker: EventTracker?

        public init(eventTracker: EventTracker? = nil) {
            self.eventTracker = eventTracker
        }

        private enum CodingKeys: String, CodingKey {
            case eventTracker = "eventTracker"
        }
    }

    public struct DescribeFeatureTransformationRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "featureTransformationArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the feature transformation to describe.
        public let featureTransformationArn: String

        public init(featureTransformationArn: String) {
            self.featureTransformationArn = featureTransformationArn
        }

        public func validate(name: String) throws {
            try validate(self.featureTransformationArn, name:"featureTransformationArn", parent: name, max: 256)
            try validate(self.featureTransformationArn, name:"featureTransformationArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformationArn = "featureTransformationArn"
        }
    }

    public struct DescribeFeatureTransformationResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "featureTransformation", required: false, type: .structure)
        ]

        /// A listing of the FeatureTransformation properties.
        public let featureTransformation: FeatureTransformation?

        public init(featureTransformation: FeatureTransformation? = nil) {
            self.featureTransformation = featureTransformation
        }

        private enum CodingKeys: String, CodingKey {
            case featureTransformation = "featureTransformation"
        }
    }

    public struct DescribeFilterRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "filterArn", required: true, type: .string)
        ]

        /// The ARN of the filter to describe.
        public let filterArn: String

        public init(filterArn: String) {
            self.filterArn = filterArn
        }

        public func validate(name: String) throws {
            try validate(self.filterArn, name:"filterArn", parent: name, max: 256)
            try validate(self.filterArn, name:"filterArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case filterArn = "filterArn"
        }
    }

    public struct DescribeFilterResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "filter", required: false, type: .structure)
        ]

        /// The filter's details.
        public let filter: Filter?

        public init(filter: Filter? = nil) {
            self.filter = filter
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
        }
    }

    public struct DescribeRecipeRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "recipeArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the recipe to describe.
        public let recipeArn: String

        public init(recipeArn: String) {
            self.recipeArn = recipeArn
        }

        public func validate(name: String) throws {
            try validate(self.recipeArn, name:"recipeArn", parent: name, max: 256)
            try validate(self.recipeArn, name:"recipeArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case recipeArn = "recipeArn"
        }
    }

    public struct DescribeRecipeResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "recipe", required: false, type: .structure)
        ]

        /// An object that describes the recipe.
        public let recipe: Recipe?

        public init(recipe: Recipe? = nil) {
            self.recipe = recipe
        }

        private enum CodingKeys: String, CodingKey {
            case recipe = "recipe"
        }
    }

    public struct DescribeSchemaRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schemaArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the schema to retrieve.
        public let schemaArn: String

        public init(schemaArn: String) {
            self.schemaArn = schemaArn
        }

        public func validate(name: String) throws {
            try validate(self.schemaArn, name:"schemaArn", parent: name, max: 256)
            try validate(self.schemaArn, name:"schemaArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case schemaArn = "schemaArn"
        }
    }

    public struct DescribeSchemaResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "schema", required: false, type: .structure)
        ]

        /// The requested schema.
        public let schema: DatasetSchema?

        public init(schema: DatasetSchema? = nil) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct DescribeSolutionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the solution to describe.
        public let solutionArn: String

        public init(solutionArn: String) {
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try validate(self.solutionArn, name:"solutionArn", parent: name, max: 256)
            try validate(self.solutionArn, name:"solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionArn = "solutionArn"
        }
    }

    public struct DescribeSolutionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solution", required: false, type: .structure)
        ]

        /// An object that describes the solution.
        public let solution: Solution?

        public init(solution: Solution? = nil) {
            self.solution = solution
        }

        private enum CodingKeys: String, CodingKey {
            case solution = "solution"
        }
    }

    public struct DescribeSolutionVersionRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, max: 256)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct DescribeSolutionVersionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersion", required: false, type: .structure)
        ]

        /// The solution version.
        public let solutionVersion: SolutionVersion?

        public init(solutionVersion: SolutionVersion? = nil) {
            self.solutionVersion = solutionVersion
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersion = "solutionVersion"
        }
    }

    public struct EventTracker: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accountId", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "eventTrackerArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string), 
            AWSShapeMember(label: "trackingId", required: false, type: .string)
        ]

        /// The Amazon AWS account that owns the event tracker.
        public let accountId: String?
        /// The date and time (in Unix format) that the event tracker was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public let datasetGroupArn: String?
        /// The ARN of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?
        /// The ID of the event tracker. Include this ID in requests to the PutEvents API.
        public let trackingId: String?

        public init(accountId: String? = nil, creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil, trackingId: String? = nil) {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventTrackerArn = "eventTrackerArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
            case trackingId = "trackingId"
        }
    }

    public struct EventTrackerSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "eventTrackerArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the event tracker was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public let eventTrackerArn: String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the event tracker.
        public let name: String?
        /// The status of the event tracker. An event tracker can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, eventTrackerArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case eventTrackerArn = "eventTrackerArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct FeatureTransformation: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "defaultParameters", required: false, type: .map), 
            AWSShapeMember(label: "featureTransformationArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The creation date and time (in Unix time) of the feature transformation.
        public let creationDateTime: TimeStamp?
        /// Provides the default parameters for feature transformation.
        public let defaultParameters: [String: String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the feature transformation.
        public let name: String?
        /// The status of the feature transformation. A feature transformation can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, defaultParameters: [String: String]? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case defaultParameters = "defaultParameters"
            case featureTransformationArn = "featureTransformationArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct Filter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "filterArn", required: false, type: .string), 
            AWSShapeMember(label: "filterExpression", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The time at which the filter was created.
        public let creationDateTime: TimeStamp?
        /// The ARN of the dataset group to which the filter belongs.
        public let datasetGroupArn: String?
        /// If the filter failed, the reason for its failure.
        public let failureReason: String?
        /// The ARN of the filter.
        public let filterArn: String?
        /// Specifies the type of item interactions to filter out of recommendation results. The filter expression must follow the following format:  EXCLUDE itemId WHERE INTERACTIONS.event_type in ("EVENT_TYPE")  Where "EVENT_TYPE" is the type of event to filter out. For more information, see Using Filters with Amazon Personalize.
        public let filterExpression: String?
        /// The time at which the filter was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the filter.
        public let name: String?
        /// The status of the filter.
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, filterArn: String? = nil, filterExpression: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.filterExpression = filterExpression
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case filterArn = "filterArn"
            case filterExpression = "filterExpression"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct FilterSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "filterArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The time at which the filter was created.
        public let creationDateTime: TimeStamp?
        /// The ARN of the dataset group to which the filter belongs.
        public let datasetGroupArn: String?
        /// If the filter failed, the reason for the failure.
        public let failureReason: String?
        /// The ARN of the filter.
        public let filterArn: String?
        /// The time at which the filter was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the filter.
        public let name: String?
        /// The status of the filter.
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, failureReason: String? = nil, filterArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case failureReason = "failureReason"
            case filterArn = "filterArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetSolutionMetricsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "solutionVersionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
        public let solutionVersionArn: String

        public init(solutionVersionArn: String) {
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, max: 256)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct GetSolutionMetricsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "metrics", required: false, type: .map), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string)
        ]

        /// The metrics for the solution version.
        public let metrics: [String: Double]?
        /// The same solution version ARN as specified in the request.
        public let solutionVersionArn: String?

        public init(metrics: [String: Double]? = nil, solutionVersionArn: String? = nil) {
            self.metrics = metrics
            self.solutionVersionArn = solutionVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case metrics = "metrics"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct HPOConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmHyperParameterRanges", required: false, type: .structure), 
            AWSShapeMember(label: "hpoObjective", required: false, type: .structure), 
            AWSShapeMember(label: "hpoResourceConfig", required: false, type: .structure)
        ]

        /// The hyperparameters and their allowable ranges.
        public let algorithmHyperParameterRanges: HyperParameterRanges?
        /// The metric to optimize during HPO.
        public let hpoObjective: HPOObjective?
        /// Describes the resource configuration for HPO.
        public let hpoResourceConfig: HPOResourceConfig?

        public init(algorithmHyperParameterRanges: HyperParameterRanges? = nil, hpoObjective: HPOObjective? = nil, hpoResourceConfig: HPOResourceConfig? = nil) {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }

        public func validate(name: String) throws {
            try self.algorithmHyperParameterRanges?.validate(name: "\(name).algorithmHyperParameterRanges")
            try self.hpoObjective?.validate(name: "\(name).hpoObjective")
            try self.hpoResourceConfig?.validate(name: "\(name).hpoResourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameterRanges = "algorithmHyperParameterRanges"
            case hpoObjective = "hpoObjective"
            case hpoResourceConfig = "hpoResourceConfig"
        }
    }

    public struct HPOObjective: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "metricName", required: false, type: .string), 
            AWSShapeMember(label: "metricRegex", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .string)
        ]

        /// The name of the metric.
        public let metricName: String?
        /// A regular expression for finding the metric in the training job logs.
        public let metricRegex: String?
        /// The type of the metric. Valid values are Maximize and Minimize.
        public let `type`: String?

        public init(metricName: String? = nil, metricRegex: String? = nil, type: String? = nil) {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.metricName, name:"metricName", parent: name, max: 256)
            try validate(self.metricRegex, name:"metricRegex", parent: name, max: 256)
            try validate(self.`type`, name:"`type`", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "metricName"
            case metricRegex = "metricRegex"
            case `type` = "type"
        }
    }

    public struct HPOResourceConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxNumberOfTrainingJobs", required: false, type: .string), 
            AWSShapeMember(label: "maxParallelTrainingJobs", required: false, type: .string)
        ]

        /// The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
        public let maxNumberOfTrainingJobs: String?
        /// The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
        public let maxParallelTrainingJobs: String?

        public init(maxNumberOfTrainingJobs: String? = nil, maxParallelTrainingJobs: String? = nil) {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }

        public func validate(name: String) throws {
            try validate(self.maxNumberOfTrainingJobs, name:"maxNumberOfTrainingJobs", parent: name, max: 256)
            try validate(self.maxParallelTrainingJobs, name:"maxParallelTrainingJobs", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxNumberOfTrainingJobs = "maxNumberOfTrainingJobs"
            case maxParallelTrainingJobs = "maxParallelTrainingJobs"
        }
    }

    public struct HyperParameterRanges: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "categoricalHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "continuousHyperParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "integerHyperParameterRanges", required: false, type: .list)
        ]

        /// The categorical hyperparameters and their ranges.
        public let categoricalHyperParameterRanges: [CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public let continuousHyperParameterRanges: [ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public let integerHyperParameterRanges: [IntegerHyperParameterRange]?

        public init(categoricalHyperParameterRanges: [CategoricalHyperParameterRange]? = nil, continuousHyperParameterRanges: [ContinuousHyperParameterRange]? = nil, integerHyperParameterRanges: [IntegerHyperParameterRange]? = nil) {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalHyperParameterRanges[]")
            }
            try validate(self.categoricalHyperParameterRanges, name:"categoricalHyperParameterRanges", parent: name, max: 100)
            try self.continuousHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).continuousHyperParameterRanges[]")
            }
            try validate(self.continuousHyperParameterRanges, name:"continuousHyperParameterRanges", parent: name, max: 100)
            try self.integerHyperParameterRanges?.forEach {
                try $0.validate(name: "\(name).integerHyperParameterRanges[]")
            }
            try validate(self.integerHyperParameterRanges, name:"integerHyperParameterRanges", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalHyperParameterRanges = "categoricalHyperParameterRanges"
            case continuousHyperParameterRanges = "continuousHyperParameterRanges"
            case integerHyperParameterRanges = "integerHyperParameterRanges"
        }
    }

    public struct IntegerHyperParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxValue", required: false, type: .integer), 
            AWSShapeMember(label: "minValue", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// The maximum allowable value for the hyperparameter.
        public let maxValue: Int?
        /// The minimum allowable value for the hyperparameter.
        public let minValue: Int?
        /// The name of the hyperparameter.
        public let name: String?

        public init(maxValue: Int? = nil, minValue: Int? = nil, name: String? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.maxValue, name:"maxValue", parent: name, max: 1000000)
            try validate(self.minValue, name:"minValue", parent: name, min: -1000000)
            try validate(self.name, name:"name", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "maxValue"
            case minValue = "minValue"
            case name = "name"
        }
    }

    public struct ListBatchInferenceJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string)
        ]

        /// The maximum number of batch inference job results to return in each page. The default value is 100.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs were created.
        public let solutionVersionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionVersionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, max: 256)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct ListBatchInferenceJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "batchInferenceJobs", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// A list containing information on each job that is returned.
        public let batchInferenceJobs: [BatchInferenceJobSummary]?
        /// The token to use to retreive the next page of results. The value is null when there are no more results to return.
        public let nextToken: String?

        public init(batchInferenceJobs: [BatchInferenceJobSummary]? = nil, nextToken: String? = nil) {
            self.batchInferenceJobs = batchInferenceJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case batchInferenceJobs = "batchInferenceJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListCampaignsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string)
        ]

        /// The maximum number of campaigns to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListCampaigns for getting the next set of campaigns (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When a solution is not specified, all the campaigns associated with the account are listed.
        public let solutionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
            try validate(self.solutionArn, name:"solutionArn", parent: name, max: 256)
            try validate(self.solutionArn, name:"solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionArn = "solutionArn"
        }
    }

    public struct ListCampaignsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaigns", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// A list of the campaigns.
        public let campaigns: [CampaignSummary]?
        /// A token for getting the next set of campaigns (if they exist).
        public let nextToken: String?

        public init(campaigns: [CampaignSummary]? = nil, nextToken: String? = nil) {
            self.campaigns = campaigns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaigns = "campaigns"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The maximum number of dataset groups to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetGroups for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetGroupsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroups", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of your dataset groups.
        public let datasetGroups: [DatasetGroupSummary]?
        /// A token for getting the next set of dataset groups (if they exist).
        public let nextToken: String?

        public init(datasetGroups: [DatasetGroupSummary]? = nil, nextToken: String? = nil) {
            self.datasetGroups = datasetGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroups = "datasetGroups"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
        public let datasetArn: String?
        /// The maximum number of dataset import jobs to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetArn = datasetArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.datasetArn, name:"datasetArn", parent: name, max: 256)
            try validate(self.datasetArn, name:"datasetArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "datasetArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetImportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetImportJobs", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of dataset import jobs.
        public let datasetImportJobs: [DatasetImportJobSummary]?
        /// A token for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetImportJobs: [DatasetImportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetImportJobs = datasetImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobs = "datasetImportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to list.
        public let datasetGroupArn: String?
        /// The maximum number of datasets to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListDatasetImportJobs for getting the next set of dataset import jobs (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDatasetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasets", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// An array of Dataset objects. Each object provides metadata information.
        public let datasets: [DatasetSummary]?
        /// A token for getting the next set of datasets (if they exist).
        public let nextToken: String?

        public init(datasets: [DatasetSummary]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "datasets"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventTrackersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The ARN of a dataset group used to filter the response.
        public let datasetGroupArn: String?
        /// The maximum number of event trackers to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListEventTrackers for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventTrackersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "eventTrackers", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// A list of event trackers.
        public let eventTrackers: [EventTrackerSummary]?
        /// A token for getting the next set of event trackers (if they exist).
        public let nextToken: String?

        public init(eventTrackers: [EventTrackerSummary]? = nil, nextToken: String? = nil) {
            self.eventTrackers = eventTrackers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventTrackers = "eventTrackers"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The ARN of the dataset group that contains the filters.
        public let datasetGroupArn: String?
        /// The maximum number of filters to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListFilters for getting the next set of filters (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFiltersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// A list of returned filters.
        public let filters: [FilterSummary]?
        /// A token for getting the next set of filters (if they exist).
        public let nextToken: String?

        public init(filters: [FilterSummary]? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecipesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "recipeProvider", required: false, type: .enum)
        ]

        /// The maximum number of recipes to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListRecipes for getting the next set of recipes (if they exist).
        public let nextToken: String?
        /// The default is SERVICE.
        public let recipeProvider: RecipeProvider?

        public init(maxResults: Int? = nil, nextToken: String? = nil, recipeProvider: RecipeProvider? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.recipeProvider = recipeProvider
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case recipeProvider = "recipeProvider"
        }
    }

    public struct ListRecipesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "recipes", required: false, type: .list)
        ]

        /// A token for getting the next set of recipes.
        public let nextToken: String?
        /// The list of available recipes.
        public let recipes: [RecipeSummary]?

        public init(nextToken: String? = nil, recipes: [RecipeSummary]? = nil) {
            self.nextToken = nextToken
            self.recipes = recipes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recipes = "recipes"
        }
    }

    public struct ListSchemasRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The maximum number of schemas to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSchemas for getting the next set of schemas (if they exist).
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSchemasResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "schemas", required: false, type: .list)
        ]

        /// A token used to get the next set of schemas (if they exist).
        public let nextToken: String?
        /// A list of schemas.
        public let schemas: [DatasetSchemaSummary]?

        public init(nextToken: String? = nil, schemas: [DatasetSchemaSummary]? = nil) {
            self.nextToken = nextToken
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemas = "schemas"
        }
    }

    public struct ListSolutionVersionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string)
        ]

        /// The maximum number of solution versions to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSolutionVersions for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, solutionArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.solutionArn = solutionArn
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
            try validate(self.solutionArn, name:"solutionArn", parent: name, max: 256)
            try validate(self.solutionArn, name:"solutionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case solutionArn = "solutionArn"
        }
    }

    public struct ListSolutionVersionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutionVersions", required: false, type: .list)
        ]

        /// A token for getting the next set of solution versions (if they exist).
        public let nextToken: String?
        /// A list of solution versions describing the version properties.
        public let solutionVersions: [SolutionVersionSummary]?

        public init(nextToken: String? = nil, solutionVersions: [SolutionVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutionVersions = solutionVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case solutionVersions = "solutionVersions"
        }
    }

    public struct ListSolutionsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The maximum number of solutions to return.
        public let maxResults: Int?
        /// A token returned from the previous call to ListSolutions for getting the next set of solutions (if they exist).
        public let nextToken: String?

        public init(datasetGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1300)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "datasetGroupArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSolutionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "solutions", required: false, type: .list)
        ]

        /// A token for getting the next set of solutions (if they exist).
        public let nextToken: String?
        /// A list of the current solutions.
        public let solutions: [SolutionSummary]?

        public init(nextToken: String? = nil, solutions: [SolutionSummary]? = nil) {
            self.nextToken = nextToken
            self.solutions = solutions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case solutions = "solutions"
        }
    }

    public struct Recipe: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmArn", required: false, type: .string), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "featureTransformationArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "recipeType", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train the model.
        public let algorithmArn: String?
        /// The date and time (in Unix format) that the recipe was created.
        public let creationDateTime: TimeStamp?
        /// The description of the recipe.
        public let description: String?
        /// The ARN of the FeatureTransformation object.
        public let featureTransformationArn: String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// One of the following values:   PERSONALIZED_RANKING   RELATED_ITEMS   USER_PERSONALIZATION  
        public let recipeType: String?
        /// The status of the recipe.
        public let status: String?

        public init(algorithmArn: String? = nil, creationDateTime: TimeStamp? = nil, description: String? = nil, featureTransformationArn: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, recipeArn: String? = nil, recipeType: String? = nil, status: String? = nil) {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "algorithmArn"
            case creationDateTime = "creationDateTime"
            case description = "description"
            case featureTransformationArn = "featureTransformationArn"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case recipeType = "recipeType"
            case status = "status"
        }
    }

    public struct RecipeSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the recipe was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the recipe was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the recipe.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public let recipeArn: String?
        /// The status of the recipe.
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, recipeArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case recipeArn = "recipeArn"
            case status = "status"
        }
    }

    public struct S3DataConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "kmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "path", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the Amazon Key Management Service (KMS) key that Amazon Personalize uses to encrypt or decrypt the input and output files of a batch inference job.
        public let kmsKeyArn: String?
        /// The file path of the Amazon S3 bucket.
        public let path: String

        public init(kmsKeyArn: String? = nil, path: String) {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
        }

        public func validate(name: String) throws {
            try validate(self.path, name:"path", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "kmsKeyArn"
            case path = "path"
        }
    }

    public struct Solution: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "autoMLResult", required: false, type: .structure), 
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "eventType", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "latestSolutionVersion", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "performAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "performHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// When performAutoML is true, specifies the best recipe found.
        public let autoMLResult: AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public let eventType: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// Describes the latest version of the solution, including the status and the ARN.
        public let latestSolutionVersion: SolutionVersionSummary?
        /// The name of the solution.
        public let name: String?
        /// When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from the list specified in the solution configuration (recipeArn must not be specified). When false (the default), Amazon Personalize uses recipeArn for training.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used to create the solution.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(autoMLResult: AutoMLResult? = nil, creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, latestSolutionVersion: SolutionVersionSummary? = nil, name: String? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, status: String? = nil) {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLResult = "autoMLResult"
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case latestSolutionVersion = "latestSolutionVersion"
            case name = "name"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionArn = "solutionArn"
            case solutionConfig = "solutionConfig"
            case status = "status"
        }
    }

    public struct SolutionConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmHyperParameters", required: false, type: .map), 
            AWSShapeMember(label: "autoMLConfig", required: false, type: .structure), 
            AWSShapeMember(label: "eventValueThreshold", required: false, type: .string), 
            AWSShapeMember(label: "featureTransformationParameters", required: false, type: .map), 
            AWSShapeMember(label: "hpoConfig", required: false, type: .structure)
        ]

        /// Lists the hyperparameter names and ranges.
        public let algorithmHyperParameters: [String: String]?
        /// The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
        public let autoMLConfig: AutoMLConfig?
        /// Only events with a value greater than or equal to this threshold are used for training a model.
        public let eventValueThreshold: String?
        /// Lists the feature transformation parameters.
        public let featureTransformationParameters: [String: String]?
        /// Describes the properties for hyperparameter optimization (HPO).
        public let hpoConfig: HPOConfig?

        public init(algorithmHyperParameters: [String: String]? = nil, autoMLConfig: AutoMLConfig? = nil, eventValueThreshold: String? = nil, featureTransformationParameters: [String: String]? = nil, hpoConfig: HPOConfig? = nil) {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
        }

        public func validate(name: String) throws {
            try self.algorithmHyperParameters?.forEach {
                try validate($0.key, name:"algorithmHyperParameters.key", parent: name, max: 256)
                try validate($0.value, name:"algorithmHyperParameters[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.autoMLConfig?.validate(name: "\(name).autoMLConfig")
            try validate(self.eventValueThreshold, name:"eventValueThreshold", parent: name, max: 256)
            try self.featureTransformationParameters?.forEach {
                try validate($0.key, name:"featureTransformationParameters.key", parent: name, max: 256)
                try validate($0.value, name:"featureTransformationParameters[\"\($0.key)\"]", parent: name, max: 1000)
            }
            try self.hpoConfig?.validate(name: "\(name).hpoConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameters = "algorithmHyperParameters"
            case autoMLConfig = "autoMLConfig"
            case eventValueThreshold = "eventValueThreshold"
            case featureTransformationParameters = "featureTransformationParameters"
            case hpoConfig = "hpoConfig"
        }
    }

    public struct SolutionSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that the solution was created.
        public let creationDateTime: TimeStamp?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The name of the solution.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the solution.
        public let solutionArn: String?
        /// The status of the solution. A solution can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED   DELETE PENDING &gt; DELETE IN_PROGRESS  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, lastUpdatedDateTime: TimeStamp? = nil, name: String? = nil, solutionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.solutionArn = solutionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case name = "name"
            case solutionArn = "solutionArn"
            case status = "status"
        }
    }

    public struct SolutionVersion: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "datasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "eventType", required: false, type: .string), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "performAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "performHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "recipeArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionArn", required: false, type: .string), 
            AWSShapeMember(label: "solutionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string), 
            AWSShapeMember(label: "trainingHours", required: false, type: .double), 
            AWSShapeMember(label: "trainingMode", required: false, type: .enum), 
            AWSShapeMember(label: "tunedHPOParams", required: false, type: .structure)
        ]

        /// The date and time (in Unix time) that this version of the solution was created.
        public let creationDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public let datasetGroupArn: String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        public let eventType: String?
        /// If training a solution version fails, the reason for the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// When true, Amazon Personalize searches for the most optimal recipe according to the solution configuration. When false (the default), Amazon Personalize uses recipeArn.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is false.
        public let performHPO: Bool?
        /// The ARN of the recipe used in the solution.
        public let recipeArn: String?
        /// The ARN of the solution.
        public let solutionArn: String?
        /// Describes the configuration properties for the solution.
        public let solutionConfig: SolutionConfig?
        /// The ARN of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING   CREATE IN_PROGRESS   ACTIVE   CREATE FAILED  
        public let status: String?
        /// The time used to train the model. You are billed for the time it takes to train a model. This field is visible only after Amazon Personalize successfully trains a model.
        public let trainingHours: Double?
        /// The scope of training used to create the solution version. The FULL option trains the solution version based on the entirety of the input solution's training data, while the UPDATE option processes only the training data that has changed since the creation of the last solution version. Choose UPDATE when you want to start recommending items added to the dataset without retraining the model.  The UPDATE option can only be used after you've created a solution version with the FULL option and the training solution uses the native-recipe-hrnn-coldstart. 
        public let trainingMode: TrainingMode?
        /// If hyperparameter optimization was performed, contains the hyperparameter values of the best performing model.
        public let tunedHPOParams: TunedHPOParams?

        public init(creationDateTime: TimeStamp? = nil, datasetGroupArn: String? = nil, eventType: String? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, recipeArn: String? = nil, solutionArn: String? = nil, solutionConfig: SolutionConfig? = nil, solutionVersionArn: String? = nil, status: String? = nil, trainingHours: Double? = nil, trainingMode: TrainingMode? = nil, tunedHPOParams: TunedHPOParams? = nil) {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingHours = trainingHours
            self.trainingMode = trainingMode
            self.tunedHPOParams = tunedHPOParams
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case datasetGroupArn = "datasetGroupArn"
            case eventType = "eventType"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case performAutoML = "performAutoML"
            case performHPO = "performHPO"
            case recipeArn = "recipeArn"
            case solutionArn = "solutionArn"
            case solutionConfig = "solutionConfig"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
            case trainingHours = "trainingHours"
            case trainingMode = "trainingMode"
            case tunedHPOParams = "tunedHPOParams"
        }
    }

    public struct SolutionVersionSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "failureReason", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedDateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .string)
        ]

        /// The date and time (in Unix time) that this version of a solution was created.
        public let creationDateTime: TimeStamp?
        /// If a solution version fails, the reason behind the failure.
        public let failureReason: String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public let lastUpdatedDateTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the solution version.
        public let solutionVersionArn: String?
        /// The status of the solution version. A solution version can be in one of the following states:   CREATE PENDING &gt; CREATE IN_PROGRESS &gt; ACTIVE -or- CREATE FAILED  
        public let status: String?

        public init(creationDateTime: TimeStamp? = nil, failureReason: String? = nil, lastUpdatedDateTime: TimeStamp? = nil, solutionVersionArn: String? = nil, status: String? = nil) {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDateTime = "creationDateTime"
            case failureReason = "failureReason"
            case lastUpdatedDateTime = "lastUpdatedDateTime"
            case solutionVersionArn = "solutionVersionArn"
            case status = "status"
        }
    }

    public struct TunedHPOParams: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "algorithmHyperParameters", required: false, type: .map)
        ]

        /// A list of the hyperparameter values of the best performing model.
        public let algorithmHyperParameters: [String: String]?

        public init(algorithmHyperParameters: [String: String]? = nil) {
            self.algorithmHyperParameters = algorithmHyperParameters
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmHyperParameters = "algorithmHyperParameters"
        }
    }

    public struct UpdateCampaignRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: true, type: .string), 
            AWSShapeMember(label: "campaignConfig", required: false, type: .structure), 
            AWSShapeMember(label: "minProvisionedTPS", required: false, type: .integer), 
            AWSShapeMember(label: "solutionVersionArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the campaign.
        public let campaignArn: String
        /// The configuration details of a campaign.
        public let campaignConfig: CampaignConfig?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that Amazon Personalize will support.
        public let minProvisionedTPS: Int?
        /// The ARN of a new solution version to deploy.
        public let solutionVersionArn: String?

        public init(campaignArn: String, campaignConfig: CampaignConfig? = nil, minProvisionedTPS: Int? = nil, solutionVersionArn: String? = nil) {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
        }

        public func validate(name: String) throws {
            try validate(self.campaignArn, name:"campaignArn", parent: name, max: 256)
            try validate(self.campaignArn, name:"campaignArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
            try self.campaignConfig?.validate(name: "\(name).campaignConfig")
            try validate(self.minProvisionedTPS, name:"minProvisionedTPS", parent: name, min: 1)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, max: 256)
            try validate(self.solutionVersionArn, name:"solutionVersionArn", parent: name, pattern: "arn:([a-z\\d-]+):personalize:.*:.*:.+")
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
            case campaignConfig = "campaignConfig"
            case minProvisionedTPS = "minProvisionedTPS"
            case solutionVersionArn = "solutionVersionArn"
        }
    }

    public struct UpdateCampaignResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "campaignArn", required: false, type: .string)
        ]

        /// The same campaign ARN as given in the request.
        public let campaignArn: String?

        public init(campaignArn: String? = nil) {
            self.campaignArn = campaignArn
        }

        private enum CodingKeys: String, CodingKey {
            case campaignArn = "campaignArn"
        }
    }
}

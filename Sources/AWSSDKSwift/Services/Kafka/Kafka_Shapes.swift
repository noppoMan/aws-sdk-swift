//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import AWSSDKSwiftCore
import Foundation

extension Kafka {
    //MARK: Enums

    public enum BrokerAZDistribution: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ClientBroker: String, CustomStringConvertible, Codable {
        case tls = "TLS"
        case tlsPlaintext = "TLS_PLAINTEXT"
        case plaintext = "PLAINTEXT"
        public var description: String { return self.rawValue }
    }

    public enum ClusterState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case updating = "UPDATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum EnhancedMonitoring: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case perBroker = "PER_BROKER"
        case perTopicPerBroker = "PER_TOPIC_PER_BROKER"
        public var description: String { return self.rawValue }
    }

    public enum KafkaVersionStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable {
        case broker = "BROKER"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct BrokerEBSVolumeInfo: AWSEncodableShape & AWSDecodableShape {

        /// The ID of the broker to update.
        public let kafkaBrokerNodeId: String
        ///             Size of the EBS volume to update.
        ///          
        public let volumeSizeGB: Int

        public init(kafkaBrokerNodeId: String, volumeSizeGB: Int) {
            self.kafkaBrokerNodeId = kafkaBrokerNodeId
            self.volumeSizeGB = volumeSizeGB
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaBrokerNodeId = "kafkaBrokerNodeId"
            case volumeSizeGB = "volumeSizeGB"
        }
    }

    public struct BrokerLogs: AWSEncodableShape & AWSDecodableShape {

        /// Details of the CloudWatch Logs destination for broker logs.
        public let cloudWatchLogs: CloudWatchLogs?
        /// Details of the Kinesis Data Firehose delivery stream that is the destination for broker logs.
        public let firehose: Firehose?
        /// Details of the Amazon S3 destination for broker logs.
        public let s3: S3?

        public init(cloudWatchLogs: CloudWatchLogs? = nil, firehose: Firehose? = nil, s3: S3? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs = "cloudWatchLogs"
            case firehose = "firehose"
            case s3 = "s3"
        }
    }

    public struct BrokerNodeGroupInfo: AWSEncodableShape & AWSDecodableShape {

        /// The distribution of broker nodes across Availability Zones.
        public let brokerAZDistribution: BrokerAZDistribution?
        /// The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.
        public let clientSubnets: [String]
        /// The type of Amazon EC2 instances to use for Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.
        public let instanceType: String
        /// The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC. If you specify security groups that were shared with you, you must ensure that you have permissions to them. Specifically, you need the ec2:DescribeSecurityGroups permission.
        public let securityGroups: [String]?
        /// Contains information about storage volumes attached to MSK broker nodes.
        public let storageInfo: StorageInfo?

        public init(brokerAZDistribution: BrokerAZDistribution? = nil, clientSubnets: [String], instanceType: String, securityGroups: [String]? = nil, storageInfo: StorageInfo? = nil) {
            self.brokerAZDistribution = brokerAZDistribution
            self.clientSubnets = clientSubnets
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.storageInfo = storageInfo
        }

        public func validate(name: String) throws {
            try validate(self.instanceType, name: "instanceType", parent: name, max: 32)
            try validate(self.instanceType, name: "instanceType", parent: name, min: 5)
            try self.storageInfo?.validate(name: "\(name).storageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case brokerAZDistribution = "brokerAZDistribution"
            case clientSubnets = "clientSubnets"
            case instanceType = "instanceType"
            case securityGroups = "securityGroups"
            case storageInfo = "storageInfo"
        }
    }

    public struct BrokerNodeInfo: AWSDecodableShape {

        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The ID of the broker.
        public let brokerId: Double?
        /// The client subnet to which this broker node belongs.
        public let clientSubnet: String?
        /// The virtual private cloud (VPC) of the client.
        public let clientVpcIpAddress: String?
        /// Information about the version of software currently deployed on the Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// Endpoints for accessing the broker.
        public let endpoints: [String]?

        public init(attachedENIId: String? = nil, brokerId: Double? = nil, clientSubnet: String? = nil, clientVpcIpAddress: String? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, endpoints: [String]? = nil) {
            self.attachedENIId = attachedENIId
            self.brokerId = brokerId
            self.clientSubnet = clientSubnet
            self.clientVpcIpAddress = clientVpcIpAddress
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId = "attachedENIId"
            case brokerId = "brokerId"
            case clientSubnet = "clientSubnet"
            case clientVpcIpAddress = "clientVpcIpAddress"
            case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
            case endpoints = "endpoints"
        }
    }

    public struct BrokerSoftwareInfo: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.
        public let configurationArn: String?
        /// The revision of the configuration to use. This field isn't visible in this preview release.
        public let configurationRevision: Int64?
        /// The version of Apache Kafka.
        public let kafkaVersion: String?

        public init(configurationArn: String? = nil, configurationRevision: Int64? = nil, kafkaVersion: String? = nil) {
            self.configurationArn = configurationArn
            self.configurationRevision = configurationRevision
            self.kafkaVersion = kafkaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationArn = "configurationArn"
            case configurationRevision = "configurationRevision"
            case kafkaVersion = "kafkaVersion"
        }
    }

    public struct ClientAuthentication: AWSEncodableShape & AWSDecodableShape {

        /// Details for ClientAuthentication using TLS.
        public let tls: Tls?

        public init(tls: Tls? = nil) {
            self.tls = tls
        }

        private enum CodingKeys: String, CodingKey {
            case tls = "tls"
        }
    }

    public struct CloudWatchLogs: AWSEncodableShape & AWSDecodableShape {

        /// Specifies whether broker logs get sent to the specified CloudWatch Logs destination.
        public let enabled: Bool
        /// The CloudWatch log group that is the destination for broker logs.
        public let logGroup: String?

        public init(enabled: Bool, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case logGroup = "logGroup"
        }
    }

    public struct ClusterInfo: AWSDecodableShape {

        /// Arn of active cluster operation.
        public let activeOperationArn: String?
        /// Information about the broker nodes.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String?
        /// The name of the cluster.
        public let clusterName: String?
        /// The time when the cluster was created.
        public let creationTime: TimeStamp?
        /// Information about the version of software currently deployed on the Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// The current version of the MSK cluster. Cluster versions aren't simple integers. You can obtain the current version by describing the cluster. An example version is KTVPDKIKX0DER.
        public let currentVersion: String?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies which metrics are gathered for the MSK cluster. This property has three possible values: DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER. For a list of the metrics associated with each of these three levels of monitoring, see Monitoring.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.
        public let loggingInfo: LoggingInfo?
        ///             The number of broker nodes in the cluster.
        ///          
        public let numberOfBrokerNodes: Int?
        /// Settings for open monitoring using Prometheus.
        public let openMonitoring: OpenMonitoring?
        /// The state of the cluster. The possible states are CREATING, ACTIVE, and FAILED.
        public let state: ClusterState?
        /// Tags attached to the cluster.
        public let tags: [String: String]?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public let zookeeperConnectString: String?

        public init(activeOperationArn: String? = nil, brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil, clientAuthentication: ClientAuthentication? = nil, clusterArn: String? = nil, clusterName: String? = nil, creationTime: TimeStamp? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, currentVersion: String? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil, state: ClusterState? = nil, tags: [String: String]? = nil, zookeeperConnectString: String? = nil) {
            self.activeOperationArn = activeOperationArn
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.creationTime = creationTime
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.state = state
            self.tags = tags
            self.zookeeperConnectString = zookeeperConnectString
        }

        private enum CodingKeys: String, CodingKey {
            case activeOperationArn = "activeOperationArn"
            case brokerNodeGroupInfo = "brokerNodeGroupInfo"
            case clientAuthentication = "clientAuthentication"
            case clusterArn = "clusterArn"
            case clusterName = "clusterName"
            case creationTime = "creationTime"
            case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
            case currentVersion = "currentVersion"
            case encryptionInfo = "encryptionInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
            case state = "state"
            case tags = "tags"
            case zookeeperConnectString = "zookeeperConnectString"
        }
    }

    public struct ClusterOperationInfo: AWSDecodableShape {

        /// The ID of the API request that triggered this operation.
        public let clientRequestId: String?
        /// ARN of the cluster.
        public let clusterArn: String?
        /// The time at which operation was created.
        public let creationTime: TimeStamp?
        /// The time at which the operation finished.
        public let endTime: TimeStamp?
        /// Describes the error if the operation fails.
        public let errorInfo: ErrorInfo?
        /// ARN of the cluster operation.
        public let operationArn: String?
        /// State of the cluster operation.
        public let operationState: String?
        /// Type of the cluster operation.
        public let operationType: String?
        /// Information about cluster attributes before a cluster is updated.
        public let sourceClusterInfo: MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public let targetClusterInfo: MutableClusterInfo?

        public init(clientRequestId: String? = nil, clusterArn: String? = nil, creationTime: TimeStamp? = nil, endTime: TimeStamp? = nil, errorInfo: ErrorInfo? = nil, operationArn: String? = nil, operationState: String? = nil, operationType: String? = nil, sourceClusterInfo: MutableClusterInfo? = nil, targetClusterInfo: MutableClusterInfo? = nil) {
            self.clientRequestId = clientRequestId
            self.clusterArn = clusterArn
            self.creationTime = creationTime
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationType = operationType
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestId = "clientRequestId"
            case clusterArn = "clusterArn"
            case creationTime = "creationTime"
            case endTime = "endTime"
            case errorInfo = "errorInfo"
            case operationArn = "operationArn"
            case operationState = "operationState"
            case operationType = "operationType"
            case sourceClusterInfo = "sourceClusterInfo"
            case targetClusterInfo = "targetClusterInfo"
        }
    }

    public struct Configuration: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String
        public let creationTime: TimeStamp
        /// The description of the configuration.
        public let description: String
        /// An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.
        public let kafkaVersions: [String]
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String

        public init(arn: String, creationTime: TimeStamp, description: String, kafkaVersions: [String], latestRevision: ConfigurationRevision, name: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case kafkaVersions = "kafkaVersions"
            case latestRevision = "latestRevision"
            case name = "name"
        }
    }

    public struct ConfigurationInfo: AWSEncodableShape & AWSDecodableShape {

        /// ARN of the configuration to use.
        public let arn: String
        /// The revision of the configuration to use.
        public let revision: Int64

        public init(arn: String, revision: Int64) {
            self.arn = arn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case revision = "revision"
        }
    }

    public struct ConfigurationRevision: AWSDecodableShape {

        /// The time when the configuration revision was created.
        public let creationTime: TimeStamp
        /// The description of the configuration revision.
        public let description: String?
        /// The revision number.
        public let revision: Int64

        public init(creationTime: TimeStamp, description: String? = nil, revision: Int64) {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case revision = "revision"
        }
    }

    public struct CreateClusterRequest: AWSEncodableShape {

        /// Information about the broker nodes in the cluster.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo
        /// Includes all client authentication related information.
        public let clientAuthentication: ClientAuthentication?
        /// The name of the cluster.
        public let clusterName: String
        /// Represents the configuration that you want MSK to use for the cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, and PER_TOPIC_PER_BROKER.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// The version of Apache Kafka.
        public let kafkaVersion: String
        /// LoggingInfo details.
        public let loggingInfo: LoggingInfo?
        ///             The number of broker nodes in the cluster.
        ///          
        public let numberOfBrokerNodes: Int
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// Create tags when creating the cluster.
        public let tags: [String: String]?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo, clientAuthentication: ClientAuthentication? = nil, clusterName: String, configurationInfo: ConfigurationInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, kafkaVersion: String, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int, openMonitoring: OpenMonitoringInfo? = nil, tags: [String: String]? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterName = clusterName
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.brokerNodeGroupInfo.validate(name: "\(name).brokerNodeGroupInfo")
            try validate(self.clusterName, name: "clusterName", parent: name, max: 64)
            try validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try validate(self.kafkaVersion, name: "kafkaVersion", parent: name, max: 128)
            try validate(self.kafkaVersion, name: "kafkaVersion", parent: name, min: 1)
            try validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, max: 15)
            try validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo = "brokerNodeGroupInfo"
            case clientAuthentication = "clientAuthentication"
            case clusterName = "clusterName"
            case configurationInfo = "configurationInfo"
            case encryptionInfo = "encryptionInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case kafkaVersion = "kafkaVersion"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
            case tags = "tags"
        }
    }

    public struct CreateClusterResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The name of the MSK cluster.
        public let clusterName: String?
        /// The state of the cluster. The possible states are CREATING, ACTIVE, and FAILED.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, clusterName: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterName = "clusterName"
            case state = "state"
        }
    }

    public struct CreateConfigurationRequest: AWSEncodableShape {

        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String
        public let serverProperties: Data

        public init(description: String? = nil, kafkaVersions: [String], name: String, serverProperties: Data) {
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.name = name
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case kafkaVersions = "kafkaVersions"
            case name = "name"
            case serverProperties = "serverProperties"
        }
    }

    public struct CreateConfigurationResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        public let creationTime: TimeStamp?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String?

        public init(arn: String? = nil, creationTime: TimeStamp? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case latestRevision = "latestRevision"
            case name = "name"
        }
    }

    public struct DeleteClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn")), 
            AWSMemberEncoding(label: "currentVersion", location: .querystring(locationName: "currentVersion"))
        ]

        public let clusterArn: String
        public let currentVersion: String?

        public init(clusterArn: String, currentVersion: String? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteClusterResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The state of the cluster. The possible states are CREATING, ACTIVE, and FAILED.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case state = "state"
        }
    }

    public struct DescribeClusterOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterOperationArn", location: .uri(locationName: "clusterOperationArn"))
        ]

        public let clusterOperationArn: String

        public init(clusterOperationArn: String) {
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterOperationResponse: AWSDecodableShape {

        /// Cluster operation information
        public let clusterOperationInfo: ClusterOperationInfo?

        public init(clusterOperationInfo: ClusterOperationInfo? = nil) {
            self.clusterOperationInfo = clusterOperationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfo = "clusterOperationInfo"
        }
    }

    public struct DescribeClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterResponse: AWSDecodableShape {

        /// The cluster information.
        public let clusterInfo: ClusterInfo?

        public init(clusterInfo: ClusterInfo? = nil) {
            self.clusterInfo = clusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfo = "clusterInfo"
        }
    }

    public struct DescribeConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn"))
        ]

        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        public let creationTime: TimeStamp?
        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String?

        public init(arn: String? = nil, creationTime: TimeStamp? = nil, description: String? = nil, kafkaVersions: [String]? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case kafkaVersions = "kafkaVersions"
            case latestRevision = "latestRevision"
            case name = "name"
        }
    }

    public struct DescribeConfigurationRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn")), 
            AWSMemberEncoding(label: "revision", location: .uri(locationName: "revision"))
        ]

        public let arn: String
        public let revision: Int64

        public init(arn: String, revision: Int64) {
            self.arn = arn
            self.revision = revision
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationRevisionResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        public let creationTime: TimeStamp?
        /// The description of the configuration.
        public let description: String?
        /// The revision number.
        public let revision: Int64?
        public let serverProperties: Data?

        public init(arn: String? = nil, creationTime: TimeStamp? = nil, description: String? = nil, revision: Int64? = nil, serverProperties: Data? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case revision = "revision"
            case serverProperties = "serverProperties"
        }
    }

    public struct EBSStorageInfo: AWSEncodableShape & AWSDecodableShape {

        /// The size in GiB of the EBS volume for the data drive on each broker node.
        public let volumeSize: Int?

        public init(volumeSize: Int? = nil) {
            self.volumeSize = volumeSize
        }

        public func validate(name: String) throws {
            try validate(self.volumeSize, name: "volumeSize", parent: name, max: 16384)
            try validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case volumeSize = "volumeSize"
        }
    }

    public struct EncryptionAtRest: AWSEncodableShape & AWSDecodableShape {

        /// The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        public let dataVolumeKMSKeyId: String

        public init(dataVolumeKMSKeyId: String) {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case dataVolumeKMSKeyId = "dataVolumeKMSKeyId"
        }
    }

    public struct EncryptionInTransit: AWSEncodableShape & AWSDecodableShape {

        /// Indicates the encryption setting for data in transit between clients and brokers. You must set it to one of the following values. TLS means that client-broker communication is enabled with TLS only. TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data. PLAINTEXT means that client-broker communication is enabled in plaintext only. The default value is TLS.
        public let clientBroker: ClientBroker?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext. The default value is true.
        public let inCluster: Bool?

        public init(clientBroker: ClientBroker? = nil, inCluster: Bool? = nil) {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }

        private enum CodingKeys: String, CodingKey {
            case clientBroker = "clientBroker"
            case inCluster = "inCluster"
        }
    }

    public struct EncryptionInfo: AWSEncodableShape & AWSDecodableShape {

        /// The data-volume encryption details.
        public let encryptionAtRest: EncryptionAtRest?
        /// The details for encryption in transit.
        public let encryptionInTransit: EncryptionInTransit?

        public init(encryptionAtRest: EncryptionAtRest? = nil, encryptionInTransit: EncryptionInTransit? = nil) {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAtRest = "encryptionAtRest"
            case encryptionInTransit = "encryptionInTransit"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {

        /// A number describing the error programmatically.
        public let errorCode: String?
        /// An optional field to provide more details about the error.
        public let errorString: String?

        public init(errorCode: String? = nil, errorString: String? = nil) {
            self.errorCode = errorCode
            self.errorString = errorString
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorString = "errorString"
        }
    }

    public struct Firehose: AWSEncodableShape & AWSDecodableShape {

        /// The Kinesis Data Firehose delivery stream that is the destination for broker logs.
        public let deliveryStream: String?
        /// Specifies whether broker logs get sent to the specified Kinesis Data Firehose delivery stream.
        public let enabled: Bool

        public init(deliveryStream: String? = nil, enabled: Bool) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream = "deliveryStream"
            case enabled = "enabled"
        }
    }

    public struct GetBootstrapBrokersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBootstrapBrokersResponse: AWSDecodableShape {

        /// A string containing one or more hostname:port pairs.
        public let bootstrapBrokerString: String?
        /// A string containing one or more DNS names (or IP) and TLS port pairs. The following is an example. {
        ///     "BootstrapBrokerStringTls": "b-3.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094,b-1.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094,b-2.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094"
        /// }
        public let bootstrapBrokerStringTls: String?

        public init(bootstrapBrokerString: String? = nil, bootstrapBrokerStringTls: String? = nil) {
            self.bootstrapBrokerString = bootstrapBrokerString
            self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapBrokerString = "bootstrapBrokerString"
            case bootstrapBrokerStringTls = "bootstrapBrokerStringTls"
        }
    }

    public struct JmxExporter: AWSDecodableShape {

        /// Indicates whether you want to enable or disable the JMX Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct JmxExporterInfo: AWSEncodableShape {

        /// JMX Exporter being enabled in broker.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct KafkaVersion: AWSDecodableShape {

        /// The status of the Apache Kafka version.
        public let status: KafkaVersionStatus?
        /// The Kafka version.
        public let version: String?

        public init(status: KafkaVersionStatus? = nil, version: String? = nil) {
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case version = "version"
        }
    }

    public struct ListClusterOperationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let clusterArn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClusterOperationsResponse: AWSDecodableShape {

        /// An array of cluster operation information objects.
        public let clusterOperationInfoList: [ClusterOperationInfo]?
        /// If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.
        public let nextToken: String?

        public init(clusterOperationInfoList: [ClusterOperationInfo]? = nil, nextToken: String? = nil) {
            self.clusterOperationInfoList = clusterOperationInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfoList = "clusterOperationInfoList"
            case nextToken = "nextToken"
        }
    }

    public struct ListClustersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterNameFilter", location: .querystring(locationName: "clusterNameFilter")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let clusterNameFilter: String?
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterNameFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterNameFilter = clusterNameFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersResponse: AWSDecodableShape {

        /// Information on each of the MSK clusters in the response.
        public let clusterInfoList: [ClusterInfo]?
        /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
        public let nextToken: String?

        public init(clusterInfoList: [ClusterInfo]? = nil, nextToken: String? = nil) {
            self.clusterInfoList = clusterInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfoList = "clusterInfoList"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfigurationRevisionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let arn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(arn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationRevisionsResponse: AWSDecodableShape {

        /// Paginated results marker.
        public let nextToken: String?
        /// List of ConfigurationRevision objects.
        public let revisions: [ConfigurationRevision]?

        public init(nextToken: String? = nil, revisions: [ConfigurationRevision]? = nil) {
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case revisions = "revisions"
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {

        /// An array of MSK configurations.
        public let configurations: [Configuration]?
        /// The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
        public let nextToken: String?

        public init(configurations: [Configuration]? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations = "configurations"
            case nextToken = "nextToken"
        }
    }

    public struct ListKafkaVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKafkaVersionsResponse: AWSDecodableShape {

        /// An array of Kafka version objects.
        public let kafkaVersions: [KafkaVersion]?
        /// Paginated results marker.
        public let nextToken: String?

        public init(kafkaVersions: [KafkaVersion]? = nil, nextToken: String? = nil) {
            self.kafkaVersions = kafkaVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaVersions = "kafkaVersions"
            case nextToken = "nextToken"
        }
    }

    public struct ListNodesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn")), 
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let clusterArn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodesResponse: AWSDecodableShape {

        /// The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response. To get another batch of nodes, provide this token in your next request.
        public let nextToken: String?
        /// List containing a NodeInfo object.
        public let nodeInfoList: [NodeInfo]?

        public init(nextToken: String? = nil, nodeInfoList: [NodeInfo]? = nil) {
            self.nextToken = nextToken
            self.nodeInfoList = nodeInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodeInfoList = "nodeInfoList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LoggingInfo: AWSEncodableShape & AWSDecodableShape {

        /// You can configure your MSK cluster to send broker logs to different destination types. This configuration specifies the details of these destinations.
        public let brokerLogs: BrokerLogs

        public init(brokerLogs: BrokerLogs) {
            self.brokerLogs = brokerLogs
        }

        private enum CodingKeys: String, CodingKey {
            case brokerLogs = "brokerLogs"
        }
    }

    public struct MutableClusterInfo: AWSDecodableShape {

        /// Specifies the size of the EBS volume and the ID of the associated broker.
        public let brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?
        /// Information about the changes in the configuration of the brokers.
        public let configurationInfo: ConfigurationInfo?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// LoggingInfo details.
        public let loggingInfo: LoggingInfo?
        ///             The number of broker nodes in the cluster.
        ///          
        public let numberOfBrokerNodes: Int?
        /// Settings for open monitoring using Prometheus.
        public let openMonitoring: OpenMonitoring?

        public init(brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil, configurationInfo: ConfigurationInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil) {
            self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
            self.configurationInfo = configurationInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
        }

        private enum CodingKeys: String, CodingKey {
            case brokerEBSVolumeInfo = "brokerEBSVolumeInfo"
            case configurationInfo = "configurationInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
        }
    }

    public struct NodeExporter: AWSDecodableShape {

        /// Indicates whether you want to enable or disable the Node Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct NodeExporterInfo: AWSEncodableShape {

        /// Node Exporter being enabled in broker.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct NodeInfo: AWSDecodableShape {

        /// The start time.
        public let addedToClusterTime: String?
        /// The broker node info.
        public let brokerNodeInfo: BrokerNodeInfo?
        /// The instance type.
        public let instanceType: String?
        /// The Amazon Resource Name (ARN) of the node.
        public let nodeARN: String?
        /// The node type.
        public let nodeType: NodeType?
        /// The ZookeeperNodeInfo.
        public let zookeeperNodeInfo: ZookeeperNodeInfo?

        public init(addedToClusterTime: String? = nil, brokerNodeInfo: BrokerNodeInfo? = nil, instanceType: String? = nil, nodeARN: String? = nil, nodeType: NodeType? = nil, zookeeperNodeInfo: ZookeeperNodeInfo? = nil) {
            self.addedToClusterTime = addedToClusterTime
            self.brokerNodeInfo = brokerNodeInfo
            self.instanceType = instanceType
            self.nodeARN = nodeARN
            self.nodeType = nodeType
            self.zookeeperNodeInfo = zookeeperNodeInfo
        }

        private enum CodingKeys: String, CodingKey {
            case addedToClusterTime = "addedToClusterTime"
            case brokerNodeInfo = "brokerNodeInfo"
            case instanceType = "instanceType"
            case nodeARN = "nodeARN"
            case nodeType = "nodeType"
            case zookeeperNodeInfo = "zookeeperNodeInfo"
        }
    }

    public struct OpenMonitoring: AWSDecodableShape {

        /// Prometheus settings.
        public let prometheus: Prometheus

        public init(prometheus: Prometheus) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus = "prometheus"
        }
    }

    public struct OpenMonitoringInfo: AWSEncodableShape {

        /// Prometheus settings.
        public let prometheus: PrometheusInfo

        public init(prometheus: PrometheusInfo) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus = "prometheus"
        }
    }

    public struct Prometheus: AWSDecodableShape {

        /// Indicates whether you want to enable or disable the JMX Exporter.
        public let jmxExporter: JmxExporter?
        /// Indicates whether you want to enable or disable the Node Exporter.
        public let nodeExporter: NodeExporter?

        public init(jmxExporter: JmxExporter? = nil, nodeExporter: NodeExporter? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter = "jmxExporter"
            case nodeExporter = "nodeExporter"
        }
    }

    public struct PrometheusInfo: AWSEncodableShape {

        /// JMX Exporter settings.
        public let jmxExporter: JmxExporterInfo?
        /// Node Exporter settings.
        public let nodeExporter: NodeExporterInfo?

        public init(jmxExporter: JmxExporterInfo? = nil, nodeExporter: NodeExporterInfo? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter = "jmxExporter"
            case nodeExporter = "nodeExporter"
        }
    }

    public struct S3: AWSEncodableShape & AWSDecodableShape {

        /// The name of the S3 bucket that is the destination for broker logs.
        public let bucket: String?
        /// Specifies whether broker logs get sent to the specified Amazon S3 destination.
        public let enabled: Bool
        /// The S3 prefix that is the destination for broker logs.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case enabled = "enabled"
            case prefix = "prefix"
        }
    }

    public struct StorageInfo: AWSEncodableShape & AWSDecodableShape {

        /// EBS volume information.
        public let ebsStorageInfo: EBSStorageInfo?

        public init(ebsStorageInfo: EBSStorageInfo? = nil) {
            self.ebsStorageInfo = ebsStorageInfo
        }

        public func validate(name: String) throws {
            try self.ebsStorageInfo?.validate(name: "\(name).ebsStorageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case ebsStorageInfo = "ebsStorageInfo"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String
        /// The key-value pair for the resource tag.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Tls: AWSEncodableShape & AWSDecodableShape {

        /// List of ACM Certificate Authority ARNs.
        public let certificateAuthorityArnList: [String]?

        public init(certificateAuthorityArnList: [String]? = nil) {
            self.certificateAuthorityArnList = certificateAuthorityArnList
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArnList = "certificateAuthorityArnList"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateBrokerCountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// The current version of the cluster.
        public let currentVersion: String
        /// The number of broker nodes that you want the cluster to have after this operation completes successfully.
        public let targetNumberOfBrokerNodes: Int

        public init(clusterArn: String, currentVersion: String, targetNumberOfBrokerNodes: Int) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
        }

        public func validate(name: String) throws {
            try validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, max: 15)
            try validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
        }
    }

    public struct UpdateBrokerCountResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateBrokerStorageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String
        /// Describes the target volume size and the ID of the broker to apply the update to. The value you specify for Target-Volume-in-GiB must be a whole number that is greater than 100 GiB. The storage per broker after the update operation can't exceed 16384 GiB.
        public let targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]

        public init(clusterArn: String, currentVersion: String, targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
        }
    }

    public struct UpdateBrokerStorageResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateClusterConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// Represents the configuration that you want MSK to use for the cluster.
        public let configurationInfo: ConfigurationInfo
        /// The version of the cluster that you want to update.
        public let currentVersion: String

        public init(clusterArn: String, configurationInfo: ConfigurationInfo, currentVersion: String) {
            self.clusterArn = clusterArn
            self.configurationInfo = configurationInfo
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationInfo = "configurationInfo"
            case currentVersion = "currentVersion"
        }
    }

    public struct UpdateClusterConfigurationResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateMonitoringRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// LoggingInfo details.
        public let loggingInfo: LoggingInfo?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?

        public init(clusterArn: String, currentVersion: String, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, openMonitoring: OpenMonitoringInfo? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.openMonitoring = openMonitoring
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case enhancedMonitoring = "enhancedMonitoring"
            case loggingInfo = "loggingInfo"
            case openMonitoring = "openMonitoring"
        }
    }

    public struct UpdateMonitoringResponse: AWSDecodableShape {

        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct ZookeeperNodeInfo: AWSDecodableShape {

        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The virtual private cloud (VPC) IP address of the client.
        public let clientVpcIpAddress: String?
        /// Endpoints for accessing the ZooKeeper.
        public let endpoints: [String]?
        /// The role-specific ID for Zookeeper.
        public let zookeeperId: Double?
        /// The version of Zookeeper.
        public let zookeeperVersion: String?

        public init(attachedENIId: String? = nil, clientVpcIpAddress: String? = nil, endpoints: [String]? = nil, zookeeperId: Double? = nil, zookeeperVersion: String? = nil) {
            self.attachedENIId = attachedENIId
            self.clientVpcIpAddress = clientVpcIpAddress
            self.endpoints = endpoints
            self.zookeeperId = zookeeperId
            self.zookeeperVersion = zookeeperVersion
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId = "attachedENIId"
            case clientVpcIpAddress = "clientVpcIpAddress"
            case endpoints = "endpoints"
            case zookeeperId = "zookeeperId"
            case zookeeperVersion = "zookeeperVersion"
        }
    }
}

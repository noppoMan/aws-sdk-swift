// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension DatabaseMigrationService {
    //MARK: Enums

    public enum AuthMechanismValue: String, CustomStringConvertible, Codable {
        case `default` = "default"
        case mongodbCr = "mongodb_cr"
        case scramSha1 = "scram_sha_1"
        public var description: String { return self.rawValue }
    }

    public enum AuthTypeValue: String, CustomStringConvertible, Codable {
        case no = "no"
        case password = "password"
        public var description: String { return self.rawValue }
    }

    public enum CompressionTypeValue: String, CustomStringConvertible, Codable {
        case none = "none"
        case gzip = "gzip"
        public var description: String { return self.rawValue }
    }

    public enum DataFormatValue: String, CustomStringConvertible, Codable {
        case csv = "csv"
        case parquet = "parquet"
        public var description: String { return self.rawValue }
    }

    public enum DmsSslModeValue: String, CustomStringConvertible, Codable {
        case none = "none"
        case require = "require"
        case verifyCa = "verify-ca"
        case verifyFull = "verify-full"
        public var description: String { return self.rawValue }
    }

    public enum EncodingTypeValue: String, CustomStringConvertible, Codable {
        case plain = "plain"
        case plainDictionary = "plain-dictionary"
        case rleDictionary = "rle-dictionary"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionModeValue: String, CustomStringConvertible, Codable {
        case sseS3 = "sse-s3"
        case sseKms = "sse-kms"
        public var description: String { return self.rawValue }
    }

    public enum MessageFormatValue: String, CustomStringConvertible, Codable {
        case json = "json"
        case jsonUnformatted = "json-unformatted"
        public var description: String { return self.rawValue }
    }

    public enum MigrationTypeValue: String, CustomStringConvertible, Codable {
        case fullLoad = "full-load"
        case cdc = "cdc"
        case fullLoadAndCdc = "full-load-and-cdc"
        public var description: String { return self.rawValue }
    }

    public enum NestingLevelValue: String, CustomStringConvertible, Codable {
        case none = "none"
        case one = "one"
        public var description: String { return self.rawValue }
    }

    public enum ParquetVersionValue: String, CustomStringConvertible, Codable {
        case parquet10 = "parquet-1-0"
        case parquet20 = "parquet-2-0"
        public var description: String { return self.rawValue }
    }

    public enum RefreshSchemasStatusTypeValue: String, CustomStringConvertible, Codable {
        case successful = "successful"
        case failed = "failed"
        case refreshing = "refreshing"
        public var description: String { return self.rawValue }
    }

    public enum ReleaseStatusValues: String, CustomStringConvertible, Codable {
        case beta = "beta"
        public var description: String { return self.rawValue }
    }

    public enum ReloadOptionValue: String, CustomStringConvertible, Codable {
        case dataReload = "data-reload"
        case validateOnly = "validate-only"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationEndpointTypeValue: String, CustomStringConvertible, Codable {
        case source = "source"
        case target = "target"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable {
        case replicationInstance = "replication-instance"
        public var description: String { return self.rawValue }
    }

    public enum StartReplicationTaskTypeValue: String, CustomStringConvertible, Codable {
        case startReplication = "start-replication"
        case resumeProcessing = "resume-processing"
        case reloadTarget = "reload-target"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AccountQuota: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountQuotaName", required: false, type: .string), 
            AWSShapeMember(label: "Max", required: false, type: .long), 
            AWSShapeMember(label: "Used", required: false, type: .long)
        ]

        /// The name of the AWS DMS quota for this AWS account.
        public let accountQuotaName: String?
        /// The maximum allowed value for the quota.
        public let max: Int64?
        /// The amount currently used toward the quota maximum.
        public let used: Int64?

        public init(accountQuotaName: String? = nil, max: Int64? = nil, used: Int64? = nil) {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotaName = "AccountQuotaName"
            case max = "Max"
            case used = "Used"
        }
    }

    public struct AddTagsToResourceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .list)
        ]

        /// Identifies the AWS DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For AWS DMS, you can tag a replication instance, an endpoint, or a replication task.
        public let resourceArn: String
        /// One or more tags to be assigned to the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct AddTagsToResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct ApplyPendingMaintenanceActionMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApplyAction", required: true, type: .string), 
            AWSShapeMember(label: "OptInType", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]

        /// The pending maintenance action to apply to this resource.
        public let applyAction: String
        /// A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an opt-in request of type immediate. Valid values:    immediate - Apply the maintenance action immediately.    next-maintenance - Apply the maintenance action during the next maintenance window for the resource.    undo-opt-in - Cancel any existing next-maintenance opt-in requests.  
        public let optInType: String
        /// The Amazon Resource Name (ARN) of the AWS DMS resource that the pending maintenance action applies to.
        public let replicationInstanceArn: String

        public init(applyAction: String, optInType: String, replicationInstanceArn: String) {
            self.applyAction = applyAction
            self.optInType = optInType
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case applyAction = "ApplyAction"
            case optInType = "OptInType"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct ApplyPendingMaintenanceActionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourcePendingMaintenanceActions", required: false, type: .structure)
        ]

        /// The AWS DMS resource that the pending maintenance action will be applied to.
        public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?

        public init(resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions? = nil) {
            self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
        }
    }

    public struct AvailabilityZone: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of the Availability Zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CancelReplicationTaskAssessmentRunMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskAssessmentRunArn", required: true, type: .string)
        ]

        /// Amazon Resource Name (ARN) of the premigration assessment run to be canceled.
        public let replicationTaskAssessmentRunArn: String

        public init(replicationTaskAssessmentRunArn: String) {
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        }
    }

    public struct CancelReplicationTaskAssessmentRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskAssessmentRun", required: false, type: .structure)
        ]

        /// The ReplicationTaskAssessmentRun object for the canceled assessment run.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct Certificate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "CertificateCreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "CertificateIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "CertificateOwner", required: false, type: .string), 
            AWSShapeMember(label: "CertificatePem", required: false, type: .string), 
            AWSShapeMember(label: "CertificateWallet", required: false, type: .blob), 
            AWSShapeMember(label: "KeyLength", required: false, type: .integer), 
            AWSShapeMember(label: "SigningAlgorithm", required: false, type: .string), 
            AWSShapeMember(label: "ValidFromDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ValidToDate", required: false, type: .timestamp)
        ]

        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The date that the certificate was created.
        public let certificateCreationDate: TimeStamp?
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let certificateIdentifier: String?
        /// The owner of the certificate.
        public let certificateOwner: String?
        /// The contents of a .pem file, which contains an X.509 certificate.
        public let certificatePem: String?
        /// The location of an imported Oracle Wallet certificate for use with SSL.
        public let certificateWallet: Data?
        /// The key length of the cryptographic algorithm being used.
        public let keyLength: Int?
        /// The signing algorithm for the certificate.
        public let signingAlgorithm: String?
        /// The beginning date that the certificate is valid.
        public let validFromDate: TimeStamp?
        /// The final date that the certificate is valid.
        public let validToDate: TimeStamp?

        public init(certificateArn: String? = nil, certificateCreationDate: TimeStamp? = nil, certificateIdentifier: String? = nil, certificateOwner: String? = nil, certificatePem: String? = nil, certificateWallet: Data? = nil, keyLength: Int? = nil, signingAlgorithm: String? = nil, validFromDate: TimeStamp? = nil, validToDate: TimeStamp? = nil) {
            self.certificateArn = certificateArn
            self.certificateCreationDate = certificateCreationDate
            self.certificateIdentifier = certificateIdentifier
            self.certificateOwner = certificateOwner
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.validFromDate = validFromDate
            self.validToDate = validToDate
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case certificateCreationDate = "CertificateCreationDate"
            case certificateIdentifier = "CertificateIdentifier"
            case certificateOwner = "CertificateOwner"
            case certificatePem = "CertificatePem"
            case certificateWallet = "CertificateWallet"
            case keyLength = "KeyLength"
            case signingAlgorithm = "SigningAlgorithm"
            case validFromDate = "ValidFromDate"
            case validToDate = "ValidToDate"
        }
    }

    public struct Connection: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "EndpointIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "LastFailureMessage", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// The ARN string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The identifier of the endpoint. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The error message when the connection last failed.
        public let lastFailureMessage: String?
        /// The ARN of the replication instance.
        public let replicationInstanceArn: String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        /// The connection status. This parameter can return one of the following values:    "successful"     "testing"     "failed"     "deleting"   
        public let status: String?

        public init(endpointArn: String? = nil, endpointIdentifier: String? = nil, lastFailureMessage: String? = nil, replicationInstanceArn: String? = nil, replicationInstanceIdentifier: String? = nil, status: String? = nil) {
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case lastFailureMessage = "LastFailureMessage"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case status = "Status"
        }
    }

    public struct CreateEndpointMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "DmsTransferSettings", required: false, type: .structure), 
            AWSShapeMember(label: "DynamoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "ElasticsearchSettings", required: false, type: .structure), 
            AWSShapeMember(label: "EndpointIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "EndpointType", required: true, type: .enum), 
            AWSShapeMember(label: "EngineName", required: true, type: .string), 
            AWSShapeMember(label: "ExternalTableDefinition", required: false, type: .string), 
            AWSShapeMember(label: "ExtraConnectionAttributes", required: false, type: .string), 
            AWSShapeMember(label: "IBMDb2Settings", required: false, type: .structure), 
            AWSShapeMember(label: "KafkaSettings", required: false, type: .structure), 
            AWSShapeMember(label: "KinesisSettings", required: false, type: .structure), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "MicrosoftSQLServerSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MongoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MySQLSettings", required: false, type: .structure), 
            AWSShapeMember(label: "NeptuneSettings", required: false, type: .structure), 
            AWSShapeMember(label: "OracleSettings", required: false, type: .structure), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "PostgreSQLSettings", required: false, type: .structure), 
            AWSShapeMember(label: "RedshiftSettings", required: false, type: .structure), 
            AWSShapeMember(label: "S3Settings", required: false, type: .structure), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SslMode", required: false, type: .enum), 
            AWSShapeMember(label: "SybaseSettings", required: false, type: .structure), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The name of the endpoint database.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Possible settings include the following:    ServiceAccessRoleArn - The IAM role that has permission to access the Amazon S3 bucket.    BucketName - The name of the S3 bucket to use.    CompressionType - An optional parameter to use GZIP to compress the target files. To use GZIP, set this value to NONE (the default). To keep the files uncompressed, don't use this value.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string,CompressionType=string  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", "CompressionType": "none"|"gzip" }  
        public let dmsTransferSettings: DmsTransferSettings?
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see Using Object Mapping to Migrate Data to DynamoDB in the AWS Database Migration Service User Guide. 
        public let dynamoDbSettings: DynamoDbSettings?
        /// Settings in JSON format for the target Elasticsearch endpoint. For more information about the available settings, see Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS in the AWS Database Migration Service User Guide.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
        public let endpointIdentifier: String
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue
        /// The type of engine for the endpoint. Valid values, depending on the EndpointType value, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "docdb", "sqlserver", and "neptune".
        public let engineName: String
        /// The external table definition. 
        public let externalTableDefinition: String?
        /// Additional attributes associated with the connection. Each attribute is specified as a name-value pair associated by an equal sign (=). Multiple attributes are separated by a semicolon (;) with no additional white space. For information on the attributes available for connecting your source or target endpoint, see Working with AWS DMS Endpoints in the AWS Database Migration Service User Guide. 
        public let extraConnectionAttributes: String?
        /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see Extra connection attributes when using Db2 LUW as a source for AWS DMS in the AWS Database Migration Service User Guide. 
        public let iBMDb2Settings: IBMDb2Settings?
        /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see Using Apache Kafka as a Target for AWS Database Migration Service in the AWS Database Migration Service User Guide. 
        public let kafkaSettings: KafkaSettings?
        /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see Using Amazon Kinesis Data Streams as a Target for AWS Database Migration Service in the AWS Database Migration Service User Guide. 
        public let kinesisSettings: KinesisSettings?
        /// An AWS KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS Region.
        public let kmsKeyId: String?
        /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see Extra connection attributes when using SQL Server as a source for AWS DMS and  Extra connection attributes when using SQL Server as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see Using MongoDB as a Target for AWS Database Migration Service in the AWS Database Migration Service User Guide. 
        public let mongoDbSettings: MongoDbSettings?
        /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see Extra connection attributes when using MySQL as a source for AWS DMS and Extra connection attributes when using a MySQL-compatible database as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let mySQLSettings: MySQLSettings?
        /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see Specifying Endpoint Settings for Amazon Neptune as a Target in the AWS Database Migration Service User Guide. 
        public let neptuneSettings: NeptuneSettings?
        /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see Extra connection attributes when using Oracle as a source for AWS DMS and  Extra connection attributes when using Oracle as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let oracleSettings: OracleSettings?
        /// The password to be used to log in to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int?
        /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see Extra connection attributes when using PostgreSQL as a source for AWS DMS and  Extra connection attributes when using PostgreSQL as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let postgreSQLSettings: PostgreSQLSettings?
        public let redshiftSettings: RedshiftSettings?
        /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see Extra Connection Attributes When Using Amazon S3 as a Target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let s3Settings: S3Settings?
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        ///  The Amazon Resource Name (ARN) for the service access role that you want to use to create the endpoint. 
        public let serviceAccessRoleArn: String?
        /// The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is none 
        public let sslMode: DmsSslModeValue?
        /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see Extra connection attributes when using SAP ASE as a source for AWS DMS and Extra connection attributes when using SAP ASE as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let sybaseSettings: SybaseSettings?
        /// One or more tags to be assigned to the endpoint.
        public let tags: [Tag]?
        /// The user name to be used to log in to the endpoint database.
        public let username: String?

        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointIdentifier: String, endpointType: ReplicationEndpointTypeValue, engineName: String, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, iBMDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, kmsKeyId: String? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, password: String? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redshiftSettings: RedshiftSettings? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, sybaseSettings: SybaseSettings? = nil, tags: [Tag]? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.iBMDb2Settings = iBMDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.password = password
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.sybaseSettings = sybaseSettings
            self.tags = tags
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineName = "EngineName"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case iBMDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case kmsKeyId = "KmsKeyId"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case password = "Password"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redshiftSettings = "RedshiftSettings"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case sybaseSettings = "SybaseSettings"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct CreateEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .structure)
        ]

        /// The endpoint that was created.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct CreateEventSubscriptionMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "EventCategories", required: false, type: .list), 
            AWSShapeMember(label: "SnsTopicArn", required: true, type: .string), 
            AWSShapeMember(label: "SourceIds", required: false, type: .list), 
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "SubscriptionName", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        ///  A Boolean value; set to true to activate the subscription, or set to false to create the subscription but not activate it. 
        public let enabled: Bool?
        /// A list of event categories for a source type that you want to subscribe to. For more information, see Working with Events and Notifications in the AWS Database Migration Service User Guide. 
        public let eventCategories: [String]?
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it. 
        public let snsTopicArn: String
        /// A list of identifiers for which AWS DMS provides notification events. If you don't specify a value, notifications are provided for all sources. If you specify multiple values, they must be of the same type. For example, if you specify a database instance ID, then all of the other values must be database instance IDs.
        public let sourceIds: [String]?
        ///  The type of AWS DMS resource that generates the events. For example, if you want to be notified of events generated by a replication instance, you set this parameter to replication-instance. If this value isn't specified, all events are returned.  Valid values: replication-instance | replication-task 
        public let sourceType: String?
        /// The name of the AWS DMS event notification subscription. This name must be less than 255 characters.
        public let subscriptionName: String
        /// One or more tags to be assigned to the event subscription.
        public let tags: [Tag]?

        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String, sourceIds: [String]? = nil, sourceType: String? = nil, subscriptionName: String, tags: [Tag]? = nil) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceIds = sourceIds
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceIds = "SourceIds"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
            case tags = "Tags"
        }
    }

    public struct CreateEventSubscriptionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscription", required: false, type: .structure)
        ]

        /// The event subscription that was created.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct CreateReplicationInstanceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "AutoMinorVersionUpgrade", required: false, type: .boolean), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "DnsNameServers", required: false, type: .string), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeMember(label: "PubliclyAccessible", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "VpcSecurityGroupIds", required: false, type: .list)
        ]

        /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
        public let allocatedStorage: Int?
        /// A value that indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window. This parameter defaults to true. Default: true 
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone where the replication instance will be created. The default value is a random, system-chosen Availability Zone in the endpoint's AWS Region, for example: us-east-1d 
        public let availabilityZone: String?
        /// A list of custom DNS name servers supported for the replication instance to access your on-premise source or target database. This list overrides the default name servers supported by the replication instance. You can specify a comma-separated list of internet addresses for up to four on-premise DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4" 
        public let dnsNameServers: String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
        public let engineVersion: String?
        /// An AWS KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS Region.
        public let kmsKeyId: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).  Format: ddd:hh24:mi-ddd:hh24:mi  Default: A 30-minute window selected at random from an 8-hour block of time per AWS Region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
        public let preferredMaintenanceWindow: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true. 
        public let publiclyAccessible: Bool?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right AWS DMS replication instance for your migration. 
        public let replicationInstanceClass: String
        /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain 1-63 alphanumeric characters or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance 
        public let replicationInstanceIdentifier: String
        /// A subnet group to associate with the replication instance.
        public let replicationSubnetGroupIdentifier: String?
        /// One or more tags to be assigned to the replication instance.
        public let tags: [Tag]?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance. 
        public let vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, dnsNameServers: String? = nil, engineVersion: String? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceClass: String, replicationInstanceIdentifier: String, replicationSubnetGroupIdentifier: String? = nil, tags: [Tag]? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.tags = tags
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case dnsNameServers = "DnsNameServers"
            case engineVersion = "EngineVersion"
            case kmsKeyId = "KmsKeyId"
            case multiAZ = "MultiAZ"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case tags = "Tags"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct CreateReplicationInstanceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .structure)
        ]

        /// The replication instance that was created.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct CreateReplicationSubnetGroupMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroupDescription", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "SubnetIds", required: true, type: .list), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// The description for the subnet group.
        public let replicationSubnetGroupDescription: String
        /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default". Example: mySubnetgroup 
        public let replicationSubnetGroupIdentifier: String
        /// One or more subnet IDs to be assigned to the subnet group.
        public let subnetIds: [String]
        /// One or more tags to be assigned to the subnet group.
        public let tags: [Tag]?

        public init(replicationSubnetGroupDescription: String, replicationSubnetGroupIdentifier: String, subnetIds: [String], tags: [Tag]? = nil) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetIds = subnetIds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetIds = "SubnetIds"
            case tags = "Tags"
        }
    }

    public struct CreateReplicationSubnetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroup", required: false, type: .structure)
        ]

        /// The replication subnet group that was created.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct CreateReplicationTaskMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CdcStartPosition", required: false, type: .string), 
            AWSShapeMember(label: "CdcStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CdcStopPosition", required: false, type: .string), 
            AWSShapeMember(label: "MigrationType", required: true, type: .enum), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationTaskSettings", required: false, type: .string), 
            AWSShapeMember(label: "SourceEndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "TableMappings", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list), 
            AWSShapeMember(label: "TargetEndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "TaskData", required: false, type: .string)
        ]

        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error.  The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for AWS DMS. 
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
        public let cdcStartTime: TimeStamp?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc 
        public let migrationType: MigrationTypeValue
        /// The Amazon Resource Name (ARN) of a replication instance.
        public let replicationInstanceArn: String
        /// An identifier for the replication task. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public let replicationTaskIdentifier: String
        /// Overall settings for the task, in JSON format. For more information, see Specifying Task Settings for AWS Database Migration Service Tasks in the AWS Database Migration User Guide. 
        public let replicationTaskSettings: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
        public let sourceEndpointArn: String
        /// The table mappings for the task, in JSON format. For more information, see Using Table Mapping to Specify Task Settings in the AWS Database Migration Service User Guide. 
        public let tableMappings: String
        /// One or more tags to be assigned to the replication task.
        public let tags: [Tag]?
        /// An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
        public let targetEndpointArn: String
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the AWS Database Migration Service User Guide. 
        public let taskData: String?

        public init(cdcStartPosition: String? = nil, cdcStartTime: TimeStamp? = nil, cdcStopPosition: String? = nil, migrationType: MigrationTypeValue, replicationInstanceArn: String, replicationTaskIdentifier: String, replicationTaskSettings: String? = nil, sourceEndpointArn: String, tableMappings: String, tags: [Tag]? = nil, targetEndpointArn: String, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.migrationType = migrationType
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.sourceEndpointArn = sourceEndpointArn
            self.tableMappings = tableMappings
            self.tags = tags
            self.targetEndpointArn = targetEndpointArn
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case migrationType = "MigrationType"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case sourceEndpointArn = "SourceEndpointArn"
            case tableMappings = "TableMappings"
            case tags = "Tags"
            case targetEndpointArn = "TargetEndpointArn"
            case taskData = "TaskData"
        }
    }

    public struct CreateReplicationTaskResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]

        /// The replication task that was created.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DeleteCertificateMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the deleted certificate.
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
        }
    }

    public struct DeleteCertificateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: false, type: .structure)
        ]

        /// The Secure Sockets Layer (SSL) certificate.
        public let certificate: Certificate?

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct DeleteConnectionMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DeleteConnectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connection", required: false, type: .structure)
        ]

        /// The connection that is being deleted.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteEndpointMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct DeleteEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .structure)
        ]

        /// The endpoint that was deleted.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct DeleteEventSubscriptionMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubscriptionName", required: true, type: .string)
        ]

        /// The name of the DMS event notification subscription to be deleted.
        public let subscriptionName: String

        public init(subscriptionName: String) {
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DeleteEventSubscriptionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscription", required: false, type: .structure)
        ]

        /// The event subscription that was deleted.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct DeleteReplicationInstanceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
        public let replicationInstanceArn: String

        public init(replicationInstanceArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DeleteReplicationInstanceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .structure)
        ]

        /// The replication instance that was deleted.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct DeleteReplicationSubnetGroupMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: true, type: .string)
        ]

        /// The subnet group name of the replication instance.
        public let replicationSubnetGroupIdentifier: String

        public init(replicationSubnetGroupIdentifier: String) {
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        }
    }

    public struct DeleteReplicationSubnetGroupResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteReplicationTaskAssessmentRunMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskAssessmentRunArn", required: true, type: .string)
        ]

        /// Amazon Resource Name (ARN) of the premigration assessment run to be deleted.
        public let replicationTaskAssessmentRunArn: String

        public init(replicationTaskAssessmentRunArn: String) {
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        }
    }

    public struct DeleteReplicationTaskAssessmentRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskAssessmentRun", required: false, type: .structure)
        ]

        /// The ReplicationTaskAssessmentRun object for the deleted assessment run.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct DeleteReplicationTaskMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the replication task to be deleted.
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DeleteReplicationTaskResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]

        /// The deleted replication task.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DescribeAccountAttributesMessage: AWSShape {


        public init() {
        }

    }

    public struct DescribeAccountAttributesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountQuotas", required: false, type: .list), 
            AWSShapeMember(label: "UniqueAccountIdentifier", required: false, type: .string)
        ]

        /// Account quota information.
        public let accountQuotas: [AccountQuota]?
        /// A unique AWS DMS identifier for an account in a particular AWS Region. The value of this identifier has the following format: c99999999999. DMS uses this identifier to name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket for storing task assessment reports in a given AWS Region. The format of this S3 bucket name is the following: dms-AccountNumber-UniqueAccountIdentifier. Here is an example name for this default S3 bucket: dms-111122223333-c44445555666.  AWS DMS supports the UniqueAccountIdentifier parameter in versions 3.1.4 and later. 
        public let uniqueAccountIdentifier: String?

        public init(accountQuotas: [AccountQuota]? = nil, uniqueAccountIdentifier: String? = nil) {
            self.accountQuotas = accountQuotas
            self.uniqueAccountIdentifier = uniqueAccountIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotas = "AccountQuotas"
            case uniqueAccountIdentifier = "UniqueAccountIdentifier"
        }
    }

    public struct DescribeApplicableIndividualAssessmentsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "MigrationType", required: false, type: .enum), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string), 
            AWSShapeMember(label: "SourceEngineName", required: false, type: .string), 
            AWSShapeMember(label: "TargetEngineName", required: false, type: .string)
        ]

        /// Optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// Maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?
        /// Name of the migration type that each provided individual assessment must support.
        public let migrationType: MigrationTypeValue?
        /// ARN of a replication instance on which you want to base the default list of individual assessments.
        public let replicationInstanceArn: String?
        /// Amazon Resource Name (ARN) of a migration task on which you want to base the default list of individual assessments.
        public let replicationTaskArn: String?
        /// Name of a database engine that the specified replication instance supports as a source.
        public let sourceEngineName: String?
        /// Name of a database engine that the specified replication instance supports as a target.
        public let targetEngineName: String?

        public init(marker: String? = nil, maxRecords: Int? = nil, migrationType: MigrationTypeValue? = nil, replicationInstanceArn: String? = nil, replicationTaskArn: String? = nil, sourceEngineName: String? = nil, targetEngineName: String? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationType = migrationType
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.sourceEngineName = sourceEngineName
            self.targetEngineName = targetEngineName
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationType = "MigrationType"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskArn = "ReplicationTaskArn"
            case sourceEngineName = "SourceEngineName"
            case targetEngineName = "TargetEngineName"
        }
    }

    public struct DescribeApplicableIndividualAssessmentsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndividualAssessmentNames", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]

        /// List of names for the individual assessments supported by the premigration assessment run that you start based on the specified request parameters. For more information on the available individual assessments, including compatibility with different migration task configurations, see Working with premigration assessment runs in the AWS Database Migration Service User Guide. 
        public let individualAssessmentNames: [String]?
        /// Pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?

        public init(individualAssessmentNames: [String]? = nil, marker: String? = nil) {
            self.individualAssessmentNames = individualAssessmentNames
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentNames = "IndividualAssessmentNames"
            case marker = "Marker"
        }
    }

    public struct DescribeCertificatesMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// Filters applied to the certificates described in the form of key-value pairs.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 10
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeCertificatesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificates", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]

        /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
        public let certificates: [Certificate]?
        /// The pagination token.
        public let marker: String?

        public init(certificates: [Certificate]? = nil, marker: String? = nil) {
            self.certificates = certificates
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case certificates = "Certificates"
            case marker = "Marker"
        }
    }

    public struct DescribeConnectionsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeConnectionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connections", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]

        /// A description of the connections.
        public let connections: [Connection]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(connections: [Connection]? = nil, marker: String? = nil) {
            self.connections = connections
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case marker = "Marker"
        }
    }

    public struct DescribeEndpointTypesMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// Filters applied to the endpoint types. Valid filter names: engine-name | endpoint-type
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointTypesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "SupportedEndpointTypes", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The types of endpoints that are supported.
        public let supportedEndpointTypes: [SupportedEndpointType]?

        public init(marker: String? = nil, supportedEndpointTypes: [SupportedEndpointType]? = nil) {
            self.marker = marker
            self.supportedEndpointTypes = supportedEndpointTypes
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case supportedEndpointTypes = "SupportedEndpointTypes"
        }
    }

    public struct DescribeEndpointsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// Filters applied to the endpoints. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoints", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]

        /// Endpoint description.
        public let endpoints: [Endpoint]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(endpoints: [Endpoint]? = nil, marker: String? = nil) {
            self.endpoints = endpoints
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
            case marker = "Marker"
        }
    }

    public struct DescribeEventCategoriesMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "SourceType", required: false, type: .string)
        ]

        /// Filters applied to the event categories.
        public let filters: [Filter]?
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | replication-task
        public let sourceType: String?

        public init(filters: [Filter]? = nil, sourceType: String? = nil) {
            self.filters = filters
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case sourceType = "SourceType"
        }
    }

    public struct DescribeEventCategoriesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventCategoryGroupList", required: false, type: .list)
        ]

        /// A list of event categories.
        public let eventCategoryGroupList: [EventCategoryGroup]?

        public init(eventCategoryGroupList: [EventCategoryGroup]? = nil) {
            self.eventCategoryGroupList = eventCategoryGroupList
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategoryGroupList = "EventCategoryGroupList"
        }
    }

    public struct DescribeEventSubscriptionsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "SubscriptionName", required: false, type: .string)
        ]

        /// Filters applied to event subscriptions.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The name of the AWS DMS event subscription to be described.
        public let subscriptionName: String?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, subscriptionName: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DescribeEventSubscriptionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscriptionsList", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]

        /// A list of event subscriptions.
        public let eventSubscriptionsList: [EventSubscription]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(eventSubscriptionsList: [EventSubscription]? = nil, marker: String? = nil) {
            self.eventSubscriptionsList = eventSubscriptionsList
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscriptionsList = "EventSubscriptionsList"
            case marker = "Marker"
        }
    }

    public struct DescribeEventsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", required: false, type: .integer), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "EventCategories", required: false, type: .list), 
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "SourceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .enum), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp)
        ]

        /// The duration of the events to be listed.
        public let duration: Int?
        /// The end time for the events to be listed.
        public let endTime: TimeStamp?
        /// A list of event categories for the source type that you've chosen.
        public let eventCategories: [String]?
        /// Filters applied to events.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        ///  The identifier of an event source.
        public let sourceIdentifier: String?
        /// The type of AWS DMS resource that generates events. Valid values: replication-instance | replication-task
        public let sourceType: SourceType?
        /// The start time for the events to be listed.
        public let startTime: TimeStamp?

        public init(duration: Int? = nil, endTime: TimeStamp? = nil, eventCategories: [String]? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil, startTime: TimeStamp? = nil) {
            self.duration = duration
            self.endTime = endTime
            self.eventCategories = eventCategories
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case endTime = "EndTime"
            case eventCategories = "EventCategories"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
            case startTime = "StartTime"
        }
    }

    public struct DescribeEventsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Events", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string)
        ]

        /// The events described.
        public let events: [Event]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?

        public init(events: [Event]? = nil, marker: String? = nil) {
            self.events = events
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case marker = "Marker"
        }
    }

    public struct DescribeOrderableReplicationInstancesMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(marker: String? = nil, maxRecords: Int? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeOrderableReplicationInstancesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "OrderableReplicationInstances", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The order-able replication instances available.
        public let orderableReplicationInstances: [OrderableReplicationInstance]?

        public init(marker: String? = nil, orderableReplicationInstances: [OrderableReplicationInstance]? = nil) {
            self.marker = marker
            self.orderableReplicationInstances = orderableReplicationInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case orderableReplicationInstances = "OrderableReplicationInstances"
        }
    }

    public struct DescribePendingMaintenanceActionsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string)
        ]

        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, replicationInstanceArn: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DescribePendingMaintenanceActionsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "PendingMaintenanceActions", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The pending maintenance action.
        public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?

        public init(marker: String? = nil, pendingMaintenanceActions: [ResourcePendingMaintenanceActions]? = nil) {
            self.marker = marker
            self.pendingMaintenanceActions = pendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case pendingMaintenanceActions = "PendingMaintenanceActions"
        }
    }

    public struct DescribeRefreshSchemasStatusMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct DescribeRefreshSchemasStatusResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RefreshSchemasStatus", required: false, type: .structure)
        ]

        /// The status of the schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct DescribeReplicationInstanceTaskLogsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(marker: String? = nil, maxRecords: Int? = nil, replicationInstanceArn: String) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DescribeReplicationInstanceTaskLogsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceTaskLogs", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// An array of replication task log metadata. Each member of the array contains the replication task name, ARN, and task log size (in bytes). 
        public let replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]?

        public init(marker: String? = nil, replicationInstanceArn: String? = nil, replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]? = nil) {
            self.marker = marker
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceTaskLogs = "ReplicationInstanceTaskLogs"
        }
    }

    public struct DescribeReplicationInstancesMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// Filters applied to replication instances. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationInstancesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstances", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The replication instances described.
        public let replicationInstances: [ReplicationInstance]?

        public init(marker: String? = nil, replicationInstances: [ReplicationInstance]? = nil) {
            self.marker = marker
            self.replicationInstances = replicationInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationInstances = "ReplicationInstances"
        }
    }

    public struct DescribeReplicationSubnetGroupsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// Filters applied to replication subnet groups. Valid filter names: replication-subnet-group-id
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationSubnetGroupsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroups", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// A description of the replication subnet groups.
        public let replicationSubnetGroups: [ReplicationSubnetGroup]?

        public init(marker: String? = nil, replicationSubnetGroups: [ReplicationSubnetGroup]? = nil) {
            self.marker = marker
            self.replicationSubnetGroups = replicationSubnetGroups
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationSubnetGroups = "ReplicationSubnetGroups"
        }
    }

    public struct DescribeReplicationTaskAssessmentResultsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input parameter is specified, the API returns only one result and ignore the values of the MaxRecords and Marker parameters. 
        public let replicationTaskArn: String?

        public init(marker: String? = nil, maxRecords: Int? = nil, replicationTaskArn: String? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeReplicationTaskAssessmentResultsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BucketName", required: false, type: .string), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskAssessmentResults", required: false, type: .list)
        ]

        /// - The Amazon S3 bucket where the task assessment report is located. 
        public let bucketName: String?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The task assessment report. 
        public let replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]?

        public init(bucketName: String? = nil, marker: String? = nil, replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]? = nil) {
            self.bucketName = bucketName
            self.marker = marker
            self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case marker = "Marker"
            case replicationTaskAssessmentResults = "ReplicationTaskAssessmentResults"
        }
    }

    public struct DescribeReplicationTaskAssessmentRunsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// Filters applied to the premigration assessment runs described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, replication-instance-arn, status 
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationTaskAssessmentRunsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskAssessmentRuns", required: false, type: .list)
        ]

        /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?
        /// One or more premigration assessment runs as specified by Filters.
        public let replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]?

        public init(marker: String? = nil, replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]? = nil) {
            self.marker = marker
            self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskAssessmentRuns = "ReplicationTaskAssessmentRuns"
        }
    }

    public struct DescribeReplicationTaskIndividualAssessmentsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// Filters applied to the individual assessments described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, status 
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationTaskIndividualAssessmentsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIndividualAssessments", required: false, type: .list)
        ]

        /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?
        /// One or more individual assessments as specified by Filters.
        public let replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]?

        public init(marker: String? = nil, replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]? = nil) {
            self.marker = marker
            self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskIndividualAssessments = "ReplicationTaskIndividualAssessments"
        }
    }

    public struct DescribeReplicationTasksMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "WithoutSettings", required: false, type: .boolean)
        ]

        /// Filters applied to replication tasks. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// An option to set to avoid returning information about settings. Use this to reduce overhead when setting information is too large. To use this option, choose true; otherwise, choose false (the default).
        public let withoutSettings: Bool?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, withoutSettings: Bool? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.withoutSettings = withoutSettings
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case withoutSettings = "WithoutSettings"
        }
    }

    public struct DescribeReplicationTasksResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTasks", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// A description of the replication tasks.
        public let replicationTasks: [ReplicationTask]?

        public init(marker: String? = nil, replicationTasks: [ReplicationTask]? = nil) {
            self.marker = marker
            self.replicationTasks = replicationTasks
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTasks = "ReplicationTasks"
        }
    }

    public struct DescribeSchemasMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(endpointArn: String, marker: String? = nil, maxRecords: Int? = nil) {
            self.endpointArn = endpointArn
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeSchemasResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "Schemas", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The described schema.
        public let schemas: [String]?

        public init(marker: String? = nil, schemas: [String]? = nil) {
            self.marker = marker
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case schemas = "Schemas"
        }
    }

    public struct DescribeTableStatisticsMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "MaxRecords", required: false, type: .integer), 
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string)
        ]

        /// Filters applied to table statistics. Valid filter names: schema-name | table-name | table-state A combination of filters creates an AND condition where each record matches all specified filters.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 500.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, replicationTaskArn: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeTableStatisticsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Marker", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string), 
            AWSShapeMember(label: "TableStatistics", required: false, type: .list)
        ]

        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. 
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The table statistics.
        public let tableStatistics: [TableStatistics]?

        public init(marker: String? = nil, replicationTaskArn: String? = nil, tableStatistics: [TableStatistics]? = nil) {
            self.marker = marker
            self.replicationTaskArn = replicationTaskArn
            self.tableStatistics = tableStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskArn = "ReplicationTaskArn"
            case tableStatistics = "TableStatistics"
        }
    }

    public struct DmsTransferSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BucketName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string)
        ]

        ///  The name of the S3 bucket to use. 
        public let bucketName: String?
        ///  The IAM role that has permission to access the Amazon S3 bucket. 
        public let serviceAccessRoleArn: String?

        public init(bucketName: String? = nil, serviceAccessRoleArn: String? = nil) {
            self.bucketName = bucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct DynamoDbSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceAccessRoleArn", required: true, type: .string)
        ]

        ///  The Amazon Resource Name (ARN) used by the service access IAM role. 
        public let serviceAccessRoleArn: String

        public init(serviceAccessRoleArn: String) {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct ElasticsearchSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointUri", required: true, type: .string), 
            AWSShapeMember(label: "ErrorRetryDuration", required: false, type: .integer), 
            AWSShapeMember(label: "FullLoadErrorPercentage", required: false, type: .integer), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: true, type: .string)
        ]

        /// The endpoint for the Elasticsearch cluster.
        public let endpointUri: String
        /// The maximum number of seconds for which DMS retries failed API requests to the Elasticsearch cluster.
        public let errorRetryDuration: Int?
        /// The maximum percentage of records that can fail to be written before a full load operation stops. 
        public let fullLoadErrorPercentage: Int?
        /// The Amazon Resource Name (ARN) used by service to access the IAM role.
        public let serviceAccessRoleArn: String

        public init(endpointUri: String, errorRetryDuration: Int? = nil, fullLoadErrorPercentage: Int? = nil, serviceAccessRoleArn: String) {
            self.endpointUri = endpointUri
            self.errorRetryDuration = errorRetryDuration
            self.fullLoadErrorPercentage = fullLoadErrorPercentage
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointUri = "EndpointUri"
            case errorRetryDuration = "ErrorRetryDuration"
            case fullLoadErrorPercentage = "FullLoadErrorPercentage"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct Endpoint: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "DmsTransferSettings", required: false, type: .structure), 
            AWSShapeMember(label: "DynamoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "ElasticsearchSettings", required: false, type: .structure), 
            AWSShapeMember(label: "EndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "EndpointIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "EndpointType", required: false, type: .enum), 
            AWSShapeMember(label: "EngineDisplayName", required: false, type: .string), 
            AWSShapeMember(label: "EngineName", required: false, type: .string), 
            AWSShapeMember(label: "ExternalId", required: false, type: .string), 
            AWSShapeMember(label: "ExternalTableDefinition", required: false, type: .string), 
            AWSShapeMember(label: "ExtraConnectionAttributes", required: false, type: .string), 
            AWSShapeMember(label: "IBMDb2Settings", required: false, type: .structure), 
            AWSShapeMember(label: "KafkaSettings", required: false, type: .structure), 
            AWSShapeMember(label: "KinesisSettings", required: false, type: .structure), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "MicrosoftSQLServerSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MongoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MySQLSettings", required: false, type: .structure), 
            AWSShapeMember(label: "NeptuneSettings", required: false, type: .structure), 
            AWSShapeMember(label: "OracleSettings", required: false, type: .structure), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "PostgreSQLSettings", required: false, type: .structure), 
            AWSShapeMember(label: "RedshiftSettings", required: false, type: .structure), 
            AWSShapeMember(label: "S3Settings", required: false, type: .structure), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SslMode", required: false, type: .enum), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "SybaseSettings", required: false, type: .structure), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public let certificateArn: String?
        /// The name of the database at the endpoint.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Possible settings include the following:    ServiceAccessRoleArn - The IAM role that has permission to access the Amazon S3 bucket.    BucketName - The name of the S3 bucket to use.    CompressionType - An optional parameter to use GZIP to compress the target files. To use GZIP, set this value to NONE (the default). To keep the files uncompressed, don't use this value.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string,CompressionType=string  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", "CompressionType": "none"|"gzip" }  
        public let dmsTransferSettings: DmsTransferSettings?
        /// The settings for the DynamoDB target endpoint. For more information, see the DynamoDBSettings structure.
        public let dynamoDbSettings: DynamoDbSettings?
        /// The settings for the Elasticsearch source endpoint. For more information, see the ElasticsearchSettings structure.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora," this value would be "Amazon Aurora MySQL."
        public let engineDisplayName: String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", and "neptune".
        public let engineName: String?
        ///  Value returned by a call to CreateEndpoint that can be used for cross-account validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a cross-account. 
        public let externalId: String?
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional connection attributes used to connect to the endpoint.
        public let extraConnectionAttributes: String?
        /// The settings for the IBM Db2 LUW source endpoint. For more information, see the IBMDb2Settings structure. 
        public let iBMDb2Settings: IBMDb2Settings?
        /// The settings for the Apache Kafka target endpoint. For more information, see the KafkaSettings structure.
        public let kafkaSettings: KafkaSettings?
        /// The settings for the Amazon Kinesis target endpoint. For more information, see the KinesisSettings structure.
        public let kinesisSettings: KinesisSettings?
        /// An AWS KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS Region.
        public let kmsKeyId: String?
        /// The settings for the Microsoft SQL Server source and target endpoint. For more information, see the MicrosoftSQLServerSettings structure.
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// The settings for the MongoDB source endpoint. For more information, see the MongoDbSettings structure.
        public let mongoDbSettings: MongoDbSettings?
        /// The settings for the MySQL source and target endpoint. For more information, see the MySQLSettings structure.
        public let mySQLSettings: MySQLSettings?
        /// The settings for the Amazon Neptune target endpoint. For more information, see the NeptuneSettings structure.
        public let neptuneSettings: NeptuneSettings?
        /// The settings for the Oracle source and target endpoint. For more information, see the OracleSettings structure.
        public let oracleSettings: OracleSettings?
        /// The port value used to access the endpoint.
        public let port: Int?
        /// The settings for the PostgreSQL source and target endpoint. For more information, see the PostgreSQLSettings structure.
        public let postgreSQLSettings: PostgreSQLSettings?
        /// Settings for the Amazon Redshift endpoint.
        public let redshiftSettings: RedshiftSettings?
        /// The settings for the S3 target endpoint. For more information, see the S3Settings structure.
        public let s3Settings: S3Settings?
        /// The name of the server at the endpoint.
        public let serverName: String?
        /// The Amazon Resource Name (ARN) used by the service access IAM role.
        public let serviceAccessRoleArn: String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public let sslMode: DmsSslModeValue?
        /// The status of the endpoint.
        public let status: String?
        /// The settings for the SAP ASE source and target endpoint. For more information, see the SybaseSettings structure.
        public let sybaseSettings: SybaseSettings?
        /// The user name used to connect to the endpoint.
        public let username: String?

        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointArn: String? = nil, endpointIdentifier: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, engineDisplayName: String? = nil, engineName: String? = nil, externalId: String? = nil, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, iBMDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, kmsKeyId: String? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redshiftSettings: RedshiftSettings? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, status: String? = nil, sybaseSettings: SybaseSettings? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.externalId = externalId
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.iBMDb2Settings = iBMDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.status = status
            self.sybaseSettings = sybaseSettings
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineDisplayName = "EngineDisplayName"
            case engineName = "EngineName"
            case externalId = "ExternalId"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case iBMDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case kmsKeyId = "KmsKeyId"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redshiftSettings = "RedshiftSettings"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case status = "Status"
            case sybaseSettings = "SybaseSettings"
            case username = "Username"
        }
    }

    public struct Event: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Date", required: false, type: .timestamp), 
            AWSShapeMember(label: "EventCategories", required: false, type: .list), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "SourceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .enum)
        ]

        /// The date of the event.
        public let date: TimeStamp?
        /// The event categories available for the specified source type.
        public let eventCategories: [String]?
        /// The event message.
        public let message: String?
        ///  The identifier of an event source.
        public let sourceIdentifier: String?
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | endpoint | replication-task
        public let sourceType: SourceType?

        public init(date: TimeStamp? = nil, eventCategories: [String]? = nil, message: String? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil) {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case eventCategories = "EventCategories"
            case message = "Message"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
        }
    }

    public struct EventCategoryGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventCategories", required: false, type: .list), 
            AWSShapeMember(label: "SourceType", required: false, type: .string)
        ]

        ///  A list of event categories from a source type that you've chosen.
        public let eventCategories: [String]?
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | replication-task
        public let sourceType: String?

        public init(eventCategories: [String]? = nil, sourceType: String? = nil) {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategories = "EventCategories"
            case sourceType = "SourceType"
        }
    }

    public struct EventSubscription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CustomerAwsId", required: false, type: .string), 
            AWSShapeMember(label: "CustSubscriptionId", required: false, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "EventCategoriesList", required: false, type: .list), 
            AWSShapeMember(label: "SnsTopicArn", required: false, type: .string), 
            AWSShapeMember(label: "SourceIdsList", required: false, type: .list), 
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "SubscriptionCreationTime", required: false, type: .string)
        ]

        /// The AWS customer account associated with the AWS DMS event notification subscription.
        public let customerAwsId: String?
        /// The AWS DMS event notification subscription Id.
        public let custSubscriptionId: String?
        /// Boolean value that indicates if the event subscription is enabled.
        public let enabled: Bool?
        /// A lists of event categories.
        public let eventCategoriesList: [String]?
        /// The topic ARN of the AWS DMS event notification subscription.
        public let snsTopicArn: String?
        /// A list of source Ids for the event subscription.
        public let sourceIdsList: [String]?
        ///  The type of AWS DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | replication-task
        public let sourceType: String?
        /// The status of the AWS DMS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that AWS DMS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public let status: String?
        /// The time the AWS DMS event notification subscription was created.
        public let subscriptionCreationTime: String?

        public init(customerAwsId: String? = nil, custSubscriptionId: String? = nil, enabled: Bool? = nil, eventCategoriesList: [String]? = nil, snsTopicArn: String? = nil, sourceIdsList: [String]? = nil, sourceType: String? = nil, status: String? = nil, subscriptionCreationTime: String? = nil) {
            self.customerAwsId = customerAwsId
            self.custSubscriptionId = custSubscriptionId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }

        private enum CodingKeys: String, CodingKey {
            case customerAwsId = "CustomerAwsId"
            case custSubscriptionId = "CustSubscriptionId"
            case enabled = "Enabled"
            case eventCategoriesList = "EventCategoriesList"
            case snsTopicArn = "SnsTopicArn"
            case sourceIdsList = "SourceIdsList"
            case sourceType = "SourceType"
            case status = "Status"
            case subscriptionCreationTime = "SubscriptionCreationTime"
        }
    }

    public struct Filter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Values", required: true, type: .list)
        ]

        /// The name of the filter as specified for a Describe* or similar operation.
        public let name: String
        /// The filter value, which can specify one or more values used to narrow the returned results.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct IBMDb2Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(databaseName: String? = nil, password: String? = nil, port: Int? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct ImportCertificateMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "CertificatePem", required: false, type: .string), 
            AWSShapeMember(label: "CertificateWallet", required: false, type: .blob), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let certificateIdentifier: String
        /// The contents of a .pem file, which contains an X.509 certificate.
        public let certificatePem: String?
        /// The location of an imported Oracle Wallet certificate for use with SSL.
        public let certificateWallet: Data?
        /// The tags associated with the certificate.
        public let tags: [Tag]?

        public init(certificateIdentifier: String, certificatePem: String? = nil, certificateWallet: Data? = nil, tags: [Tag]? = nil) {
            self.certificateIdentifier = certificateIdentifier
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case certificateIdentifier = "CertificateIdentifier"
            case certificatePem = "CertificatePem"
            case certificateWallet = "CertificateWallet"
            case tags = "Tags"
        }
    }

    public struct ImportCertificateResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Certificate", required: false, type: .structure)
        ]

        /// The certificate to be uploaded.
        public let certificate: Certificate?

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct KafkaSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Broker", required: false, type: .string), 
            AWSShapeMember(label: "IncludeControlDetails", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludeNullAndEmpty", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludePartitionValue", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludeTableAlterOperations", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludeTransactionDetails", required: false, type: .boolean), 
            AWSShapeMember(label: "MessageFormat", required: false, type: .enum), 
            AWSShapeMember(label: "MessageMaxBytes", required: false, type: .integer), 
            AWSShapeMember(label: "PartitionIncludeSchemaTable", required: false, type: .boolean), 
            AWSShapeMember(label: "Topic", required: false, type: .string)
        ]

        /// The broker location and port of the Kafka broker that hosts your Kafka instance. Specify the broker in the form  broker-hostname-or-ip:port . For example, "ec2-12-345-678-901.compute-1.amazonaws.com:2345".
        public let broker: String?
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. The default is false.
        public let includeControlDetails: Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public let includeNullAndEmpty: Bool?
        /// Shows the partition value within the Kafka message output, unless the partition type is schema-table-type. The default is false.
        public let includePartitionValue: Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public let includeTableAlterOperations: Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public let includeTransactionDetails: Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public let messageFormat: MessageFormatValue?
        /// The maximum size in bytes for records created on the endpoint The default is 1,000,000.
        public let messageMaxBytes: Int?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. The default is false.
        public let partitionIncludeSchemaTable: Bool?
        /// The topic to which you migrate the data. If you don't specify a topic, AWS DMS specifies "kafka-default-topic" as the migration topic.
        public let topic: String?

        public init(broker: String? = nil, includeControlDetails: Bool? = nil, includeNullAndEmpty: Bool? = nil, includePartitionValue: Bool? = nil, includeTableAlterOperations: Bool? = nil, includeTransactionDetails: Bool? = nil, messageFormat: MessageFormatValue? = nil, messageMaxBytes: Int? = nil, partitionIncludeSchemaTable: Bool? = nil, topic: String? = nil) {
            self.broker = broker
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.messageMaxBytes = messageMaxBytes
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case broker = "Broker"
            case includeControlDetails = "IncludeControlDetails"
            case includeNullAndEmpty = "IncludeNullAndEmpty"
            case includePartitionValue = "IncludePartitionValue"
            case includeTableAlterOperations = "IncludeTableAlterOperations"
            case includeTransactionDetails = "IncludeTransactionDetails"
            case messageFormat = "MessageFormat"
            case messageMaxBytes = "MessageMaxBytes"
            case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
            case topic = "Topic"
        }
    }

    public struct KinesisSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IncludeControlDetails", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludeNullAndEmpty", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludePartitionValue", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludeTableAlterOperations", required: false, type: .boolean), 
            AWSShapeMember(label: "IncludeTransactionDetails", required: false, type: .boolean), 
            AWSShapeMember(label: "MessageFormat", required: false, type: .enum), 
            AWSShapeMember(label: "PartitionIncludeSchemaTable", required: false, type: .boolean), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "StreamArn", required: false, type: .string)
        ]

        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is false.
        public let includeControlDetails: Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public let includeNullAndEmpty: Bool?
        /// Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. The default is false.
        public let includePartitionValue: Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public let includeTableAlterOperations: Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public let includeTransactionDetails: Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public let messageFormat: MessageFormatValue?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is false.
        public let partitionIncludeSchemaTable: Bool?
        /// The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role that AWS DMS uses to write to the Kinesis data stream.
        public let serviceAccessRoleArn: String?
        /// The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.
        public let streamArn: String?

        public init(includeControlDetails: Bool? = nil, includeNullAndEmpty: Bool? = nil, includePartitionValue: Bool? = nil, includeTableAlterOperations: Bool? = nil, includeTransactionDetails: Bool? = nil, messageFormat: MessageFormatValue? = nil, partitionIncludeSchemaTable: Bool? = nil, serviceAccessRoleArn: String? = nil, streamArn: String? = nil) {
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.streamArn = streamArn
        }

        private enum CodingKeys: String, CodingKey {
            case includeControlDetails = "IncludeControlDetails"
            case includeNullAndEmpty = "IncludeNullAndEmpty"
            case includePartitionValue = "IncludePartitionValue"
            case includeTableAlterOperations = "IncludeTableAlterOperations"
            case includeTransactionDetails = "IncludeTransactionDetails"
            case messageFormat = "MessageFormat"
            case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case streamArn = "StreamArn"
        }
    }

    public struct ListTagsForResourceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the AWS DMS resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TagList", required: false, type: .list)
        ]

        /// A list of tags for the resource.
        public let tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct MicrosoftSQLServerSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(databaseName: String? = nil, password: String? = nil, port: Int? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct ModifyEndpointMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CertificateArn", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "DmsTransferSettings", required: false, type: .structure), 
            AWSShapeMember(label: "DynamoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "ElasticsearchSettings", required: false, type: .structure), 
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "EndpointIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "EndpointType", required: false, type: .enum), 
            AWSShapeMember(label: "EngineName", required: false, type: .string), 
            AWSShapeMember(label: "ExternalTableDefinition", required: false, type: .string), 
            AWSShapeMember(label: "ExtraConnectionAttributes", required: false, type: .string), 
            AWSShapeMember(label: "IBMDb2Settings", required: false, type: .structure), 
            AWSShapeMember(label: "KafkaSettings", required: false, type: .structure), 
            AWSShapeMember(label: "KinesisSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MicrosoftSQLServerSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MongoDbSettings", required: false, type: .structure), 
            AWSShapeMember(label: "MySQLSettings", required: false, type: .structure), 
            AWSShapeMember(label: "NeptuneSettings", required: false, type: .structure), 
            AWSShapeMember(label: "OracleSettings", required: false, type: .structure), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "PostgreSQLSettings", required: false, type: .structure), 
            AWSShapeMember(label: "RedshiftSettings", required: false, type: .structure), 
            AWSShapeMember(label: "S3Settings", required: false, type: .structure), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "SslMode", required: false, type: .enum), 
            AWSShapeMember(label: "SybaseSettings", required: false, type: .structure), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The name of the endpoint database.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Attributes include the following:   serviceAccessRoleArn - The AWS Identity and Access Management (IAM) role that has permission to access the Amazon S3 bucket.   BucketName - The name of the S3 bucket to use.   compressionType - An optional parameter to use GZIP to compress the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string ,BucketName=string,CompressionType=string  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", "CompressionType": "none"|"gzip" }  
        public let dmsTransferSettings: DmsTransferSettings?
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see Using Object Mapping to Migrate Data to DynamoDB in the AWS Database Migration Service User Guide. 
        public let dynamoDbSettings: DynamoDbSettings?
        /// Settings in JSON format for the target Elasticsearch endpoint. For more information about the available settings, see Extra Connection Attributes When Using Elasticsearch as a Target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The type of engine for the endpoint. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", and "neptune".
        public let engineName: String?
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional attributes associated with the connection. To reset this parameter, pass the empty string ("") as an argument.
        public let extraConnectionAttributes: String?
        /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see Extra connection attributes when using Db2 LUW as a source for AWS DMS in the AWS Database Migration Service User Guide. 
        public let iBMDb2Settings: IBMDb2Settings?
        /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see Using Apache Kafka as a Target for AWS Database Migration Service in the AWS Database Migration Service User Guide. 
        public let kafkaSettings: KafkaSettings?
        /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see Using Amazon Kinesis Data Streams as a Target for AWS Database Migration Service in the AWS Database Migration Service User Guide. 
        public let kinesisSettings: KinesisSettings?
        /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see Extra connection attributes when using SQL Server as a source for AWS DMS and  Extra connection attributes when using SQL Server as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the configuration properties section in  Using MongoDB as a Target for AWS Database Migration Service in the AWS Database Migration Service User Guide. 
        public let mongoDbSettings: MongoDbSettings?
        /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see Extra connection attributes when using MySQL as a source for AWS DMS and Extra connection attributes when using a MySQL-compatible database as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let mySQLSettings: MySQLSettings?
        /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see Specifying Endpoint Settings for Amazon Neptune as a Target in the AWS Database Migration Service User Guide. 
        public let neptuneSettings: NeptuneSettings?
        /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see Extra connection attributes when using Oracle as a source for AWS DMS and  Extra connection attributes when using Oracle as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let oracleSettings: OracleSettings?
        /// The password to be used to login to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int?
        /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see Extra connection attributes when using PostgreSQL as a source for AWS DMS and  Extra connection attributes when using PostgreSQL as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let postgreSQLSettings: PostgreSQLSettings?
        public let redshiftSettings: RedshiftSettings?
        /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see Extra Connection Attributes When Using Amazon S3 as a Target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let s3Settings: S3Settings?
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        ///  The Amazon Resource Name (ARN) for the service access role you want to use to modify the endpoint. 
        public let serviceAccessRoleArn: String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public let sslMode: DmsSslModeValue?
        /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see Extra connection attributes when using SAP ASE as a source for AWS DMS and Extra connection attributes when using SAP ASE as a target for AWS DMS in the AWS Database Migration Service User Guide. 
        public let sybaseSettings: SybaseSettings?
        /// The user name to be used to login to the endpoint database.
        public let username: String?

        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointArn: String, endpointIdentifier: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, engineName: String? = nil, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, iBMDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, password: String? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redshiftSettings: RedshiftSettings? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, sybaseSettings: SybaseSettings? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.iBMDb2Settings = iBMDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.password = password
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.sybaseSettings = sybaseSettings
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineName = "EngineName"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case iBMDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case password = "Password"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redshiftSettings = "RedshiftSettings"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case sybaseSettings = "SybaseSettings"
            case username = "Username"
        }
    }

    public struct ModifyEndpointResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Endpoint", required: false, type: .structure)
        ]

        /// The modified endpoint.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct ModifyEventSubscriptionMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "EventCategories", required: false, type: .list), 
            AWSShapeMember(label: "SnsTopicArn", required: false, type: .string), 
            AWSShapeMember(label: "SourceType", required: false, type: .string), 
            AWSShapeMember(label: "SubscriptionName", required: true, type: .string)
        ]

        ///  A Boolean value; set to true to activate the subscription. 
        public let enabled: Bool?
        ///  A list of event categories for a source type that you want to subscribe to. Use the DescribeEventCategories action to see a list of event categories. 
        public let eventCategories: [String]?
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        public let snsTopicArn: String?
        ///  The type of AWS DMS resource that generates the events you want to subscribe to.  Valid values: replication-instance | replication-task
        public let sourceType: String?
        /// The name of the AWS DMS event notification subscription to be modified.
        public let subscriptionName: String

        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String? = nil, sourceType: String? = nil, subscriptionName: String) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct ModifyEventSubscriptionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventSubscription", required: false, type: .structure)
        ]

        /// The modified event subscription.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct ModifyReplicationInstanceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "AllowMajorVersionUpgrade", required: false, type: .boolean), 
            AWSShapeMember(label: "ApplyImmediately", required: false, type: .boolean), 
            AWSShapeMember(label: "AutoMinorVersionUpgrade", required: false, type: .boolean), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "VpcSecurityGroupIds", required: false, type: .list)
        ]

        /// The amount of storage (in gigabytes) to be allocated for the replication instance.
        public let allocatedStorage: Int?
        /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage, and the change is asynchronously applied as soon as possible. This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
        public let allowMajorVersionUpgrade: Bool?
        /// Indicates whether the changes should be applied immediately or during the next maintenance window.
        public let applyImmediately: Bool?
        /// A value that indicates that minor version upgrades are applied automatically to the replication instance during the maintenance window. Changing this parameter doesn't result in an outage, except in the case dsecribed following. The change is asynchronously applied as soon as possible.  An outage does result if these factors apply:    This parameter is set to true during the maintenance window.   A newer minor version is available.    AWS DMS has enabled automatic patching for the given engine version.   
        public let autoMinorVersionUpgrade: Bool?
        /// The engine version number of the replication instance. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public let engineVersion: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
        public let preferredMaintenanceWindow: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right AWS DMS replication instance for your migration. 
        public let replicationInstanceClass: String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance. 
        public let vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, allowMajorVersionUpgrade: Bool? = nil, applyImmediately: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil, engineVersion: String? = nil, multiAZ: Bool? = nil, preferredMaintenanceWindow: String? = nil, replicationInstanceArn: String, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.applyImmediately = applyImmediately
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
            case applyImmediately = "ApplyImmediately"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case engineVersion = "EngineVersion"
            case multiAZ = "MultiAZ"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct ModifyReplicationInstanceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .structure)
        ]

        /// The modified replication instance.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct ModifyReplicationSubnetGroupMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroupDescription", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: true, type: .string), 
            AWSShapeMember(label: "SubnetIds", required: true, type: .list)
        ]

        /// A description for the replication instance subnet group.
        public let replicationSubnetGroupDescription: String?
        /// The name of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String
        /// A list of subnet IDs.
        public let subnetIds: [String]

        public init(replicationSubnetGroupDescription: String? = nil, replicationSubnetGroupIdentifier: String, subnetIds: [String]) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetIds = "SubnetIds"
        }
    }

    public struct ModifyReplicationSubnetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroup", required: false, type: .structure)
        ]

        /// The modified replication subnet group.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct ModifyReplicationTaskMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CdcStartPosition", required: false, type: .string), 
            AWSShapeMember(label: "CdcStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CdcStopPosition", required: false, type: .string), 
            AWSShapeMember(label: "MigrationType", required: false, type: .enum), 
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskSettings", required: false, type: .string), 
            AWSShapeMember(label: "TableMappings", required: false, type: .string), 
            AWSShapeMember(label: "TaskData", required: false, type: .string)
        ]

        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error.  The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for AWS DMS. 
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
        public let cdcStartTime: TimeStamp?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc 
        public let migrationType: MigrationTypeValue?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String
        /// The replication task identifier. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public let replicationTaskIdentifier: String?
        /// JSON file that contains settings for the task, such as task metadata settings.
        public let replicationTaskSettings: String?
        /// When using the AWS CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with file://. When working with the DMS API, provide the JSON as the parameter value, for example: --table-mappings file://mappingfile.json 
        public let tableMappings: String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the AWS Database Migration Service User Guide. 
        public let taskData: String?

        public init(cdcStartPosition: String? = nil, cdcStartTime: TimeStamp? = nil, cdcStopPosition: String? = nil, migrationType: MigrationTypeValue? = nil, replicationTaskArn: String, replicationTaskIdentifier: String? = nil, replicationTaskSettings: String? = nil, tableMappings: String? = nil, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.migrationType = migrationType
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.tableMappings = tableMappings
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case migrationType = "MigrationType"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case tableMappings = "TableMappings"
            case taskData = "TaskData"
        }
    }

    public struct ModifyReplicationTaskResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]

        /// The replication task that was modified.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct MongoDbSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AuthMechanism", required: false, type: .enum), 
            AWSShapeMember(label: "AuthSource", required: false, type: .string), 
            AWSShapeMember(label: "AuthType", required: false, type: .enum), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "DocsToInvestigate", required: false, type: .string), 
            AWSShapeMember(label: "ExtractDocId", required: false, type: .string), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "NestingLevel", required: false, type: .enum), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        ///  The authentication mechanism you use to access the MongoDB source endpoint. For the default value, in MongoDB version 2.x, "default" is "mongodb_cr". For MongoDB version 3.x or later, "default" is "scram_sha_1". This setting isn't used when AuthType is set to "no".
        public let authMechanism: AuthMechanismValue?
        ///  The MongoDB database name. This setting isn't used when AuthType is set to "no".  The default is "admin".
        public let authSource: String?
        ///  The authentication type you use to access the MongoDB source endpoint. When when set to "no", user name and password parameters are not used and can be empty. 
        public let authType: AuthTypeValue?
        ///  The database name on the MongoDB source endpoint. 
        public let databaseName: String?
        ///  Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one".  Must be a positive value greater than 0. Default value is 1000.
        public let docsToInvestigate: String?
        ///  Specifies the document ID. Use this setting when NestingLevel is set to "none".  Default value is "false". 
        public let extractDocId: String?
        /// The AWS KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS Region.
        public let kmsKeyId: String?
        ///  Specifies either document or table mode.  Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public let nestingLevel: NestingLevelValue?
        ///  The password for the user account you use to access the MongoDB source endpoint. 
        public let password: String?
        ///  The port value for the MongoDB source endpoint. 
        public let port: Int?
        ///  The name of the server on the MongoDB source endpoint. 
        public let serverName: String?
        /// The user name you use to access the MongoDB source endpoint. 
        public let username: String?

        public init(authMechanism: AuthMechanismValue? = nil, authSource: String? = nil, authType: AuthTypeValue? = nil, databaseName: String? = nil, docsToInvestigate: String? = nil, extractDocId: String? = nil, kmsKeyId: String? = nil, nestingLevel: NestingLevelValue? = nil, password: String? = nil, port: Int? = nil, serverName: String? = nil, username: String? = nil) {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case authMechanism = "AuthMechanism"
            case authSource = "AuthSource"
            case authType = "AuthType"
            case databaseName = "DatabaseName"
            case docsToInvestigate = "DocsToInvestigate"
            case extractDocId = "ExtractDocId"
            case kmsKeyId = "KmsKeyId"
            case nestingLevel = "NestingLevel"
            case password = "Password"
            case port = "Port"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct MySQLSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(databaseName: String? = nil, password: String? = nil, port: Int? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct NeptuneSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorRetryDuration", required: false, type: .integer), 
            AWSShapeMember(label: "IamAuthEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "MaxFileSize", required: false, type: .integer), 
            AWSShapeMember(label: "MaxRetryCount", required: false, type: .integer), 
            AWSShapeMember(label: "S3BucketFolder", required: true, type: .string), 
            AWSShapeMember(label: "S3BucketName", required: true, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string)
        ]

        /// The number of milliseconds for AWS DMS to wait to retry a bulk-load of migrated graph data to the Neptune target database before raising an error. The default is 250.
        public let errorRetryDuration: Int?
        /// If you want AWS Identity and Access Management (IAM) authorization enabled for this endpoint, set this parameter to true. Then attach the appropriate IAM policy document to your service role specified by ServiceAccessRoleArn. The default is false.
        public let iamAuthEnabled: Bool?
        /// The maximum size in kilobytes of migrated graph data stored in a .csv file before AWS DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the bulk load is successful, AWS DMS clears the bucket, ready to store the next batch of migrated graph data.
        public let maxFileSize: Int?
        /// The number of times for AWS DMS to retry a bulk load of migrated graph data to the Neptune target database before raising an error. The default is 5.
        public let maxRetryCount: Int?
        /// A folder path where you want AWS DMS to store migrated graph data in the S3 bucket specified by S3BucketName 
        public let s3BucketFolder: String
        /// The name of the Amazon S3 bucket where AWS DMS can temporarily store migrated graph data in .csv files before bulk-loading it to the Neptune target database. AWS DMS maps the SQL source data to graph data before storing it in these .csv files.
        public let s3BucketName: String
        /// The Amazon Resource Name (ARN) of the service role that you created for the Neptune target endpoint. For more information, see Creating an IAM Service Role for Accessing Amazon Neptune as a Target in the AWS Database Migration Service User Guide.  
        public let serviceAccessRoleArn: String?

        public init(errorRetryDuration: Int? = nil, iamAuthEnabled: Bool? = nil, maxFileSize: Int? = nil, maxRetryCount: Int? = nil, s3BucketFolder: String, s3BucketName: String, serviceAccessRoleArn: String? = nil) {
            self.errorRetryDuration = errorRetryDuration
            self.iamAuthEnabled = iamAuthEnabled
            self.maxFileSize = maxFileSize
            self.maxRetryCount = maxRetryCount
            self.s3BucketFolder = s3BucketFolder
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorRetryDuration = "ErrorRetryDuration"
            case iamAuthEnabled = "IamAuthEnabled"
            case maxFileSize = "MaxFileSize"
            case maxRetryCount = "MaxRetryCount"
            case s3BucketFolder = "S3BucketFolder"
            case s3BucketName = "S3BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct OracleSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AsmPassword", required: false, type: .string), 
            AWSShapeMember(label: "AsmServer", required: false, type: .string), 
            AWSShapeMember(label: "AsmUser", required: false, type: .string), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "SecurityDbEncryption", required: false, type: .string), 
            AWSShapeMember(label: "SecurityDbEncryptionName", required: false, type: .string), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password. You can set this value from the  asm_user_password  value. You set this value as part of the comma-separated value that you set to the Password request parameter when you create the endpoint to access transaction logs using Binary Reader. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmPassword: String?
        /// For an Oracle source endpoint, your ASM server address. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmServer: String?
        /// For an Oracle source endpoint, your ASM user name. You can set this value from the asm_user value. You set asm_user as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmUser: String?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// For an Oracle source endpoint, the transparent data encryption (TDE) password required by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the  TDE_Password  part of the comma-separated value you set to the Password request parameter when you create the endpoint. The SecurityDbEncryptian setting is related to this SecurityDbEncryptionName setting. For more information, see  Supported encryption methods for using Oracle as a source for AWS DMS in the AWS Database Migration Service User Guide. 
        public let securityDbEncryption: String?
        /// For an Oracle source endpoint, the name of a key used for the transparent data encryption (TDE) of the columns and tablespaces in an Oracle source database that is encrypted using TDE. The key value is the value of the SecurityDbEncryption setting. For more information on setting the key name value of SecurityDbEncryptionName, see the information and example for setting the securityDbEncryptionName extra connection attribute in  Supported encryption methods for using Oracle as a source for AWS DMS in the AWS Database Migration Service User Guide.
        public let securityDbEncryptionName: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(asmPassword: String? = nil, asmServer: String? = nil, asmUser: String? = nil, databaseName: String? = nil, password: String? = nil, port: Int? = nil, securityDbEncryption: String? = nil, securityDbEncryptionName: String? = nil, serverName: String? = nil, username: String? = nil) {
            self.asmPassword = asmPassword
            self.asmServer = asmServer
            self.asmUser = asmUser
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.securityDbEncryption = securityDbEncryption
            self.securityDbEncryptionName = securityDbEncryptionName
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case asmPassword = "AsmPassword"
            case asmServer = "AsmServer"
            case asmUser = "AsmUser"
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case securityDbEncryption = "SecurityDbEncryption"
            case securityDbEncryptionName = "SecurityDbEncryptionName"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct OrderableReplicationInstance: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AvailabilityZones", required: false, type: .list), 
            AWSShapeMember(label: "DefaultAllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "IncludedAllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "MaxAllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "MinAllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "ReleaseStatus", required: false, type: .enum), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string), 
            AWSShapeMember(label: "StorageType", required: false, type: .string)
        ]

        /// List of Availability Zones for this replication instance.
        public let availabilityZones: [String]?
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public let defaultAllocatedStorage: Int?
        /// The version of the replication engine.
        public let engineVersion: String?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let includedAllocatedStorage: Int?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let maxAllocatedStorage: Int?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let minAllocatedStorage: Int?
        /// The value returned when the specified EngineVersion of the replication instance is in Beta or test mode. This indicates some features might not work as expected.  AWS DMS supports the ReleaseStatus parameter in versions 3.1.4 and later. 
        public let releaseStatus: ReleaseStatusValues?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right AWS DMS replication instance for your migration. 
        public let replicationInstanceClass: String?
        /// The type of storage used by the replication instance.
        public let storageType: String?

        public init(availabilityZones: [String]? = nil, defaultAllocatedStorage: Int? = nil, engineVersion: String? = nil, includedAllocatedStorage: Int? = nil, maxAllocatedStorage: Int? = nil, minAllocatedStorage: Int? = nil, releaseStatus: ReleaseStatusValues? = nil, replicationInstanceClass: String? = nil, storageType: String? = nil) {
            self.availabilityZones = availabilityZones
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.engineVersion = engineVersion
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
            self.minAllocatedStorage = minAllocatedStorage
            self.releaseStatus = releaseStatus
            self.replicationInstanceClass = replicationInstanceClass
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case defaultAllocatedStorage = "DefaultAllocatedStorage"
            case engineVersion = "EngineVersion"
            case includedAllocatedStorage = "IncludedAllocatedStorage"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case minAllocatedStorage = "MinAllocatedStorage"
            case releaseStatus = "ReleaseStatus"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case storageType = "StorageType"
        }
    }

    public struct PendingMaintenanceAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Action", required: false, type: .string), 
            AWSShapeMember(label: "AutoAppliedAfterDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "CurrentApplyDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Description", required: false, type: .string), 
            AWSShapeMember(label: "ForcedApplyDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "OptInStatus", required: false, type: .string)
        ]

        /// The type of pending maintenance action that is available for the resource.
        public let action: String?
        /// The date of the maintenance window when the action is to be applied. The maintenance action is applied to the resource during its first maintenance window after this date. If this date is specified, any next-maintenance opt-in requests are ignored.
        public let autoAppliedAfterDate: TimeStamp?
        /// The effective date when the pending maintenance action will be applied to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API operation, and also the AutoAppliedAfterDate and ForcedApplyDate parameter values. This value is blank if an opt-in request has not been received and nothing has been specified for AutoAppliedAfterDate or ForcedApplyDate.
        public let currentApplyDate: TimeStamp?
        /// A description providing more detail about the maintenance action.
        public let description: String?
        /// The date when the maintenance action will be automatically applied. The maintenance action is applied to the resource on this date regardless of the maintenance window for the resource. If this date is specified, any immediate opt-in requests are ignored.
        public let forcedApplyDate: TimeStamp?
        /// The type of opt-in request that has been received for the resource.
        public let optInStatus: String?

        public init(action: String? = nil, autoAppliedAfterDate: TimeStamp? = nil, currentApplyDate: TimeStamp? = nil, description: String? = nil, forcedApplyDate: TimeStamp? = nil, optInStatus: String? = nil) {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case autoAppliedAfterDate = "AutoAppliedAfterDate"
            case currentApplyDate = "CurrentApplyDate"
            case description = "Description"
            case forcedApplyDate = "ForcedApplyDate"
            case optInStatus = "OptInStatus"
        }
    }

    public struct PostgreSQLSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(databaseName: String? = nil, password: String? = nil, port: Int? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct RebootReplicationInstanceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForceFailover", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]

        /// If this parameter is true, the reboot is conducted through a Multi-AZ failover. (If the instance isn't configured for Multi-AZ, then you can't specify true.)
        public let forceFailover: Bool?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(forceFailover: Bool? = nil, replicationInstanceArn: String) {
            self.forceFailover = forceFailover
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case forceFailover = "ForceFailover"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct RebootReplicationInstanceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstance", required: false, type: .structure)
        ]

        /// The replication instance that is being rebooted. 
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct RedshiftSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceptAnyDate", required: false, type: .boolean), 
            AWSShapeMember(label: "AfterConnectScript", required: false, type: .string), 
            AWSShapeMember(label: "BucketFolder", required: false, type: .string), 
            AWSShapeMember(label: "BucketName", required: false, type: .string), 
            AWSShapeMember(label: "ConnectionTimeout", required: false, type: .integer), 
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "DateFormat", required: false, type: .string), 
            AWSShapeMember(label: "EmptyAsNull", required: false, type: .boolean), 
            AWSShapeMember(label: "EncryptionMode", required: false, type: .enum), 
            AWSShapeMember(label: "FileTransferUploadStreams", required: false, type: .integer), 
            AWSShapeMember(label: "LoadTimeout", required: false, type: .integer), 
            AWSShapeMember(label: "MaxFileSize", required: false, type: .integer), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "RemoveQuotes", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplaceChars", required: false, type: .string), 
            AWSShapeMember(label: "ReplaceInvalidChars", required: false, type: .string), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "ServerSideEncryptionKmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "TimeFormat", required: false, type: .string), 
            AWSShapeMember(label: "TrimBlanks", required: false, type: .boolean), 
            AWSShapeMember(label: "TruncateColumns", required: false, type: .boolean), 
            AWSShapeMember(label: "Username", required: false, type: .string), 
            AWSShapeMember(label: "WriteBufferSize", required: false, type: .integer)
        ]

        /// A value that indicates to allow any date format, including invalid formats such as 00/00/00 00:00:00, to be loaded without generating an error. You can choose true or false (the default). This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT specification, Amazon Redshift inserts a NULL value into that field. 
        public let acceptAnyDate: Bool?
        /// Code to run after connecting. This parameter should contain the code itself, not the name of a file containing the code.
        public let afterConnectScript: String?
        /// The location where the comma-separated value (.csv) files are stored before being uploaded to the S3 bucket. 
        public let bucketFolder: String?
        /// The name of the S3 bucket you want to use
        public let bucketName: String?
        /// A value that sets the amount of time to wait (in milliseconds) before timing out, beginning from when you initially establish a connection.
        public let connectionTimeout: Int?
        /// The name of the Amazon Redshift data warehouse (service) that you are working with.
        public let databaseName: String?
        /// The date format that you are using. Valid values are auto (case-sensitive), your date format string enclosed in quotes, or NULL. If this parameter is left unset (NULL), it defaults to a format of 'YYYY-MM-DD'. Using auto recognizes most strings, even some that aren't supported when you use a date format string.  If your date and time values use formats different from each other, set this to auto. 
        public let dateFormat: String?
        /// A value that specifies whether AWS DMS should migrate empty CHAR and VARCHAR fields as NULL. A value of true sets empty CHAR and VARCHAR fields to null. The default is false.
        public let emptyAsNull: Bool?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS.   For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS.  To use SSE_S3, create an AWS Identity and Access Management (IAM) role with a policy that allows "arn:aws:s3:::*" to use the following actions: "s3:PutObject", "s3:ListBucket" 
        public let encryptionMode: EncryptionModeValue?
        /// The number of threads used to upload a single file. This parameter accepts a value from 1 through 64. It defaults to 10.
        public let fileTransferUploadStreams: Int?
        /// The amount of time to wait (in milliseconds) before timing out, beginning from when you begin loading.
        public let loadTimeout: Int?
        /// The maximum size (in KB) of any .csv file used to transfer data to Amazon Redshift. This accepts a value from 1 through 1,048,576. It defaults to 32,768 KB (32 MB).
        public let maxFileSize: Int?
        /// The password for the user named in the username property.
        public let password: String?
        /// The port number for Amazon Redshift. The default value is 5439.
        public let port: Int?
        /// A value that specifies to remove surrounding quotation marks from strings in the incoming data. All characters within the quotation marks, including delimiters, are retained. Choose true to remove quotation marks. The default is false.
        public let removeQuotes: Bool?
        /// A value that specifies to replaces the invalid characters specified in ReplaceInvalidChars, substituting the specified characters instead. The default is "?".
        public let replaceChars: String?
        /// A list of characters that you want to replace. Use with ReplaceChars.
        public let replaceInvalidChars: String?
        /// The name of the Amazon Redshift cluster you are using.
        public let serverName: String?
        /// The AWS KMS key ID. If you are using SSE_KMS for the EncryptionMode, provide this key ID. The key that you use needs an attached policy that enables IAM user permissions and allows use of the key.
        public let serverSideEncryptionKmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift service.
        public let serviceAccessRoleArn: String?
        /// The time format that you want to use. Valid values are auto (case-sensitive), 'timeformat_string', 'epochsecs', or 'epochmillisecs'. It defaults to 10. Using auto recognizes most strings, even some that aren't supported when you use a time format string.  If your date and time values use formats different from each other, set this parameter to auto. 
        public let timeFormat: String?
        /// A value that specifies to remove the trailing white space characters from a VARCHAR string. This parameter applies only to columns with a VARCHAR data type. Choose true to remove unneeded white space. The default is false.
        public let trimBlanks: Bool?
        /// A value that specifies to truncate data in columns to the appropriate number of characters, so that the data fits in the column. This parameter applies only to columns with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose true to truncate data. The default is false.
        public let truncateColumns: Bool?
        /// An Amazon Redshift user name for a registered user.
        public let username: String?
        /// The size of the write buffer to use in rows. Valid values range from 1 through 2,048. The default is 1,024. Use this setting to tune performance. 
        public let writeBufferSize: Int?

        public init(acceptAnyDate: Bool? = nil, afterConnectScript: String? = nil, bucketFolder: String? = nil, bucketName: String? = nil, connectionTimeout: Int? = nil, databaseName: String? = nil, dateFormat: String? = nil, emptyAsNull: Bool? = nil, encryptionMode: EncryptionModeValue? = nil, fileTransferUploadStreams: Int? = nil, loadTimeout: Int? = nil, maxFileSize: Int? = nil, password: String? = nil, port: Int? = nil, removeQuotes: Bool? = nil, replaceChars: String? = nil, replaceInvalidChars: String? = nil, serverName: String? = nil, serverSideEncryptionKmsKeyId: String? = nil, serviceAccessRoleArn: String? = nil, timeFormat: String? = nil, trimBlanks: Bool? = nil, truncateColumns: Bool? = nil, username: String? = nil, writeBufferSize: Int? = nil) {
            self.acceptAnyDate = acceptAnyDate
            self.afterConnectScript = afterConnectScript
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.connectionTimeout = connectionTimeout
            self.databaseName = databaseName
            self.dateFormat = dateFormat
            self.emptyAsNull = emptyAsNull
            self.encryptionMode = encryptionMode
            self.fileTransferUploadStreams = fileTransferUploadStreams
            self.loadTimeout = loadTimeout
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.removeQuotes = removeQuotes
            self.replaceChars = replaceChars
            self.replaceInvalidChars = replaceInvalidChars
            self.serverName = serverName
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timeFormat = timeFormat
            self.trimBlanks = trimBlanks
            self.truncateColumns = truncateColumns
            self.username = username
            self.writeBufferSize = writeBufferSize
        }

        private enum CodingKeys: String, CodingKey {
            case acceptAnyDate = "AcceptAnyDate"
            case afterConnectScript = "AfterConnectScript"
            case bucketFolder = "BucketFolder"
            case bucketName = "BucketName"
            case connectionTimeout = "ConnectionTimeout"
            case databaseName = "DatabaseName"
            case dateFormat = "DateFormat"
            case emptyAsNull = "EmptyAsNull"
            case encryptionMode = "EncryptionMode"
            case fileTransferUploadStreams = "FileTransferUploadStreams"
            case loadTimeout = "LoadTimeout"
            case maxFileSize = "MaxFileSize"
            case password = "Password"
            case port = "Port"
            case removeQuotes = "RemoveQuotes"
            case replaceChars = "ReplaceChars"
            case replaceInvalidChars = "ReplaceInvalidChars"
            case serverName = "ServerName"
            case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case timeFormat = "TimeFormat"
            case trimBlanks = "TrimBlanks"
            case truncateColumns = "TruncateColumns"
            case username = "Username"
            case writeBufferSize = "WriteBufferSize"
        }
    }

    public struct RefreshSchemasMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct RefreshSchemasResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RefreshSchemasStatus", required: false, type: .structure)
        ]

        /// The status of the refreshed schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct RefreshSchemasStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "LastFailureMessage", required: false, type: .string), 
            AWSShapeMember(label: "LastRefreshDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The last failure message for the schema.
        public let lastFailureMessage: String?
        /// The date the schema was last refreshed.
        public let lastRefreshDate: TimeStamp?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The status of the schema.
        public let status: RefreshSchemasStatusTypeValue?

        public init(endpointArn: String? = nil, lastFailureMessage: String? = nil, lastRefreshDate: TimeStamp? = nil, replicationInstanceArn: String? = nil, status: RefreshSchemasStatusTypeValue? = nil) {
            self.endpointArn = endpointArn
            self.lastFailureMessage = lastFailureMessage
            self.lastRefreshDate = lastRefreshDate
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case lastFailureMessage = "LastFailureMessage"
            case lastRefreshDate = "LastRefreshDate"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case status = "Status"
        }
    }

    public struct ReloadTablesMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReloadOption", required: false, type: .enum), 
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string), 
            AWSShapeMember(label: "TablesToReload", required: true, type: .list)
        ]

        /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the task.  Valid values: data-reload, validate-only Default value is data-reload.
        public let reloadOption: ReloadOptionValue?
        /// The Amazon Resource Name (ARN) of the replication task. 
        public let replicationTaskArn: String
        /// The name and schema of the table to be reloaded. 
        public let tablesToReload: [TableToReload]

        public init(reloadOption: ReloadOptionValue? = nil, replicationTaskArn: String, tablesToReload: [TableToReload]) {
            self.reloadOption = reloadOption
            self.replicationTaskArn = replicationTaskArn
            self.tablesToReload = tablesToReload
        }

        private enum CodingKeys: String, CodingKey {
            case reloadOption = "ReloadOption"
            case replicationTaskArn = "ReplicationTaskArn"
            case tablesToReload = "TablesToReload"
        }
    }

    public struct ReloadTablesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the replication task. 
        public let replicationTaskArn: String?

        public init(replicationTaskArn: String? = nil) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct RemoveTagsFromResourceMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceArn", required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", required: true, type: .list)
        ]

        /// An AWS DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The tag key (name) of the tag to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct RemoveTagsFromResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct ReplicationInstance: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "AutoMinorVersionUpgrade", required: false, type: .boolean), 
            AWSShapeMember(label: "AvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "DnsNameServers", required: false, type: .string), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "FreeUntil", required: false, type: .timestamp), 
            AWSShapeMember(label: "InstanceCreateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "KmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "PendingModifiedValues", required: false, type: .structure), 
            AWSShapeMember(label: "PreferredMaintenanceWindow", required: false, type: .string), 
            AWSShapeMember(label: "PubliclyAccessible", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstancePrivateIpAddresses", required: false, type: .list), 
            AWSShapeMember(label: "ReplicationInstancePublicIpAddresses", required: false, type: .list), 
            AWSShapeMember(label: "ReplicationInstanceStatus", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroup", required: false, type: .structure), 
            AWSShapeMember(label: "SecondaryAvailabilityZone", required: false, type: .string), 
            AWSShapeMember(label: "VpcSecurityGroups", required: false, type: .list)
        ]

        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int?
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone for the instance.
        public let availabilityZone: String?
        /// The DNS name servers supported for the replication instance to access your on-premise source or target database.
        public let dnsNameServers: String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public let engineVersion: String?
        ///  The expiration date of the free replication instance that is part of the Free DMS program. 
        public let freeUntil: TimeStamp?
        /// The time the replication instance was created.
        public let instanceCreateTime: TimeStamp?
        /// An AWS KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS Region.
        public let kmsKeyId: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// The pending modification values.
        public let pendingModifiedValues: ReplicationPendingModifiedValues?
        /// The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.
        public let preferredMaintenanceWindow: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true. 
        public let publiclyAccessible: Bool?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a defualt value is pre-selected in the DMS console. For more information on the settings and capacities for the available replication instance classes, see  Selecting the right AWS DMS replication instance for your migration. 
        public let replicationInstanceClass: String?
        /// The replication instance identifier is a required parameter. This parameter is stored as a lowercase string. Constraints:   Must contain 1-63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance 
        public let replicationInstanceIdentifier: String?
        /// One or more private IP addresses for the replication instance.
        public let replicationInstancePrivateIpAddresses: [String]?
        /// One or more public IP addresses for the replication instance.
        public let replicationInstancePublicIpAddresses: [String]?
        /// The status of the replication instance. The possible return values include:    "available"     "creating"     "deleted"     "deleting"     "failed"     "modifying"     "upgrading"     "rebooting"     "resetting-master-credentials"     "storage-full"     "incompatible-credentials"     "incompatible-network"     "maintenance"   
        public let replicationInstanceStatus: String?
        /// The subnet group for the replication instance.
        public let replicationSubnetGroup: ReplicationSubnetGroup?
        /// The Availability Zone of the standby replication instance in a Multi-AZ deployment.
        public let secondaryAvailabilityZone: String?
        /// The VPC security group for the instance.
        public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, dnsNameServers: String? = nil, engineVersion: String? = nil, freeUntil: TimeStamp? = nil, instanceCreateTime: TimeStamp? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, pendingModifiedValues: ReplicationPendingModifiedValues? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceArn: String? = nil, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, replicationInstancePrivateIpAddresses: [String]? = nil, replicationInstancePublicIpAddresses: [String]? = nil, replicationInstanceStatus: String? = nil, replicationSubnetGroup: ReplicationSubnetGroup? = nil, secondaryAvailabilityZone: String? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case dnsNameServers = "DnsNameServers"
            case engineVersion = "EngineVersion"
            case freeUntil = "FreeUntil"
            case instanceCreateTime = "InstanceCreateTime"
            case kmsKeyId = "KmsKeyId"
            case multiAZ = "MultiAZ"
            case pendingModifiedValues = "PendingModifiedValues"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
            case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
            case replicationInstanceStatus = "ReplicationInstanceStatus"
            case replicationSubnetGroup = "ReplicationSubnetGroup"
            case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct ReplicationInstanceTaskLog: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationInstanceTaskLogSize", required: false, type: .long), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskName", required: false, type: .string)
        ]

        /// The size, in bytes, of the replication task log.
        public let replicationInstanceTaskLogSize: Int64?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The name of the replication task.
        public let replicationTaskName: String?

        public init(replicationInstanceTaskLogSize: Int64? = nil, replicationTaskArn: String? = nil, replicationTaskName: String? = nil) {
            self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskName = replicationTaskName
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceTaskLogSize = "ReplicationInstanceTaskLogSize"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskName = "ReplicationTaskName"
        }
    }

    public struct ReplicationPendingModifiedValues: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AllocatedStorage", required: false, type: .integer), 
            AWSShapeMember(label: "EngineVersion", required: false, type: .string), 
            AWSShapeMember(label: "MultiAZ", required: false, type: .boolean), 
            AWSShapeMember(label: "ReplicationInstanceClass", required: false, type: .string)
        ]

        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int?
        /// The engine version number of the replication instance.
        public let engineVersion: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true. 
        public let multiAZ: Bool?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For more information on the settings and capacities for the available replication instance classes, see  Selecting the right AWS DMS replication instance for your migration. 
        public let replicationInstanceClass: String?

        public init(allocatedStorage: Int? = nil, engineVersion: String? = nil, multiAZ: Bool? = nil, replicationInstanceClass: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.replicationInstanceClass = replicationInstanceClass
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case engineVersion = "EngineVersion"
            case multiAZ = "MultiAZ"
            case replicationInstanceClass = "ReplicationInstanceClass"
        }
    }

    public struct ReplicationSubnetGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationSubnetGroupDescription", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationSubnetGroupIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "SubnetGroupStatus", required: false, type: .string), 
            AWSShapeMember(label: "Subnets", required: false, type: .list), 
            AWSShapeMember(label: "VpcId", required: false, type: .string)
        ]

        /// A description for the replication subnet group.
        public let replicationSubnetGroupDescription: String?
        /// The identifier of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String?
        /// The status of the subnet group.
        public let subnetGroupStatus: String?
        /// The subnets that are in the subnet group.
        public let subnets: [Subnet]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(replicationSubnetGroupDescription: String? = nil, replicationSubnetGroupIdentifier: String? = nil, subnetGroupStatus: String? = nil, subnets: [Subnet]? = nil, vpcId: String? = nil) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetGroupStatus = "SubnetGroupStatus"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct ReplicationTask: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CdcStartPosition", required: false, type: .string), 
            AWSShapeMember(label: "CdcStopPosition", required: false, type: .string), 
            AWSShapeMember(label: "LastFailureMessage", required: false, type: .string), 
            AWSShapeMember(label: "MigrationType", required: false, type: .enum), 
            AWSShapeMember(label: "RecoveryCheckpoint", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskCreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReplicationTaskIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskSettings", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskStartDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReplicationTaskStats", required: false, type: .structure), 
            AWSShapeMember(label: "SourceEndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "StopReason", required: false, type: .string), 
            AWSShapeMember(label: "TableMappings", required: false, type: .string), 
            AWSShapeMember(label: "TargetEndpointArn", required: false, type: .string), 
            AWSShapeMember(label: "TaskData", required: false, type: .string)
        ]

        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want the CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”
        public let cdcStartPosition: String?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The last error (failure) message generated for the replication task.
        public let lastFailureMessage: String?
        /// The type of migration.
        public let migrationType: MigrationTypeValue?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public let recoveryCheckpoint: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The date the replication task was created.
        public let replicationTaskCreationDate: TimeStamp?
        /// The user-assigned replication task identifier or name. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.  
        public let replicationTaskIdentifier: String?
        /// The settings for the replication task.
        public let replicationTaskSettings: String?
        /// The date the replication task is scheduled to start.
        public let replicationTaskStartDate: TimeStamp?
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public let replicationTaskStats: ReplicationTaskStats?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let sourceEndpointArn: String?
        /// The status of the replication task.
        public let status: String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:    "STOP_REASON_FULL_LOAD_COMPLETED" – Full-load migration completed.    "STOP_REASON_CACHED_CHANGES_APPLIED" – Change data capture (CDC) load completed.    "STOP_REASON_CACHED_CHANGES_NOT_APPLIED" – In a full-load and CDC migration, the full-load stopped as specified before starting the CDC migration.    "STOP_REASON_SERVER_TIME" – The migration stopped at the specified server time.  
        public let stopReason: String?
        /// Table mappings specified in the task.
        public let tableMappings: String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let targetEndpointArn: String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the AWS Database Migration Service User Guide. 
        public let taskData: String?

        public init(cdcStartPosition: String? = nil, cdcStopPosition: String? = nil, lastFailureMessage: String? = nil, migrationType: MigrationTypeValue? = nil, recoveryCheckpoint: String? = nil, replicationInstanceArn: String? = nil, replicationTaskArn: String? = nil, replicationTaskCreationDate: TimeStamp? = nil, replicationTaskIdentifier: String? = nil, replicationTaskSettings: String? = nil, replicationTaskStartDate: TimeStamp? = nil, replicationTaskStats: ReplicationTaskStats? = nil, sourceEndpointArn: String? = nil, status: String? = nil, stopReason: String? = nil, tableMappings: String? = nil, targetEndpointArn: String? = nil, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStopPosition = cdcStopPosition
            self.lastFailureMessage = lastFailureMessage
            self.migrationType = migrationType
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskStats = replicationTaskStats
            self.sourceEndpointArn = sourceEndpointArn
            self.status = status
            self.stopReason = stopReason
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStopPosition = "CdcStopPosition"
            case lastFailureMessage = "LastFailureMessage"
            case migrationType = "MigrationType"
            case recoveryCheckpoint = "RecoveryCheckpoint"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskCreationDate = "ReplicationTaskCreationDate"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case replicationTaskStartDate = "ReplicationTaskStartDate"
            case replicationTaskStats = "ReplicationTaskStats"
            case sourceEndpointArn = "SourceEndpointArn"
            case status = "Status"
            case stopReason = "StopReason"
            case tableMappings = "TableMappings"
            case targetEndpointArn = "TargetEndpointArn"
            case taskData = "TaskData"
        }
    }

    public struct ReplicationTaskAssessmentResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AssessmentResults", required: false, type: .string), 
            AWSShapeMember(label: "AssessmentResultsFile", required: false, type: .string), 
            AWSShapeMember(label: "AssessmentStatus", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskLastAssessmentDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "S3ObjectUrl", required: false, type: .string)
        ]

        ///  The task assessment results in JSON format. 
        public let assessmentResults: String?
        ///  The file containing the results of the task assessment. 
        public let assessmentResultsFile: String?
        ///  The status of the task assessment. 
        public let assessmentStatus: String?
        /// The Amazon Resource Name (ARN) of the replication task. 
        public let replicationTaskArn: String?
        ///  The replication task identifier of the task on which the task assessment was run. 
        public let replicationTaskIdentifier: String?
        /// The date the task assessment was completed. 
        public let replicationTaskLastAssessmentDate: TimeStamp?
        ///  The URL of the S3 object containing the task assessment results. 
        public let s3ObjectUrl: String?

        public init(assessmentResults: String? = nil, assessmentResultsFile: String? = nil, assessmentStatus: String? = nil, replicationTaskArn: String? = nil, replicationTaskIdentifier: String? = nil, replicationTaskLastAssessmentDate: TimeStamp? = nil, s3ObjectUrl: String? = nil) {
            self.assessmentResults = assessmentResults
            self.assessmentResultsFile = assessmentResultsFile
            self.assessmentStatus = assessmentStatus
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
            self.s3ObjectUrl = s3ObjectUrl
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentResults = "AssessmentResults"
            case assessmentResultsFile = "AssessmentResultsFile"
            case assessmentStatus = "AssessmentStatus"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskLastAssessmentDate = "ReplicationTaskLastAssessmentDate"
            case s3ObjectUrl = "S3ObjectUrl"
        }
    }

    public struct ReplicationTaskAssessmentRun: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AssessmentProgress", required: false, type: .structure), 
            AWSShapeMember(label: "AssessmentRunName", required: false, type: .string), 
            AWSShapeMember(label: "LastFailureMessage", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskAssessmentRunArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskAssessmentRunCreationDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "ResultEncryptionMode", required: false, type: .string), 
            AWSShapeMember(label: "ResultKmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "ResultLocationBucket", required: false, type: .string), 
            AWSShapeMember(label: "ResultLocationFolder", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// Indication of the completion progress for the individual assessments specified to run.
        public let assessmentProgress: ReplicationTaskAssessmentRunProgress?
        /// Unique name of the assessment run.
        public let assessmentRunName: String?
        /// Last message generated by an individual assessment failure.
        public let lastFailureMessage: String?
        /// ARN of the migration task associated with this premigration assessment run.
        public let replicationTaskArn: String?
        /// Amazon Resource Name (ARN) of this assessment run.
        public let replicationTaskAssessmentRunArn: String?
        /// Date on which the assessment run was created using the StartReplicationTaskAssessmentRun operation.
        public let replicationTaskAssessmentRunCreationDate: TimeStamp?
        /// Encryption mode used to encrypt the assessment run results.
        public let resultEncryptionMode: String?
        /// ARN of the AWS KMS encryption key used to encrypt the assessment run results.
        public let resultKmsKeyArn: String?
        /// Amazon S3 bucket where AWS DMS stores the results of this assessment run.
        public let resultLocationBucket: String?
        /// Folder in an Amazon S3 bucket where AWS DMS stores the results of this assessment run.
        public let resultLocationFolder: String?
        /// ARN of the service role used to start the assessment run using the StartReplicationTaskAssessmentRun operation.
        public let serviceAccessRoleArn: String?
        /// Assessment run status.  This status can have one of the following values:    "cancelling" – The assessment run was canceled by the CancelReplicationTaskAssessmentRun operation.    "deleting" – The assessment run was deleted by the DeleteReplicationTaskAssessmentRun operation.    "failed" – At least one individual assessment completed with a failed status.    "error-provisioning" – An internal error occurred while resources were provisioned (during provisioning status).    "error-executing" – An internal error occurred while individual assessments ran (during running status).    "invalid state" – The assessment run is in an unknown state.    "passed" – All individual assessments have completed, and none has a failed status.    "provisioning" – Resources required to run individual assessments are being provisioned.    "running" – Individual assessments are being run.    "starting" – The assessment run is starting, but resources are not yet being provisioned for individual assessments.  
        public let status: String?

        public init(assessmentProgress: ReplicationTaskAssessmentRunProgress? = nil, assessmentRunName: String? = nil, lastFailureMessage: String? = nil, replicationTaskArn: String? = nil, replicationTaskAssessmentRunArn: String? = nil, replicationTaskAssessmentRunCreationDate: TimeStamp? = nil, resultEncryptionMode: String? = nil, resultKmsKeyArn: String? = nil, resultLocationBucket: String? = nil, resultLocationFolder: String? = nil, serviceAccessRoleArn: String? = nil, status: String? = nil) {
            self.assessmentProgress = assessmentProgress
            self.assessmentRunName = assessmentRunName
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentProgress = "AssessmentProgress"
            case assessmentRunName = "AssessmentRunName"
            case lastFailureMessage = "LastFailureMessage"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
            case replicationTaskAssessmentRunCreationDate = "ReplicationTaskAssessmentRunCreationDate"
            case resultEncryptionMode = "ResultEncryptionMode"
            case resultKmsKeyArn = "ResultKmsKeyArn"
            case resultLocationBucket = "ResultLocationBucket"
            case resultLocationFolder = "ResultLocationFolder"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case status = "Status"
        }
    }

    public struct ReplicationTaskAssessmentRunProgress: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndividualAssessmentCompletedCount", required: false, type: .integer), 
            AWSShapeMember(label: "IndividualAssessmentCount", required: false, type: .integer)
        ]

        /// The number of individual assessments that have completed, successfully or not.
        public let individualAssessmentCompletedCount: Int?
        /// The number of individual assessments that are specified to run.
        public let individualAssessmentCount: Int?

        public init(individualAssessmentCompletedCount: Int? = nil, individualAssessmentCount: Int? = nil) {
            self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
            self.individualAssessmentCount = individualAssessmentCount
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentCompletedCount = "IndividualAssessmentCompletedCount"
            case individualAssessmentCount = "IndividualAssessmentCount"
        }
    }

    public struct ReplicationTaskIndividualAssessment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IndividualAssessmentName", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskAssessmentRunArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIndividualAssessmentArn", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskIndividualAssessmentStartDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// Name of this individual assessment.
        public let individualAssessmentName: String?
        /// ARN of the premigration assessment run that is created to run this individual assessment.
        public let replicationTaskAssessmentRunArn: String?
        /// Amazon Resource Name (ARN) of this individual assessment.
        public let replicationTaskIndividualAssessmentArn: String?
        /// Date when this individual assessment was started as part of running the StartReplicationTaskAssessmentRun operation.
        public let replicationTaskIndividualAssessmentStartDate: TimeStamp?
        /// Individual assessment status. This status can have one of the following values:    "cancelled"     "error"     "failed"     "passed"     "pending"     "running"   
        public let status: String?

        public init(individualAssessmentName: String? = nil, replicationTaskAssessmentRunArn: String? = nil, replicationTaskIndividualAssessmentArn: String? = nil, replicationTaskIndividualAssessmentStartDate: TimeStamp? = nil, status: String? = nil) {
            self.individualAssessmentName = individualAssessmentName
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
            self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentName = "IndividualAssessmentName"
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
            case replicationTaskIndividualAssessmentArn = "ReplicationTaskIndividualAssessmentArn"
            case replicationTaskIndividualAssessmentStartDate = "ReplicationTaskIndividualAssessmentStartDate"
            case status = "Status"
        }
    }

    public struct ReplicationTaskStats: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ElapsedTimeMillis", required: false, type: .long), 
            AWSShapeMember(label: "FreshStartDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "FullLoadFinishDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "FullLoadProgressPercent", required: false, type: .integer), 
            AWSShapeMember(label: "FullLoadStartDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "StartDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "StopDate", required: false, type: .timestamp), 
            AWSShapeMember(label: "TablesErrored", required: false, type: .integer), 
            AWSShapeMember(label: "TablesLoaded", required: false, type: .integer), 
            AWSShapeMember(label: "TablesLoading", required: false, type: .integer), 
            AWSShapeMember(label: "TablesQueued", required: false, type: .integer)
        ]

        /// The elapsed time of the task, in milliseconds.
        public let elapsedTimeMillis: Int64?
        /// The date the replication task was started either with a fresh start or a target reload.
        public let freshStartDate: TimeStamp?
        /// The date the replication task full load was completed.
        public let fullLoadFinishDate: TimeStamp?
        /// The percent complete for the full load migration task.
        public let fullLoadProgressPercent: Int?
        /// The date the replication task full load was started.
        public let fullLoadStartDate: TimeStamp?
        /// The date the replication task was started either with a fresh start or a resume. For more information, see StartReplicationTaskType.
        public let startDate: TimeStamp?
        /// The date the replication task was stopped.
        public let stopDate: TimeStamp?
        /// The number of errors that have occurred during this task.
        public let tablesErrored: Int?
        /// The number of tables loaded for this task.
        public let tablesLoaded: Int?
        /// The number of tables currently loading for this task.
        public let tablesLoading: Int?
        /// The number of tables queued for this task.
        public let tablesQueued: Int?

        public init(elapsedTimeMillis: Int64? = nil, freshStartDate: TimeStamp? = nil, fullLoadFinishDate: TimeStamp? = nil, fullLoadProgressPercent: Int? = nil, fullLoadStartDate: TimeStamp? = nil, startDate: TimeStamp? = nil, stopDate: TimeStamp? = nil, tablesErrored: Int? = nil, tablesLoaded: Int? = nil, tablesLoading: Int? = nil, tablesQueued: Int? = nil) {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }

        private enum CodingKeys: String, CodingKey {
            case elapsedTimeMillis = "ElapsedTimeMillis"
            case freshStartDate = "FreshStartDate"
            case fullLoadFinishDate = "FullLoadFinishDate"
            case fullLoadProgressPercent = "FullLoadProgressPercent"
            case fullLoadStartDate = "FullLoadStartDate"
            case startDate = "StartDate"
            case stopDate = "StopDate"
            case tablesErrored = "TablesErrored"
            case tablesLoaded = "TablesLoaded"
            case tablesLoading = "TablesLoading"
            case tablesQueued = "TablesQueued"
        }
    }

    public struct ResourcePendingMaintenanceActions: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PendingMaintenanceActionDetails", required: false, type: .list), 
            AWSShapeMember(label: "ResourceIdentifier", required: false, type: .string)
        ]

        /// Detailed information about the pending maintenance action.
        public let pendingMaintenanceActionDetails: [PendingMaintenanceAction]?
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to. For information about creating an ARN, see  Constructing an Amazon Resource Name (ARN) for AWS DMS in the DMS documentation.
        public let resourceIdentifier: String?

        public init(pendingMaintenanceActionDetails: [PendingMaintenanceAction]? = nil, resourceIdentifier: String? = nil) {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct S3Settings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BucketFolder", required: false, type: .string), 
            AWSShapeMember(label: "BucketName", required: false, type: .string), 
            AWSShapeMember(label: "CdcInsertsAndUpdates", required: false, type: .boolean), 
            AWSShapeMember(label: "CdcInsertsOnly", required: false, type: .boolean), 
            AWSShapeMember(label: "CompressionType", required: false, type: .enum), 
            AWSShapeMember(label: "CsvDelimiter", required: false, type: .string), 
            AWSShapeMember(label: "CsvRowDelimiter", required: false, type: .string), 
            AWSShapeMember(label: "DataFormat", required: false, type: .enum), 
            AWSShapeMember(label: "DataPageSize", required: false, type: .integer), 
            AWSShapeMember(label: "DictPageSizeLimit", required: false, type: .integer), 
            AWSShapeMember(label: "EnableStatistics", required: false, type: .boolean), 
            AWSShapeMember(label: "EncodingType", required: false, type: .enum), 
            AWSShapeMember(label: "EncryptionMode", required: false, type: .enum), 
            AWSShapeMember(label: "ExternalTableDefinition", required: false, type: .string), 
            AWSShapeMember(label: "IncludeOpForFullLoad", required: false, type: .boolean), 
            AWSShapeMember(label: "ParquetTimestampInMillisecond", required: false, type: .boolean), 
            AWSShapeMember(label: "ParquetVersion", required: false, type: .enum), 
            AWSShapeMember(label: "RowGroupLength", required: false, type: .integer), 
            AWSShapeMember(label: "ServerSideEncryptionKmsKeyId", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: false, type: .string), 
            AWSShapeMember(label: "TimestampColumnName", required: false, type: .string)
        ]

        ///  An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path  bucketFolder/schema_name/table_name/. If this parameter isn't specified, then the path used is  schema_name/table_name/. 
        public let bucketFolder: String?
        ///  The name of the S3 bucket. 
        public let bucketName: String?
        /// A value that enables a change data capture (CDC) load to write INSERT and UPDATE operations to .csv or .parquet (columnar storage) output files. The default setting is false, but when CdcInsertsAndUpdates is set to true or y, only INSERTs and UPDATEs from the source database are migrated to the .csv or .parquet file.  For .csv file format only, how these INSERTs and UPDATEs are recorded depends on the value of the IncludeOpForFullLoad parameter. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to either I or U to indicate INSERT and UPDATE operations at the source. But if IncludeOpForFullLoad is set to false, CDC records are written without an indication of INSERT or UPDATE operations at the source. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the AWS Database Migration Service User Guide..  AWS DMS supports the use of the CdcInsertsAndUpdates parameter in versions 3.3.1 and later.  CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both. 
        public let cdcInsertsAndUpdates: Bool?
        /// A value that enables a change data capture (CDC) load to write only INSERT operations to .csv or columnar storage (.parquet) output files. By default (the false setting), the first field in a .csv or .parquet record contains the letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was inserted, updated, or deleted at the source database for a CDC load to the target. If CdcInsertsOnly is set to true or y, only INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format only, how these INSERTs are recorded depends on the value of IncludeOpForFullLoad. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to I to indicate the INSERT operation at the source. If IncludeOpForFullLoad is set to false, every CDC record is written without a first field to indicate the INSERT operation at the source. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the AWS Database Migration Service User Guide..  AWS DMS supports the interaction described preceding between the CdcInsertsOnly and IncludeOpForFullLoad parameters in versions 3.1.4 and later.   CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both. 
        public let cdcInsertsOnly: Bool?
        /// An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed. This parameter applies to both .csv and .parquet file formats. 
        public let compressionType: CompressionTypeValue?
        ///  The delimiter used to separate columns in the .csv file for both source and target. The default is a comma. 
        public let csvDelimiter: String?
        ///  The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage return (\n). 
        public let csvRowDelimiter: String?
        /// The format of the data that you want to use for output. You can choose one of the following:     csv : This is a row-based file format with comma-separated values (.csv).     parquet : Apache Parquet (.parquet) is a columnar storage file format that features efficient compression and provides faster query response.   
        public let dataFormat: DataFormatValue?
        /// The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB). This number is used for .parquet file format only. 
        public let dataPageSize: Int?
        /// The maximum size of an encoded dictionary page of a column. If the dictionary page exceeds this, this column is stored using an encoding type of PLAIN. This parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page before it reverts to PLAIN encoding. This size is used for .parquet file format only. 
        public let dictPageSizeLimit: Int?
        /// A value that enables statistics for Parquet pages and row groups. Choose true to enable statistics, false to disable. Statistics include NULL, DISTINCT, MAX, and MIN values. This parameter defaults to true. This value is used for .parquet file format only.
        public let enableStatistics: Bool?
        /// The type of encoding you are using:     RLE_DICTIONARY uses a combination of bit-packing and run-length encoding to store repeated values more efficiently. This is the default.    PLAIN doesn't use encoding at all. Values are stored as they are.    PLAIN_DICTIONARY builds a dictionary of the values encountered in a given column. The dictionary is stored in a dictionary page for each column chunk.  
        public let encodingType: EncodingTypeValue?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS.   For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS.  To use SSE_S3, you need an AWS Identity and Access Management (IAM) role with permission to allow "arn:aws:s3:::dms-*" to use the following actions:    s3:CreateBucket     s3:ListBucket     s3:DeleteBucket     s3:GetBucketLocation     s3:GetObject     s3:PutObject     s3:DeleteObject     s3:GetObjectVersion     s3:GetBucketPolicy     s3:PutBucketPolicy     s3:DeleteBucketPolicy   
        public let encryptionMode: EncryptionModeValue?
        ///  Specifies how tables are defined in the S3 source files only. 
        public let externalTableDefinition: String?
        /// A value that enables a full load to write INSERT operations to the comma-separated value (.csv) output files only to indicate how the rows were added to the source database.  AWS DMS supports the IncludeOpForFullLoad parameter in versions 3.1.4 and later.  For full load, records can only be inserted. By default (the false setting), no information is recorded in these output files for a full load to indicate that the rows were inserted at the source database. If IncludeOpForFullLoad is set to true or y, the INSERT is recorded as an I annotation in the first field of the .csv file. This allows the format of your target records from a full load to be consistent with the target records from a CDC load.  This setting works together with the CdcInsertsOnly and the CdcInsertsAndUpdates parameters for output to .csv files only. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the AWS Database Migration Service User Guide.. 
        public let includeOpForFullLoad: Bool?
        /// A value that specifies the precision of any TIMESTAMP column values that are written to an Amazon S3 object file in .parquet format.  AWS DMS supports the ParquetTimestampInMillisecond parameter in versions 3.1.4 and later.  When ParquetTimestampInMillisecond is set to true or y, AWS DMS writes all TIMESTAMP columns in a .parquet formatted file with millisecond precision. Otherwise, DMS writes them with microsecond precision. Currently, Amazon Athena and AWS Glue can handle only millisecond precision for TIMESTAMP values. Set this parameter to true for S3 endpoint object files that are .parquet formatted only if you plan to query or process the data with Athena or AWS Glue.  AWS DMS writes any TIMESTAMP column values written to an S3 file in .csv format with microsecond precision. Setting ParquetTimestampInMillisecond has no effect on the string format of the timestamp column value that is inserted by setting the TimestampColumnName parameter. 
        public let parquetTimestampInMillisecond: Bool?
        /// The version of the Apache Parquet format that you want to use: parquet_1_0 (the default) or parquet_2_0.
        public let parquetVersion: ParquetVersionValue?
        /// The number of rows in a row group. A smaller row group size provides faster reads. But as the number of row groups grows, the slower writes become. This parameter defaults to 10,000 rows. This number is used for .parquet file format only.  If you choose a value larger than the maximum, RowGroupLength is set to the max row group length in bytes (64 * 1024 * 1024). 
        public let rowGroupLength: Int?
        /// If you are using SSE_KMS for the EncryptionMode, provide the AWS KMS key ID. The key that you use needs an attached policy that enables AWS Identity and Access Management (IAM) user permissions and allows use of the key. Here is a CLI example: aws dms create-endpoint --endpoint-identifier value --endpoint-type target --engine-name s3 --s3-settings ServiceAccessRoleArn=value,BucketFolder=value,BucketName=value,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=value  
        public let serverSideEncryptionKmsKeyId: String?
        ///  The Amazon Resource Name (ARN) used by the service access IAM role. It is a required parameter that enables DMS to write and read objects from an 3S bucket.
        public let serviceAccessRoleArn: String?
        /// A value that when nonblank causes AWS DMS to add a column with timestamp information to the endpoint data for an Amazon S3 target.  AWS DMS supports the TimestampColumnName parameter in versions 3.1.4 and later.  DMS includes an additional STRING column in the .csv or .parquet object files of your migrated data when you set TimestampColumnName to a nonblank value. For a full load, each row of this timestamp column contains a timestamp for when the data was transferred from the source to the target by DMS.  For a change data capture (CDC) load, each row of the timestamp column contains the timestamp for the commit of that row in the source database. The string format for this timestamp column value is yyyy-MM-dd HH:mm:ss.SSSSSS. By default, the precision of this value is in microseconds. For a CDC load, the rounding of the precision depends on the commit timestamp supported by DMS for the source database. When the AddColumnName parameter is set to true, DMS also includes a name for the timestamp column that you set with TimestampColumnName.
        public let timestampColumnName: String?

        public init(bucketFolder: String? = nil, bucketName: String? = nil, cdcInsertsAndUpdates: Bool? = nil, cdcInsertsOnly: Bool? = nil, compressionType: CompressionTypeValue? = nil, csvDelimiter: String? = nil, csvRowDelimiter: String? = nil, dataFormat: DataFormatValue? = nil, dataPageSize: Int? = nil, dictPageSizeLimit: Int? = nil, enableStatistics: Bool? = nil, encodingType: EncodingTypeValue? = nil, encryptionMode: EncryptionModeValue? = nil, externalTableDefinition: String? = nil, includeOpForFullLoad: Bool? = nil, parquetTimestampInMillisecond: Bool? = nil, parquetVersion: ParquetVersionValue? = nil, rowGroupLength: Int? = nil, serverSideEncryptionKmsKeyId: String? = nil, serviceAccessRoleArn: String? = nil, timestampColumnName: String? = nil) {
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.cdcInsertsOnly = cdcInsertsOnly
            self.compressionType = compressionType
            self.csvDelimiter = csvDelimiter
            self.csvRowDelimiter = csvRowDelimiter
            self.dataFormat = dataFormat
            self.dataPageSize = dataPageSize
            self.dictPageSizeLimit = dictPageSizeLimit
            self.enableStatistics = enableStatistics
            self.encodingType = encodingType
            self.encryptionMode = encryptionMode
            self.externalTableDefinition = externalTableDefinition
            self.includeOpForFullLoad = includeOpForFullLoad
            self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
            self.parquetVersion = parquetVersion
            self.rowGroupLength = rowGroupLength
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timestampColumnName = timestampColumnName
        }

        private enum CodingKeys: String, CodingKey {
            case bucketFolder = "BucketFolder"
            case bucketName = "BucketName"
            case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
            case cdcInsertsOnly = "CdcInsertsOnly"
            case compressionType = "CompressionType"
            case csvDelimiter = "CsvDelimiter"
            case csvRowDelimiter = "CsvRowDelimiter"
            case dataFormat = "DataFormat"
            case dataPageSize = "DataPageSize"
            case dictPageSizeLimit = "DictPageSizeLimit"
            case enableStatistics = "EnableStatistics"
            case encodingType = "EncodingType"
            case encryptionMode = "EncryptionMode"
            case externalTableDefinition = "ExternalTableDefinition"
            case includeOpForFullLoad = "IncludeOpForFullLoad"
            case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
            case parquetVersion = "ParquetVersion"
            case rowGroupLength = "RowGroupLength"
            case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case timestampColumnName = "TimestampColumnName"
        }
    }

    public struct StartReplicationTaskAssessmentMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string)
        ]

        ///  The Amazon Resource Name (ARN) of the replication task. 
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct StartReplicationTaskAssessmentResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]

        ///  The assessed replication task. 
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct StartReplicationTaskAssessmentRunMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AssessmentRunName", required: true, type: .string), 
            AWSShapeMember(label: "Exclude", required: false, type: .list), 
            AWSShapeMember(label: "IncludeOnly", required: false, type: .list), 
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string), 
            AWSShapeMember(label: "ResultEncryptionMode", required: false, type: .string), 
            AWSShapeMember(label: "ResultKmsKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "ResultLocationBucket", required: true, type: .string), 
            AWSShapeMember(label: "ResultLocationFolder", required: false, type: .string), 
            AWSShapeMember(label: "ServiceAccessRoleArn", required: true, type: .string)
        ]

        /// Unique name to identify the assessment run.
        public let assessmentRunName: String
        /// Space-separated list of names for specific individual assessments that you want to exclude. These names come from the default list of individual assessments that AWS DMS supports for the associated migration task. This task is specified by ReplicationTaskArn.  You can't set a value for Exclude if you also set a value for IncludeOnly in the API operation. To identify the names of the default individual assessments that AWS DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter. 
        public let exclude: [String]?
        /// Space-separated list of names for specific individual assessments that you want to include. These names come from the default list of individual assessments that AWS DMS supports for the associated migration task. This task is specified by ReplicationTaskArn.  You can't set a value for IncludeOnly if you also set a value for Exclude in the API operation.  To identify the names of the default individual assessments that AWS DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter. 
        public let includeOnly: [String]?
        /// Amazon Resource Name (ARN) of the migration task associated with the premigration assessment run that you want to start.
        public let replicationTaskArn: String
        /// Encryption mode that you can specify to encrypt the results of this assessment run. If you don't specify this request parameter, AWS DMS stores the assessment run results without encryption. You can specify one of the options following:    "SSE_S3" – The server-side encryption provided as a default by Amazon S3.    "SSE_KMS" – AWS Key Management Service (AWS KMS) encryption. This encryption can use either a custom KMS encryption key that you specify or the default KMS encryption key that DMS provides.  
        public let resultEncryptionMode: String?
        /// ARN of a custom KMS encryption key that you specify when you set ResultEncryptionMode to "SSE_KMS".
        public let resultKmsKeyArn: String?
        /// Amazon S3 bucket where you want AWS DMS to store the results of this assessment run.
        public let resultLocationBucket: String
        /// Folder within an Amazon S3 bucket where you want AWS DMS to store the results of this assessment run.
        public let resultLocationFolder: String?
        /// ARN of a service role needed to start the assessment run.
        public let serviceAccessRoleArn: String

        public init(assessmentRunName: String, exclude: [String]? = nil, includeOnly: [String]? = nil, replicationTaskArn: String, resultEncryptionMode: String? = nil, resultKmsKeyArn: String? = nil, resultLocationBucket: String, resultLocationFolder: String? = nil, serviceAccessRoleArn: String) {
            self.assessmentRunName = assessmentRunName
            self.exclude = exclude
            self.includeOnly = includeOnly
            self.replicationTaskArn = replicationTaskArn
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentRunName = "AssessmentRunName"
            case exclude = "Exclude"
            case includeOnly = "IncludeOnly"
            case replicationTaskArn = "ReplicationTaskArn"
            case resultEncryptionMode = "ResultEncryptionMode"
            case resultKmsKeyArn = "ResultKmsKeyArn"
            case resultLocationBucket = "ResultLocationBucket"
            case resultLocationFolder = "ResultLocationFolder"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct StartReplicationTaskAssessmentRunResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskAssessmentRun", required: false, type: .structure)
        ]

        /// The premigration assessment run that was started.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct StartReplicationTaskMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CdcStartPosition", required: false, type: .string), 
            AWSShapeMember(label: "CdcStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "CdcStopPosition", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string), 
            AWSShapeMember(label: "StartReplicationTaskType", required: true, type: .enum)
        ]

        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error.  The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for AWS DMS. 
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
        public let cdcStartTime: TimeStamp?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The Amazon Resource Name (ARN) of the replication task to be started.
        public let replicationTaskArn: String
        /// The type of replication task.
        public let startReplicationTaskType: StartReplicationTaskTypeValue

        public init(cdcStartPosition: String? = nil, cdcStartTime: TimeStamp? = nil, cdcStopPosition: String? = nil, replicationTaskArn: String, startReplicationTaskType: StartReplicationTaskTypeValue) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.replicationTaskArn = replicationTaskArn
            self.startReplicationTaskType = startReplicationTaskType
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case replicationTaskArn = "ReplicationTaskArn"
            case startReplicationTaskType = "StartReplicationTaskType"
        }
    }

    public struct StartReplicationTaskResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]

        /// The replication task started.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct StopReplicationTaskMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTaskArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name(ARN) of the replication task to be stopped.
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct StopReplicationTaskResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ReplicationTask", required: false, type: .structure)
        ]

        /// The replication task stopped.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct Subnet: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SubnetAvailabilityZone", required: false, type: .structure), 
            AWSShapeMember(label: "SubnetIdentifier", required: false, type: .string), 
            AWSShapeMember(label: "SubnetStatus", required: false, type: .string)
        ]

        /// The Availability Zone of the subnet.
        public let subnetAvailabilityZone: AvailabilityZone?
        /// The subnet identifier.
        public let subnetIdentifier: String?
        /// The status of the subnet.
        public let subnetStatus: String?

        public init(subnetAvailabilityZone: AvailabilityZone? = nil, subnetIdentifier: String? = nil, subnetStatus: String? = nil) {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case subnetAvailabilityZone = "SubnetAvailabilityZone"
            case subnetIdentifier = "SubnetIdentifier"
            case subnetStatus = "SubnetStatus"
        }
    }

    public struct SupportedEndpointType: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointType", required: false, type: .enum), 
            AWSShapeMember(label: "EngineDisplayName", required: false, type: .string), 
            AWSShapeMember(label: "EngineName", required: false, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceEngineMinimumVersion", required: false, type: .string), 
            AWSShapeMember(label: "SupportsCDC", required: false, type: .boolean)
        ]

        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora," this value would be "Amazon Aurora MySQL."
        public let engineDisplayName: String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", and "neptune".
        public let engineName: String?
        /// The earliest AWS DMS engine version that supports this endpoint engine. Note that endpoint engines released with AWS DMS versions earlier than 3.1.1 do not return a value for this parameter.
        public let replicationInstanceEngineMinimumVersion: String?
        /// Indicates if Change Data Capture (CDC) is supported.
        public let supportsCDC: Bool?

        public init(endpointType: ReplicationEndpointTypeValue? = nil, engineDisplayName: String? = nil, engineName: String? = nil, replicationInstanceEngineMinimumVersion: String? = nil, supportsCDC: Bool? = nil) {
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
            self.supportsCDC = supportsCDC
        }

        private enum CodingKeys: String, CodingKey {
            case endpointType = "EndpointType"
            case engineDisplayName = "EngineDisplayName"
            case engineName = "EngineName"
            case replicationInstanceEngineMinimumVersion = "ReplicationInstanceEngineMinimumVersion"
            case supportsCDC = "SupportsCDC"
        }
    }

    public struct SybaseSettings: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatabaseName", required: false, type: .string), 
            AWSShapeMember(label: "Password", required: false, type: .string), 
            AWSShapeMember(label: "Port", required: false, type: .integer), 
            AWSShapeMember(label: "ServerName", required: false, type: .string), 
            AWSShapeMember(label: "Username", required: false, type: .string)
        ]

        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(databaseName: String? = nil, password: String? = nil, port: Int? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct TableStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Ddls", required: false, type: .long), 
            AWSShapeMember(label: "Deletes", required: false, type: .long), 
            AWSShapeMember(label: "FullLoadCondtnlChkFailedRows", required: false, type: .long), 
            AWSShapeMember(label: "FullLoadEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "FullLoadErrorRows", required: false, type: .long), 
            AWSShapeMember(label: "FullLoadReloaded", required: false, type: .boolean), 
            AWSShapeMember(label: "FullLoadRows", required: false, type: .long), 
            AWSShapeMember(label: "FullLoadStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Inserts", required: false, type: .long), 
            AWSShapeMember(label: "LastUpdateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "SchemaName", required: false, type: .string), 
            AWSShapeMember(label: "TableName", required: false, type: .string), 
            AWSShapeMember(label: "TableState", required: false, type: .string), 
            AWSShapeMember(label: "Updates", required: false, type: .long), 
            AWSShapeMember(label: "ValidationFailedRecords", required: false, type: .long), 
            AWSShapeMember(label: "ValidationPendingRecords", required: false, type: .long), 
            AWSShapeMember(label: "ValidationState", required: false, type: .string), 
            AWSShapeMember(label: "ValidationStateDetails", required: false, type: .string), 
            AWSShapeMember(label: "ValidationSuspendedRecords", required: false, type: .long)
        ]

        /// The data definition language (DDL) used to build and modify the structure of your tables.
        public let ddls: Int64?
        /// The number of delete actions performed on a table.
        public let deletes: Int64?
        /// The number of rows that failed conditional checks during the full load operation (valid only for migrations where DynamoDB is the target).
        public let fullLoadCondtnlChkFailedRows: Int64?
        /// The time when the full load operation completed.
        public let fullLoadEndTime: TimeStamp?
        /// The number of rows that failed to load during the full load operation (valid only for migrations where DynamoDB is the target).
        public let fullLoadErrorRows: Int64?
        /// A value that indicates if the table was reloaded (true) or loaded as part of a new full load operation (false).
        public let fullLoadReloaded: Bool?
        /// The number of rows added during the full load operation.
        public let fullLoadRows: Int64?
        /// The time when the full load operation started.
        public let fullLoadStartTime: TimeStamp?
        /// The number of insert actions performed on a table.
        public let inserts: Int64?
        /// The last time a table was updated.
        public let lastUpdateTime: TimeStamp?
        /// The schema name.
        public let schemaName: String?
        /// The name of the table.
        public let tableName: String?
        /// The state of the tables described. Valid states: Table does not exist | Before load | Full load | Table completed | Table cancelled | Table error | Table all | Table updates | Table is being reloaded
        public let tableState: String?
        /// The number of update actions performed on a table.
        public let updates: Int64?
        /// The number of records that failed validation.
        public let validationFailedRecords: Int64?
        /// The number of records that have yet to be validated.
        public let validationPendingRecords: Int64?
        /// The validation state of the table. This parameter can have the following values:   Not enabled – Validation isn't enabled for the table in the migration task.   Pending records – Some records in the table are waiting for validation.   Mismatched records – Some records in the table don't match between the source and target.   Suspended records – Some records in the table couldn't be validated.   No primary key –The table couldn't be validated because it has no primary key.   Table error – The table wasn't validated because it's in an error state and some data wasn't migrated.   Validated – All rows in the table are validated. If the table is updated, the status can change from Validated.   Error – The table couldn't be validated because of an unexpected error.   Pending validation – The table is waiting validation.   Preparing table – Preparing the table enabled in the migration task for validation.   Pending revalidation – All rows in the table are pending validation after the table was updated.  
        public let validationState: String?
        /// Additional details about the state of validation.
        public let validationStateDetails: String?
        /// The number of records that couldn't be validated.
        public let validationSuspendedRecords: Int64?

        public init(ddls: Int64? = nil, deletes: Int64? = nil, fullLoadCondtnlChkFailedRows: Int64? = nil, fullLoadEndTime: TimeStamp? = nil, fullLoadErrorRows: Int64? = nil, fullLoadReloaded: Bool? = nil, fullLoadRows: Int64? = nil, fullLoadStartTime: TimeStamp? = nil, inserts: Int64? = nil, lastUpdateTime: TimeStamp? = nil, schemaName: String? = nil, tableName: String? = nil, tableState: String? = nil, updates: Int64? = nil, validationFailedRecords: Int64? = nil, validationPendingRecords: Int64? = nil, validationState: String? = nil, validationStateDetails: String? = nil, validationSuspendedRecords: Int64? = nil) {
            self.ddls = ddls
            self.deletes = deletes
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadEndTime = fullLoadEndTime
            self.fullLoadErrorRows = fullLoadErrorRows
            self.fullLoadReloaded = fullLoadReloaded
            self.fullLoadRows = fullLoadRows
            self.fullLoadStartTime = fullLoadStartTime
            self.inserts = inserts
            self.lastUpdateTime = lastUpdateTime
            self.schemaName = schemaName
            self.tableName = tableName
            self.tableState = tableState
            self.updates = updates
            self.validationFailedRecords = validationFailedRecords
            self.validationPendingRecords = validationPendingRecords
            self.validationState = validationState
            self.validationStateDetails = validationStateDetails
            self.validationSuspendedRecords = validationSuspendedRecords
        }

        private enum CodingKeys: String, CodingKey {
            case ddls = "Ddls"
            case deletes = "Deletes"
            case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
            case fullLoadEndTime = "FullLoadEndTime"
            case fullLoadErrorRows = "FullLoadErrorRows"
            case fullLoadReloaded = "FullLoadReloaded"
            case fullLoadRows = "FullLoadRows"
            case fullLoadStartTime = "FullLoadStartTime"
            case inserts = "Inserts"
            case lastUpdateTime = "LastUpdateTime"
            case schemaName = "SchemaName"
            case tableName = "TableName"
            case tableState = "TableState"
            case updates = "Updates"
            case validationFailedRecords = "ValidationFailedRecords"
            case validationPendingRecords = "ValidationPendingRecords"
            case validationState = "ValidationState"
            case validationStateDetails = "ValidationStateDetails"
            case validationSuspendedRecords = "ValidationSuspendedRecords"
        }
    }

    public struct TableToReload: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SchemaName", required: true, type: .string), 
            AWSShapeMember(label: "TableName", required: true, type: .string)
        ]

        /// The schema name of the table to be reloaded.
        public let schemaName: String
        /// The table name of the table to be reloaded.
        public let tableName: String

        public init(schemaName: String, tableName: String) {
            self.schemaName = schemaName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case schemaName = "SchemaName"
            case tableName = "TableName"
        }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: false, type: .string), 
            AWSShapeMember(label: "Value", required: false, type: .string)
        ]

        /// A key is the required name of the tag. The string value can be 1-128 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let key: String?
        /// A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TestConnectionMessage: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointArn", required: true, type: .string), 
            AWSShapeMember(label: "ReplicationInstanceArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct TestConnectionResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Connection", required: false, type: .structure)
        ]

        /// The connection tested.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct VpcSecurityGroupMembership: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "VpcSecurityGroupId", required: false, type: .string)
        ]

        /// The status of the VPC security group.
        public let status: String?
        /// The VPC security group ID.
        public let vpcSecurityGroupId: String?

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }
}

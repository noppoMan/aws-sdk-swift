//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension GroundStation {
    //MARK: Enums

    public enum AngleUnits: String, CustomStringConvertible, Codable {
        case degreeAngle = "DEGREE_ANGLE"
        case radian = "RADIAN"
        public var description: String { return self.rawValue }
    }

    public enum BandwidthUnits: String, CustomStringConvertible, Codable {
        case ghz = "GHz"
        case mhz = "MHz"
        case khz = "kHz"
        public var description: String { return self.rawValue }
    }

    public enum ConfigCapabilityType: String, CustomStringConvertible, Codable {
        case antennaDownlink = "antenna-downlink"
        case antennaDownlinkDemodDecode = "antenna-downlink-demod-decode"
        case antennaUplink = "antenna-uplink"
        case dataflowEndpoint = "dataflow-endpoint"
        case tracking = "tracking"
        case uplinkEcho = "uplink-echo"
        public var description: String { return self.rawValue }
    }

    public enum ContactStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case awsCancelled = "AWS_CANCELLED"
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case failedToSchedule = "FAILED_TO_SCHEDULE"
        case pass = "PASS"
        case postpass = "POSTPASS"
        case prepass = "PREPASS"
        case scheduled = "SCHEDULED"
        case scheduling = "SCHEDULING"
        public var description: String { return self.rawValue }
    }

    public enum Criticality: String, CustomStringConvertible, Codable {
        case preferred = "PREFERRED"
        case removed = "REMOVED"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum EirpUnits: String, CustomStringConvertible, Codable {
        case dbw = "dBW"
        public var description: String { return self.rawValue }
    }

    public enum EndpointStatus: String, CustomStringConvertible, Codable {
        case created = "created"
        case creating = "creating"
        case deleted = "deleted"
        case deleting = "deleting"
        case failed = "failed"
        public var description: String { return self.rawValue }
    }

    public enum FrequencyUnits: String, CustomStringConvertible, Codable {
        case ghz = "GHz"
        case mhz = "MHz"
        case khz = "kHz"
        public var description: String { return self.rawValue }
    }

    public enum Polarization: String, CustomStringConvertible, Codable {
        case leftHand = "LEFT_HAND"
        case none = "NONE"
        case rightHand = "RIGHT_HAND"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AntennaDownlinkConfig: AWSEncodableShape & AWSDecodableShape {

        /// Object that describes a spectral Config.
        public let spectrumConfig: SpectrumConfig

        public init(spectrumConfig: SpectrumConfig) {
            self.spectrumConfig = spectrumConfig
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig = "spectrumConfig"
        }
    }

    public struct AntennaDownlinkDemodDecodeConfig: AWSEncodableShape & AWSDecodableShape {

        /// Information about the decode Config.
        public let decodeConfig: DecodeConfig
        /// Information about the demodulation Config.
        public let demodulationConfig: DemodulationConfig
        /// Information about the spectral Config.
        public let spectrumConfig: SpectrumConfig

        public init(decodeConfig: DecodeConfig, demodulationConfig: DemodulationConfig, spectrumConfig: SpectrumConfig) {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }

        public func validate(name: String) throws {
            try self.decodeConfig.validate(name: "\(name).decodeConfig")
            try self.demodulationConfig.validate(name: "\(name).demodulationConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case decodeConfig = "decodeConfig"
            case demodulationConfig = "demodulationConfig"
            case spectrumConfig = "spectrumConfig"
        }
    }

    public struct AntennaUplinkConfig: AWSEncodableShape & AWSDecodableShape {

        /// Information about the uplink spectral Config.
        public let spectrumConfig: UplinkSpectrumConfig
        /// EIRP of the target.
        public let targetEirp: Eirp

        public init(spectrumConfig: UplinkSpectrumConfig, targetEirp: Eirp) {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig = "spectrumConfig"
            case targetEirp = "targetEirp"
        }
    }

    public struct CancelContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri(locationName: "contactId"))
        ]

        /// UUID of a contact.
        public let contactId: String

        public init(contactId: String) {
            self.contactId = contactId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ConfigIdResponse: AWSDecodableShape {

        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?

        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: String, CodingKey {
            case configArn = "configArn"
            case configId = "configId"
            case configType = "configType"
        }
    }

    public struct ConfigListItem: AWSDecodableShape {

        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String?

        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, name: String? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case configArn = "configArn"
            case configId = "configId"
            case configType = "configType"
            case name = "name"
        }
    }

    public struct ConfigTypeData: AWSEncodableShape & AWSDecodableShape {

        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        public let antennaDownlinkConfig: AntennaDownlinkConfig?
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        public let antennaDownlinkDemodDecodeConfig: AntennaDownlinkDemodDecodeConfig?
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        public let antennaUplinkConfig: AntennaUplinkConfig?
        /// Information about the dataflow endpoint Config.
        public let dataflowEndpointConfig: DataflowEndpointConfig?
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile. 
        public let trackingConfig: TrackingConfig?
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        public let uplinkEchoConfig: UplinkEchoConfig?

        public init(antennaDownlinkConfig: AntennaDownlinkConfig? = nil, antennaDownlinkDemodDecodeConfig: AntennaDownlinkDemodDecodeConfig? = nil, antennaUplinkConfig: AntennaUplinkConfig? = nil, dataflowEndpointConfig: DataflowEndpointConfig? = nil, trackingConfig: TrackingConfig? = nil, uplinkEchoConfig: UplinkEchoConfig? = nil) {
            self.antennaDownlinkConfig = antennaDownlinkConfig
            self.antennaDownlinkDemodDecodeConfig = antennaDownlinkDemodDecodeConfig
            self.antennaUplinkConfig = antennaUplinkConfig
            self.dataflowEndpointConfig = dataflowEndpointConfig
            self.trackingConfig = trackingConfig
            self.uplinkEchoConfig = uplinkEchoConfig
        }

        public func validate(name: String) throws {
            try self.antennaDownlinkDemodDecodeConfig?.validate(name: "\(name).antennaDownlinkDemodDecodeConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case antennaDownlinkConfig = "antennaDownlinkConfig"
            case antennaDownlinkDemodDecodeConfig = "antennaDownlinkDemodDecodeConfig"
            case antennaUplinkConfig = "antennaUplinkConfig"
            case dataflowEndpointConfig = "dataflowEndpointConfig"
            case trackingConfig = "trackingConfig"
            case uplinkEchoConfig = "uplinkEchoConfig"
        }
    }

    public struct ContactData: AWSDecodableShape {

        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// End time of a contact.
        public let endTime: TimeStamp?
        /// Error message of a contact.
        public let errorMessage: String?
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: TimeStamp?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: TimeStamp?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact.
        public let startTime: TimeStamp?
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, endTime: TimeStamp? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: TimeStamp? = nil, prePassStartTime: TimeStamp? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: TimeStamp? = nil, tags: [String: String]? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "contactId"
            case contactStatus = "contactStatus"
            case endTime = "endTime"
            case errorMessage = "errorMessage"
            case groundStation = "groundStation"
            case maximumElevation = "maximumElevation"
            case missionProfileArn = "missionProfileArn"
            case postPassEndTime = "postPassEndTime"
            case prePassStartTime = "prePassStartTime"
            case region = "region"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case tags = "tags"
        }
    }

    public struct ContactIdResponse: AWSDecodableShape {

        /// UUID of a contact.
        public let contactId: String?

        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "contactId"
        }
    }

    public struct CreateConfigRequest: AWSEncodableShape {

        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        public init(configData: ConfigTypeData, name: String, tags: [String: String]? = nil) {
            self.configData = configData
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try validate(self.name, name:"name", parent: name, max: 256)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData = "configData"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateDataflowEndpointGroupRequest: AWSEncodableShape {

        /// Endpoint details of each endpoint in the dataflow endpoint group.
        public let endpointDetails: [EndpointDetails]
        /// Tags of a dataflow endpoint group.
        public let tags: [String: String]?

        public init(endpointDetails: [EndpointDetails], tags: [String: String]? = nil) {
            self.endpointDetails = endpointDetails
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.endpointDetails.forEach {
                try $0.validate(name: "\(name).endpointDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case endpointDetails = "endpointDetails"
            case tags = "tags"
        }
    }

    public struct CreateMissionProfileRequest: AWSEncodableShape {

        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
        public let dataflowEdges: [[String]]
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int
        /// Name of a mission profile.
        public let name: String
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]], minimumViableContactDurationSeconds: Int, name: String, tags: [String: String]? = nil, trackingConfigArn: String) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.name = name
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        public func validate(name: String) throws {
            try validate(self.contactPostPassDurationSeconds, name:"contactPostPassDurationSeconds", parent: name, max: 21600)
            try validate(self.contactPostPassDurationSeconds, name:"contactPostPassDurationSeconds", parent: name, min: 1)
            try validate(self.contactPrePassDurationSeconds, name:"contactPrePassDurationSeconds", parent: name, max: 21600)
            try validate(self.contactPrePassDurationSeconds, name:"contactPrePassDurationSeconds", parent: name, min: 1)
            try self.dataflowEdges.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try validate(self.minimumViableContactDurationSeconds, name:"minimumViableContactDurationSeconds", parent: name, max: 21600)
            try validate(self.minimumViableContactDurationSeconds, name:"minimumViableContactDurationSeconds", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 256)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case dataflowEdges = "dataflowEdges"
            case minimumViableContactDurationSeconds = "minimumViableContactDurationSeconds"
            case name = "name"
            case tags = "tags"
            case trackingConfigArn = "trackingConfigArn"
        }
    }

    public struct DataflowEndpoint: AWSEncodableShape & AWSDecodableShape {

        /// Socket address of a dataflow endpoint.
        public let address: SocketAddress?
        /// Name of a dataflow endpoint.
        public let name: String?
        /// Status of a dataflow endpoint.
        public let status: EndpointStatus?

        public init(address: SocketAddress? = nil, name: String? = nil, status: EndpointStatus? = nil) {
            self.address = address
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 256)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
            case name = "name"
            case status = "status"
        }
    }

    public struct DataflowEndpointConfig: AWSEncodableShape & AWSDecodableShape {

        /// Name of a dataflow endpoint.
        public let dataflowEndpointName: String
        /// Region of a dataflow endpoint.
        public let dataflowEndpointRegion: String?

        public init(dataflowEndpointName: String, dataflowEndpointRegion: String? = nil) {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointName = "dataflowEndpointName"
            case dataflowEndpointRegion = "dataflowEndpointRegion"
        }
    }

    public struct DataflowEndpointGroupIdResponse: AWSDecodableShape {

        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        public init(dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupId = "dataflowEndpointGroupId"
        }
    }

    public struct DataflowEndpointListItem: AWSDecodableShape {

        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        public init(dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupArn = "dataflowEndpointGroupArn"
            case dataflowEndpointGroupId = "dataflowEndpointGroupId"
        }
    }

    public struct DecodeConfig: AWSEncodableShape & AWSDecodableShape {

        /// Unvalidated JSON of a decode Config.
        public let unvalidatedJSON: String

        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try validate(self.unvalidatedJSON, name:"unvalidatedJSON", parent: name, max: 8192)
            try validate(self.unvalidatedJSON, name:"unvalidatedJSON", parent: name, min: 2)
            try validate(self.unvalidatedJSON, name:"unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON = "unvalidatedJSON"
        }
    }

    public struct DeleteConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "configId")), 
            AWSMemberEncoding(label: "configType", location: .uri(locationName: "configType"))
        ]

        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataflowEndpointGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataflowEndpointGroupId", location: .uri(locationName: "dataflowEndpointGroupId"))
        ]

        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri(locationName: "missionProfileId"))
        ]

        /// UUID of a mission profile.
        public let missionProfileId: String

        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DemodulationConfig: AWSEncodableShape & AWSDecodableShape {

        /// Unvalidated JSON of a demodulation Config.
        public let unvalidatedJSON: String

        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try validate(self.unvalidatedJSON, name:"unvalidatedJSON", parent: name, max: 8192)
            try validate(self.unvalidatedJSON, name:"unvalidatedJSON", parent: name, min: 2)
            try validate(self.unvalidatedJSON, name:"unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON = "unvalidatedJSON"
        }
    }

    public struct DescribeContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri(locationName: "contactId"))
        ]

        /// UUID of a contact.
        public let contactId: String

        public init(contactId: String) {
            self.contactId = contactId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactResponse: AWSDecodableShape {

        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// End time of a contact.
        public let endTime: TimeStamp?
        /// Error message for a contact.
        public let errorMessage: String?
        /// Ground station for a contact.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: TimeStamp?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: TimeStamp?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact.
        public let startTime: TimeStamp?
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, endTime: TimeStamp? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: TimeStamp? = nil, prePassStartTime: TimeStamp? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: TimeStamp? = nil, tags: [String: String]? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "contactId"
            case contactStatus = "contactStatus"
            case endTime = "endTime"
            case errorMessage = "errorMessage"
            case groundStation = "groundStation"
            case maximumElevation = "maximumElevation"
            case missionProfileArn = "missionProfileArn"
            case postPassEndTime = "postPassEndTime"
            case prePassStartTime = "prePassStartTime"
            case region = "region"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case tags = "tags"
        }
    }

    public struct Eirp: AWSEncodableShape & AWSDecodableShape {

        /// Units of an EIRP.
        public let units: EirpUnits
        /// Value of an EIRP.
        public let value: Double

        public init(units: EirpUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
            case value = "value"
        }
    }

    public struct Elevation: AWSDecodableShape {

        /// Elevation angle units.
        public let unit: AngleUnits
        /// Elevation angle value.
        public let value: Double

        public init(unit: AngleUnits, value: Double) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct EndpointDetails: AWSEncodableShape & AWSDecodableShape {

        /// A dataflow endpoint.
        public let endpoint: DataflowEndpoint?
        /// Endpoint security details.
        public let securityDetails: SecurityDetails?

        public init(endpoint: DataflowEndpoint? = nil, securityDetails: SecurityDetails? = nil) {
            self.endpoint = endpoint
            self.securityDetails = securityDetails
        }

        public func validate(name: String) throws {
            try self.endpoint?.validate(name: "\(name).endpoint")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
            case securityDetails = "securityDetails"
        }
    }

    public struct Frequency: AWSEncodableShape & AWSDecodableShape {

        /// Frequency units.
        public let units: FrequencyUnits
        /// Frequency value.
        public let value: Double

        public init(units: FrequencyUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
            case value = "value"
        }
    }

    public struct FrequencyBandwidth: AWSEncodableShape & AWSDecodableShape {

        /// Frequency bandwidth units.
        public let units: BandwidthUnits
        /// Frequency bandwidth value.
        public let value: Double

        public init(units: BandwidthUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
            case value = "value"
        }
    }

    public struct GetConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "configId")), 
            AWSMemberEncoding(label: "configType", location: .uri(locationName: "configType"))
        ]

        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigResponse: AWSDecodableShape {

        /// ARN of a Config 
        public let configArn: String
        /// Data elements in a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        public init(configArn: String, configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType? = nil, name: String, tags: [String: String]? = nil) {
            self.configArn = configArn
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configArn = "configArn"
            case configData = "configData"
            case configId = "configId"
            case configType = "configType"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetDataflowEndpointGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataflowEndpointGroupId", location: .uri(locationName: "dataflowEndpointGroupId"))
        ]

        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataflowEndpointGroupResponse: AWSDecodableShape {

        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?
        /// Details of a dataflow endpoint.
        public let endpointsDetails: [EndpointDetails]?
        /// Tags assigned to a dataflow endpoint group.
        public let tags: [String: String]?

        public init(dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil, endpointsDetails: [EndpointDetails]? = nil, tags: [String: String]? = nil) {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
            self.endpointsDetails = endpointsDetails
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupArn = "dataflowEndpointGroupArn"
            case dataflowEndpointGroupId = "dataflowEndpointGroupId"
            case endpointsDetails = "endpointsDetails"
            case tags = "tags"
        }
    }

    public struct GetMinuteUsageRequest: AWSEncodableShape {

        /// The month being requested, with a value of 1-12.
        public let month: Int
        /// The year being requested, in the format of YYYY.
        public let year: Int

        public init(month: Int, year: Int) {
            self.month = month
            self.year = year
        }

        private enum CodingKeys: String, CodingKey {
            case month = "month"
            case year = "year"
        }
    }

    public struct GetMinuteUsageResponse: AWSDecodableShape {

        /// Estimated number of minutes remaining for an account, specific to the month being requested.
        public let estimatedMinutesRemaining: Int?
        /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
        public let isReservedMinutesCustomer: Bool?
        /// Total number of reserved minutes allocated, specific to the month being requested.
        public let totalReservedMinuteAllocation: Int?
        /// Total scheduled minutes for an account, specific to the month being requested.
        public let totalScheduledMinutes: Int?
        /// Upcoming minutes scheduled for an account, specific to the month being requested.
        public let upcomingMinutesScheduled: Int?

        public init(estimatedMinutesRemaining: Int? = nil, isReservedMinutesCustomer: Bool? = nil, totalReservedMinuteAllocation: Int? = nil, totalScheduledMinutes: Int? = nil, upcomingMinutesScheduled: Int? = nil) {
            self.estimatedMinutesRemaining = estimatedMinutesRemaining
            self.isReservedMinutesCustomer = isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
            self.totalScheduledMinutes = totalScheduledMinutes
            self.upcomingMinutesScheduled = upcomingMinutesScheduled
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMinutesRemaining = "estimatedMinutesRemaining"
            case isReservedMinutesCustomer = "isReservedMinutesCustomer"
            case totalReservedMinuteAllocation = "totalReservedMinuteAllocation"
            case totalScheduledMinutes = "totalScheduledMinutes"
            case upcomingMinutesScheduled = "upcomingMinutesScheduled"
        }
    }

    public struct GetMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri(locationName: "missionProfileId"))
        ]

        /// UUID of a mission profile.
        public let missionProfileId: String

        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMissionProfileResponse: AWSDecodableShape {

        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil, tags: [String: String]? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case dataflowEdges = "dataflowEdges"
            case minimumViableContactDurationSeconds = "minimumViableContactDurationSeconds"
            case missionProfileArn = "missionProfileArn"
            case missionProfileId = "missionProfileId"
            case name = "name"
            case region = "region"
            case tags = "tags"
            case trackingConfigArn = "trackingConfigArn"
        }
    }

    public struct GetSatelliteRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "satelliteId", location: .uri(locationName: "satelliteId"))
        ]

        /// UUID of a satellite.
        public let satelliteId: String

        public init(satelliteId: String) {
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSatelliteResponse: AWSDecodableShape {

        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        public init(groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case groundStations = "groundStations"
            case noradSatelliteID = "noradSatelliteID"
            case satelliteArn = "satelliteArn"
            case satelliteId = "satelliteId"
        }
    }

    public struct GroundStationData: AWSDecodableShape {

        /// UUID of a ground station.
        public let groundStationId: String?
        /// Name of a ground station.
        public let groundStationName: String?
        /// Ground station Region.
        public let region: String?

        public init(groundStationId: String? = nil, groundStationName: String? = nil, region: String? = nil) {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationId = "groundStationId"
            case groundStationName = "groundStationName"
            case region = "region"
        }
    }

    public struct ListConfigsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of Configs returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigsResponse: AWSDecodableShape {

        /// List of Config items.
        public let configList: [ConfigListItem]?
        /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        public init(configList: [ConfigListItem]? = nil, nextToken: String? = nil) {
            self.configList = configList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configList = "configList"
            case nextToken = "nextToken"
        }
    }

    public struct ListContactsRequest: AWSEncodableShape {

        /// End time of a contact.
        public let endTime: TimeStamp
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum number of contacts returned.
        public let maxResults: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact.
        public let startTime: TimeStamp
        /// Status of a contact reservation.
        public let statusList: [ContactStatus]

        public init(endTime: TimeStamp, groundStation: String? = nil, maxResults: Int? = nil, missionProfileArn: String? = nil, nextToken: String? = nil, satelliteArn: String? = nil, startTime: TimeStamp, statusList: [ContactStatus]) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.maxResults = maxResults
            self.missionProfileArn = missionProfileArn
            self.nextToken = nextToken
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.statusList = statusList
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case groundStation = "groundStation"
            case maxResults = "maxResults"
            case missionProfileArn = "missionProfileArn"
            case nextToken = "nextToken"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case statusList = "statusList"
        }
    }

    public struct ListContactsResponse: AWSDecodableShape {

        /// List of contacts.
        public let contactList: [ContactData]?
        /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?

        public init(contactList: [ContactData]? = nil, nextToken: String? = nil) {
            self.contactList = contactList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactList = "contactList"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataflowEndpointGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of dataflow endpoint groups returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataflowEndpointGroupsResponse: AWSDecodableShape {

        /// A list of dataflow endpoint groups.
        public let dataflowEndpointGroupList: [DataflowEndpointListItem]?
        /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        public init(dataflowEndpointGroupList: [DataflowEndpointListItem]? = nil, nextToken: String? = nil) {
            self.dataflowEndpointGroupList = dataflowEndpointGroupList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupList = "dataflowEndpointGroupList"
            case nextToken = "nextToken"
        }
    }

    public struct ListGroundStationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")), 
            AWSMemberEncoding(label: "satelliteId", location: .querystring(locationName: "satelliteId"))
        ]

        /// Maximum number of ground stations returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?
        /// Satellite ID to retrieve on-boarded ground stations.
        public let satelliteId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, satelliteId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroundStationsResponse: AWSDecodableShape {

        /// List of ground stations.
        public let groundStationList: [GroundStationData]?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?

        public init(groundStationList: [GroundStationData]? = nil, nextToken: String? = nil) {
            self.groundStationList = groundStationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationList = "groundStationList"
            case nextToken = "nextToken"
        }
    }

    public struct ListMissionProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of mission profiles returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMissionProfilesResponse: AWSDecodableShape {

        /// List of mission profiles.
        public let missionProfileList: [MissionProfileListItem]?
        /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        public init(missionProfileList: [MissionProfileListItem]? = nil, nextToken: String? = nil) {
            self.missionProfileList = missionProfileList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileList = "missionProfileList"
            case nextToken = "nextToken"
        }
    }

    public struct ListSatellitesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")), 
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of satellites returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSatellitesResponse: AWSDecodableShape {

        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?
        /// List of satellites.
        public let satellites: [SatelliteListItem]?

        public init(nextToken: String? = nil, satellites: [SatelliteListItem]? = nil) {
            self.nextToken = nextToken
            self.satellites = satellites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case satellites = "satellites"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// ARN of a resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {

        /// Tags assigned to a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MissionProfileIdResponse: AWSDecodableShape {

        /// UUID of a mission profile.
        public let missionProfileId: String?

        public init(missionProfileId: String? = nil) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileId = "missionProfileId"
        }
    }

    public struct MissionProfileListItem: AWSDecodableShape {

        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?

        public init(missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil) {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileArn = "missionProfileArn"
            case missionProfileId = "missionProfileId"
            case name = "name"
            case region = "region"
        }
    }

    public struct ReserveContactRequest: AWSEncodableShape {

        /// End time of a contact.
        public let endTime: TimeStamp
        /// Name of a ground station.
        public let groundStation: String
        /// ARN of a mission profile.
        public let missionProfileArn: String
        /// ARN of a satellite
        public let satelliteArn: String
        /// Start time of a contact.
        public let startTime: TimeStamp
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(endTime: TimeStamp, groundStation: String, missionProfileArn: String, satelliteArn: String, startTime: TimeStamp, tags: [String: String]? = nil) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.missionProfileArn = missionProfileArn
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case groundStation = "groundStation"
            case missionProfileArn = "missionProfileArn"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case tags = "tags"
        }
    }

    public struct SatelliteListItem: AWSDecodableShape {

        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        public init(groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case groundStations = "groundStations"
            case noradSatelliteID = "noradSatelliteID"
            case satelliteArn = "satelliteArn"
            case satelliteId = "satelliteId"
        }
    }

    public struct SecurityDetails: AWSEncodableShape & AWSDecodableShape {

        /// ARN to a role needed for connecting streams to your instances. 
        public let roleArn: String
        /// The security groups to attach to the elastic network interfaces.
        public let securityGroupIds: [String]
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        public let subnetIds: [String]

        public init(roleArn: String, securityGroupIds: [String], subnetIds: [String]) {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct SocketAddress: AWSEncodableShape & AWSDecodableShape {

        /// Name of a socket address.
        public let name: String
        /// Port of a socket address.
        public let port: Int

        public init(name: String, port: Int) {
            self.name = name
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case port = "port"
        }
    }

    public struct SpectrumConfig: AWSEncodableShape & AWSDecodableShape {

        /// Bandwidth of a spectral Config.
        public let bandwidth: FrequencyBandwidth
        /// Center frequency of a spectral Config.
        public let centerFrequency: Frequency
        /// Polarization of a spectral Config.
        public let polarization: Polarization?

        public init(bandwidth: FrequencyBandwidth, centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "bandwidth"
            case centerFrequency = "centerFrequency"
            case polarization = "polarization"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// ARN of a resource tag.
        public let resourceArn: String
        /// Tags assigned to a resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct TrackingConfig: AWSEncodableShape & AWSDecodableShape {

        /// Current setting for autotrack.
        public let autotrack: Criticality

        public init(autotrack: Criticality) {
            self.autotrack = autotrack
        }

        private enum CodingKeys: String, CodingKey {
            case autotrack = "autotrack"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")), 
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// ARN of a resource.
        public let resourceArn: String
        /// Keys of a resource tag.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {


        public init() {
        }

    }

    public struct UpdateConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "configId")), 
            AWSMemberEncoding(label: "configType", location: .uri(locationName: "configType"))
        ]

        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType
        /// Name of a Config.
        public let name: String

        public init(configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType, name: String) {
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try validate(self.name, name:"name", parent: name, max: 256)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData = "configData"
            case name = "name"
        }
    }

    public struct UpdateMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri(locationName: "missionProfileId"))
        ]

        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// UUID of a mission profile.
        public let missionProfileId: String
        /// Name of a mission profile.
        public let name: String?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileId: String, name: String? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileId = missionProfileId
            self.name = name
            self.trackingConfigArn = trackingConfigArn
        }

        public func validate(name: String) throws {
            try validate(self.contactPostPassDurationSeconds, name:"contactPostPassDurationSeconds", parent: name, max: 21600)
            try validate(self.contactPostPassDurationSeconds, name:"contactPostPassDurationSeconds", parent: name, min: 1)
            try validate(self.contactPrePassDurationSeconds, name:"contactPrePassDurationSeconds", parent: name, max: 21600)
            try validate(self.contactPrePassDurationSeconds, name:"contactPrePassDurationSeconds", parent: name, min: 1)
            try self.dataflowEdges?.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try validate(self.minimumViableContactDurationSeconds, name:"minimumViableContactDurationSeconds", parent: name, max: 21600)
            try validate(self.minimumViableContactDurationSeconds, name:"minimumViableContactDurationSeconds", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, max: 256)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case dataflowEdges = "dataflowEdges"
            case minimumViableContactDurationSeconds = "minimumViableContactDurationSeconds"
            case name = "name"
            case trackingConfigArn = "trackingConfigArn"
        }
    }

    public struct UplinkEchoConfig: AWSEncodableShape & AWSDecodableShape {

        /// ARN of an uplink Config.
        public let antennaUplinkConfigArn: String
        /// Whether or not an uplink Config is enabled.
        public let enabled: Bool

        public init(antennaUplinkConfigArn: String, enabled: Bool) {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case antennaUplinkConfigArn = "antennaUplinkConfigArn"
            case enabled = "enabled"
        }
    }

    public struct UplinkSpectrumConfig: AWSEncodableShape & AWSDecodableShape {

        /// Center frequency of an uplink spectral Config.
        public let centerFrequency: Frequency
        /// Polarization of an uplink spectral Config.
        public let polarization: Polarization?

        public init(centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case centerFrequency = "centerFrequency"
            case polarization = "polarization"
        }
    }
}

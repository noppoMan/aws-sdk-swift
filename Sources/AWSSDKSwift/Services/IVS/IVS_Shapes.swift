// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension IVS {
    //MARK: Enums

    public enum ChannelLatencyMode: String, CustomStringConvertible, Codable {
        case normal = "NORMAL"
        case low = "LOW"
        public var description: String { return self.rawValue }
    }

    public enum ChannelType: String, CustomStringConvertible, Codable {
        case basic = "BASIC"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum StreamHealth: String, CustomStringConvertible, Codable {
        case healthy = "HEALTHY"
        case starving = "STARVING"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum StreamState: String, CustomStringConvertible, Codable {
        case live = "LIVE"
        case offline = "OFFLINE"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct BatchError: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "code", required: false, type: .string), 
            AWSShapeMember(label: "message", required: false, type: .string)
        ]

        /// Channel ARN.
        public let arn: String?
        /// Error code.
        public let code: String?
        /// Error message, determined by the application.
        public let message: String?

        public init(arn: String? = nil, code: String? = nil, message: String? = nil) {
            self.arn = arn
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case code = "code"
            case message = "message"
        }
    }

    public struct BatchGetChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arns", required: true, type: .list)
        ]

        /// Array of ARNs, one per channel.
        public let arns: [String]

        public init(arns: [String]) {
            self.arns = arns
        }

        public func validate(name: String) throws {
            try self.arns.forEach {
                try validate($0, name: "arns[]", parent: name, max: 128)
                try validate($0, name: "arns[]", parent: name, min: 1)
                try validate($0, name: "arns[]", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
            }
            try validate(self.arns, name:"arns", parent: name, max: 50)
            try validate(self.arns, name:"arns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arns = "arns"
        }
    }

    public struct BatchGetChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channels", required: false, type: .list), 
            AWSShapeMember(label: "errors", required: false, type: .list)
        ]

        public let channels: [Channel]?
        /// Each error object is related to a specific ARN in the request.
        public let errors: [BatchError]?

        public init(channels: [Channel]? = nil, errors: [BatchError]? = nil) {
            self.channels = channels
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case errors = "errors"
        }
    }

    public struct BatchGetStreamKeyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arns", required: true, type: .list)
        ]

        /// Array of ARNs, one per channel.
        public let arns: [String]

        public init(arns: [String]) {
            self.arns = arns
        }

        public func validate(name: String) throws {
            try self.arns.forEach {
                try validate($0, name: "arns[]", parent: name, max: 128)
                try validate($0, name: "arns[]", parent: name, min: 1)
                try validate($0, name: "arns[]", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:stream-key/[a-zA-Z0-9-]+$")
            }
            try validate(self.arns, name:"arns", parent: name, max: 50)
            try validate(self.arns, name:"arns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arns = "arns"
        }
    }

    public struct BatchGetStreamKeyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "errors", required: false, type: .list), 
            AWSShapeMember(label: "streamKeys", required: false, type: .list)
        ]

        public let errors: [BatchError]?
        public let streamKeys: [StreamKey]?

        public init(errors: [BatchError]? = nil, streamKeys: [StreamKey]? = nil) {
            self.errors = errors
            self.streamKeys = streamKeys
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case streamKeys = "streamKeys"
        }
    }

    public struct Channel: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "authorized", required: false, type: .boolean), 
            AWSShapeMember(label: "ingestEndpoint", required: false, type: .string), 
            AWSShapeMember(label: "latencyMode", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "playbackUrl", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]

        /// Channel ARN.
        public let arn: String?
        /// Whether the channel is authorized.
        public let authorized: Bool?
        /// Channel ingest endpoint, part of the definition of an ingest server, used when you set up streaming software.
        public let ingestEndpoint: String?
        /// Channel latency mode. Default: LOW.
        public let latencyMode: ChannelLatencyMode?
        /// Channel name.
        public let name: String?
        /// Channel playback URL.
        public let playbackUrl: String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public let tags: [String: String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable resolution or bitrate, the stream probably will disconnect immediately. Valid values:    STANDARD: Multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.    BASIC: Amazon IVS delivers the original input to viewers. The viewerâ€™s video-quality choice is limited to the original input. Vertical resolution can be up to 480 and bitrate can be up to 1.5 Mbps.   Default: STANDARD.
        public let `type`: ChannelType?

        public init(arn: String? = nil, authorized: Bool? = nil, ingestEndpoint: String? = nil, latencyMode: ChannelLatencyMode? = nil, name: String? = nil, playbackUrl: String? = nil, tags: [String: String]? = nil, type: ChannelType? = nil) {
            self.arn = arn
            self.authorized = authorized
            self.ingestEndpoint = ingestEndpoint
            self.latencyMode = latencyMode
            self.name = name
            self.playbackUrl = playbackUrl
            self.tags = tags
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorized = "authorized"
            case ingestEndpoint = "ingestEndpoint"
            case latencyMode = "latencyMode"
            case name = "name"
            case playbackUrl = "playbackUrl"
            case tags = "tags"
            case `type` = "type"
        }
    }

    public struct ChannelSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "authorized", required: false, type: .boolean), 
            AWSShapeMember(label: "latencyMode", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map)
        ]

        /// Channel ARN.
        public let arn: String?
        /// Whether the channel is authorized.
        public let authorized: Bool?
        /// Channel latency mode. Default: LOW.
        public let latencyMode: ChannelLatencyMode?
        /// Channel name.
        public let name: String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public let tags: [String: String]?

        public init(arn: String? = nil, authorized: Bool? = nil, latencyMode: ChannelLatencyMode? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorized = authorized
            self.latencyMode = latencyMode
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorized = "authorized"
            case latencyMode = "latencyMode"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "authorized", required: false, type: .boolean), 
            AWSShapeMember(label: "latencyMode", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]

        /// Whether the channel is authorized. Default: false.
        public let authorized: Bool?
        /// Channel latency mode. Default: LOW.
        public let latencyMode: ChannelLatencyMode?
        /// Channel name.
        public let name: String?
        /// See Channel$tags.
        public let tags: [String: String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable resolution or bitrate, the stream probably will disconnect immediately. Valid values:    STANDARD: Multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.    BASIC: Amazon IVS delivers the original input to viewers. The viewerâ€™s video-quality choice is limited to the original input. Vertical resolution can be up to 480 and bitrate can be up to 1.5 Mbps.   Default: STANDARD.
        public let `type`: ChannelType?

        public init(authorized: Bool? = nil, latencyMode: ChannelLatencyMode? = nil, name: String? = nil, tags: [String: String]? = nil, type: ChannelType? = nil) {
            self.authorized = authorized
            self.latencyMode = latencyMode
            self.name = name
            self.tags = tags
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 128)
            try validate(self.name, name:"name", parent: name, min: 0)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case authorized = "authorized"
            case latencyMode = "latencyMode"
            case name = "name"
            case tags = "tags"
            case `type` = "type"
        }
    }

    public struct CreateChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channel", required: false, type: .structure), 
            AWSShapeMember(label: "streamKey", required: false, type: .structure)
        ]

        public let channel: Channel?
        public let streamKey: StreamKey?

        public init(channel: Channel? = nil, streamKey: StreamKey? = nil) {
            self.channel = channel
            self.streamKey = streamKey
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
            case streamKey = "streamKey"
        }
    }

    public struct CreateStreamKeyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channelArn", required: true, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map)
        ]

        /// ARN of the channel for which to create the stream key.
        public let channelArn: String
        /// See Channel$tags.
        public let tags: [String: String]?

        public init(channelArn: String, tags: [String: String]? = nil) {
            self.channelArn = channelArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.channelArn, name:"channelArn", parent: name, max: 128)
            try validate(self.channelArn, name:"channelArn", parent: name, min: 1)
            try validate(self.channelArn, name:"channelArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
            case tags = "tags"
        }
    }

    public struct CreateStreamKeyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "streamKey", required: false, type: .structure)
        ]

        /// Stream key used to authenticate an RTMPS stream for ingestion.
        public let streamKey: StreamKey?

        public init(streamKey: StreamKey? = nil) {
            self.streamKey = streamKey
        }

        private enum CodingKeys: String, CodingKey {
            case streamKey = "streamKey"
        }
    }

    public struct DeleteChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]

        /// ARN of the channel to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, max: 128)
            try validate(self.arn, name:"arn", parent: name, min: 1)
            try validate(self.arn, name:"arn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeletePlaybackKeyPairRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]

        /// ARN of the key pair to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, max: 128)
            try validate(self.arn, name:"arn", parent: name, min: 1)
            try validate(self.arn, name:"arn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:playback-key/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeletePlaybackKeyPairResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteStreamKeyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]

        /// ARN of the stream key to be deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, max: 128)
            try validate(self.arn, name:"arn", parent: name, min: 1)
            try validate(self.arn, name:"arn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:stream-key/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]

        /// ARN of the channel for which the configuration is to be retrieved.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, max: 128)
            try validate(self.arn, name:"arn", parent: name, min: 1)
            try validate(self.arn, name:"arn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channel", required: false, type: .structure)
        ]

        public let channel: Channel?

        public init(channel: Channel? = nil) {
            self.channel = channel
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
        }
    }

    public struct GetPlaybackKeyPairRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]

        /// ARN of the key pair to be returned.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, max: 128)
            try validate(self.arn, name:"arn", parent: name, min: 1)
            try validate(self.arn, name:"arn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:playback-key/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetPlaybackKeyPairResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "keyPair", required: false, type: .structure)
        ]

        public let keyPair: PlaybackKeyPair?

        public init(keyPair: PlaybackKeyPair? = nil) {
            self.keyPair = keyPair
        }

        private enum CodingKeys: String, CodingKey {
            case keyPair = "keyPair"
        }
    }

    public struct GetStreamKeyRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string)
        ]

        /// ARN for the stream key to be retrieved.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, max: 128)
            try validate(self.arn, name:"arn", parent: name, min: 1)
            try validate(self.arn, name:"arn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:stream-key/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct GetStreamKeyResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "streamKey", required: false, type: .structure)
        ]

        public let streamKey: StreamKey?

        public init(streamKey: StreamKey? = nil) {
            self.streamKey = streamKey
        }

        private enum CodingKeys: String, CodingKey {
            case streamKey = "streamKey"
        }
    }

    public struct GetStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channelArn", required: true, type: .string)
        ]

        /// Channel ARN for stream to be accessed.
        public let channelArn: String

        public init(channelArn: String) {
            self.channelArn = channelArn
        }

        public func validate(name: String) throws {
            try validate(self.channelArn, name:"channelArn", parent: name, max: 128)
            try validate(self.channelArn, name:"channelArn", parent: name, min: 1)
            try validate(self.channelArn, name:"channelArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
        }
    }

    public struct GetStreamResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "stream", required: false, type: .structure)
        ]

        public let stream: Stream?

        public init(stream: Stream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream = "stream"
        }
    }

    public struct ImportPlaybackKeyPairRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "publicKeyMaterial", required: true, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map)
        ]

        /// An arbitrary string (a nickname) assigned to a playback key pair that helps the customer identify that resource. The value does not need to be unique.
        public let name: String?
        /// The public portion of a customer-generated key pair.
        public let publicKeyMaterial: String
        /// Any tags provided with the request are added to the playback key pair tags.
        public let tags: [String: String]?

        public init(name: String? = nil, publicKeyMaterial: String, tags: [String: String]? = nil) {
            self.name = name
            self.publicKeyMaterial = publicKeyMaterial
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 128)
            try validate(self.name, name:"name", parent: name, min: 0)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case publicKeyMaterial = "publicKeyMaterial"
            case tags = "tags"
        }
    }

    public struct ImportPlaybackKeyPairResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "keyPair", required: false, type: .structure)
        ]

        public let keyPair: PlaybackKeyPair?

        public init(keyPair: PlaybackKeyPair? = nil) {
            self.keyPair = keyPair
        }

        private enum CodingKeys: String, CodingKey {
            case keyPair = "keyPair"
        }
    }

    public struct ListChannelsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "filterByName", required: false, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// Filters the channel list to match the specified name.
        public let filterByName: String?
        /// Maximum number of channels to return.
        public let maxResults: Int?
        /// The first channel to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(filterByName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filterByName = filterByName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.filterByName, name:"filterByName", parent: name, max: 128)
            try validate(self.filterByName, name:"filterByName", parent: name, min: 0)
            try validate(self.filterByName, name:"filterByName", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 500)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filterByName = "filterByName"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListChannelsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channels", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// List of the matching channels.
        public let channels: [ChannelSummary]
        /// If there are more channels than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        public init(channels: [ChannelSummary], nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
            case nextToken = "nextToken"
        }
    }

    public struct ListPlaybackKeyPairsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The first key pair to retrieve. This is used for pagination; see the nextToken response field.
        public let maxResults: Int?
        /// Maximum number of key pairs to return.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 500)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListPlaybackKeyPairsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "keyPairs", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// List of key pairs.
        public let keyPairs: [PlaybackKeyPairSummary]
        /// If there are more key pairs than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?

        public init(keyPairs: [PlaybackKeyPairSummary], nextToken: String? = nil) {
            self.keyPairs = keyPairs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case keyPairs = "keyPairs"
            case nextToken = "nextToken"
        }
    }

    public struct ListStreamKeysRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channelArn", required: true, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// Channel ARN used to filter the list.
        public let channelArn: String
        /// Maximum number of streamKeys to return.
        public let maxResults: Int?
        /// The first stream key to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(channelArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.channelArn, name:"channelArn", parent: name, max: 128)
            try validate(self.channelArn, name:"channelArn", parent: name, min: 1)
            try validate(self.channelArn, name:"channelArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 500)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStreamKeysResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "streamKeys", required: true, type: .list)
        ]

        /// If there are more stream keys than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of stream keys.
        public let streamKeys: [StreamKeySummary]

        public init(nextToken: String? = nil, streamKeys: [StreamKeySummary]) {
            self.nextToken = nextToken
            self.streamKeys = streamKeys
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case streamKeys = "streamKeys"
        }
    }

    public struct ListStreamsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// Maximum number of streams to return.
        public let maxResults: Int?
        /// The first stream to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 500)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStreamsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "streams", required: true, type: .list)
        ]

        /// If there are more streams than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        /// List of streams.
        public let streams: [StreamSummary]

        public init(nextToken: String? = nil, streams: [StreamSummary]) {
            self.nextToken = nextToken
            self.streams = streams
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case streams = "streams"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "resourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string)
        ]

        /// Maximum number of tags to return.
        public let maxResults: Int?
        /// The first tag to retrieve. This is used for pagination; see the nextToken response field.
        public let nextToken: String?
        /// The ARN of the resource to be retrieved.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 50)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 128)
            try validate(self.resourceArn, name:"resourceArn", parent: name, min: 1)
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .map)
        ]

        /// If there are more tags than maxResults, use nextToken in the request to get the next set.
        public let nextToken: String?
        public let tags: [String: String]

        public init(nextToken: String? = nil, tags: [String: String]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct PlaybackKeyPair: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "fingerprint", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map)
        ]

        /// Key-pair ARN.
        public let arn: String?
        /// Key-pair identifier.
        public let fingerprint: String?
        /// Key-pair name.
        public let name: String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public let tags: [String: String]?

        public init(arn: String? = nil, fingerprint: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.fingerprint = fingerprint
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case fingerprint = "fingerprint"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct PlaybackKeyPairSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map)
        ]

        /// Key-pair ARN.
        public let arn: String?
        /// Key-pair name.
        public let name: String?
        /// Array of 1-50 maps, each of the form string:string (key:value) 
        public let tags: [String: String]?

        public init(arn: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct PutMetadataRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channelArn", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .string)
        ]

        /// ARN of the channel into which metadata is inserted. This channel must have an active stream.
        public let channelArn: String
        /// Metadata to insert into the stream. Maximum: 1 KB per request.
        public let metadata: String

        public init(channelArn: String, metadata: String) {
            self.channelArn = channelArn
            self.metadata = metadata
        }

        public func validate(name: String) throws {
            try validate(self.channelArn, name:"channelArn", parent: name, max: 128)
            try validate(self.channelArn, name:"channelArn", parent: name, min: 1)
            try validate(self.channelArn, name:"channelArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
            case metadata = "metadata"
        }
    }

    public struct StopStreamRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channelArn", required: true, type: .string)
        ]

        /// ARN of the channel for which the stream is to be stopped.
        public let channelArn: String

        public init(channelArn: String) {
            self.channelArn = channelArn
        }

        public func validate(name: String) throws {
            try validate(self.channelArn, name:"channelArn", parent: name, max: 128)
            try validate(self.channelArn, name:"channelArn", parent: name, min: 1)
            try validate(self.channelArn, name:"channelArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
        }
    }

    public struct StopStreamResponse: AWSShape {


        public init() {
        }

    }

    public struct Stream: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channelArn", required: false, type: .string), 
            AWSShapeMember(label: "health", required: false, type: .enum), 
            AWSShapeMember(label: "playbackUrl", required: false, type: .string), 
            AWSShapeMember(label: "startTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "state", required: false, type: .enum), 
            AWSShapeMember(label: "viewerCount", required: false, type: .long)
        ]

        /// Channel ARN for the stream.
        public let channelArn: String?
        /// The streamâ€™s health.
        public let health: StreamHealth?
        /// URL of the video master manifest, required by the video player to play the HLS stream.
        public let playbackUrl: String?
        /// ISO-8601 formatted timestamp of the streamâ€™s start.
        public let startTime: TimeStamp?
        /// The streamâ€™s state.
        public let state: StreamState?
        /// Number of current viewers of the stream.
        public let viewerCount: Int64?

        public init(channelArn: String? = nil, health: StreamHealth? = nil, playbackUrl: String? = nil, startTime: TimeStamp? = nil, state: StreamState? = nil, viewerCount: Int64? = nil) {
            self.channelArn = channelArn
            self.health = health
            self.playbackUrl = playbackUrl
            self.startTime = startTime
            self.state = state
            self.viewerCount = viewerCount
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
            case health = "health"
            case playbackUrl = "playbackUrl"
            case startTime = "startTime"
            case state = "state"
            case viewerCount = "viewerCount"
        }
    }

    public struct StreamKey: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "channelArn", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]

        /// Stream-key ARN.
        public let arn: String?
        /// Channel ARN for the stream.
        public let channelArn: String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public let tags: [String: String]?
        /// Stream-key value.
        public let value: String?

        public init(arn: String? = nil, channelArn: String? = nil, tags: [String: String]? = nil, value: String? = nil) {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelArn = "channelArn"
            case tags = "tags"
            case value = "value"
        }
    }

    public struct StreamKeySummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: false, type: .string), 
            AWSShapeMember(label: "channelArn", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .map)
        ]

        /// Stream-key ARN.
        public let arn: String?
        /// Channel ARN for the stream.
        public let channelArn: String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public let tags: [String: String]?

        public init(arn: String? = nil, channelArn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case channelArn = "channelArn"
            case tags = "tags"
        }
    }

    public struct StreamSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channelArn", required: false, type: .string), 
            AWSShapeMember(label: "health", required: false, type: .enum), 
            AWSShapeMember(label: "startTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "state", required: false, type: .enum), 
            AWSShapeMember(label: "viewerCount", required: false, type: .long)
        ]

        /// Channel ARN for the stream.
        public let channelArn: String?
        /// The streamâ€™s health.
        public let health: StreamHealth?
        /// ISO-8601 formatted timestamp of the streamâ€™s start.
        public let startTime: TimeStamp?
        /// The streamâ€™s state.
        public let state: StreamState?
        /// Number of current viewers of the stream.
        public let viewerCount: Int64?

        public init(channelArn: String? = nil, health: StreamHealth? = nil, startTime: TimeStamp? = nil, state: StreamState? = nil, viewerCount: Int64? = nil) {
            self.channelArn = channelArn
            self.health = health
            self.startTime = startTime
            self.state = state
            self.viewerCount = viewerCount
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "channelArn"
            case health = "health"
            case startTime = "startTime"
            case state = "state"
            case viewerCount = "viewerCount"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .map)
        ]

        /// ARN of the resource for which tags are to be added or updated.
        public let resourceArn: String
        /// Array of tags to be added or updated.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 128)
            try validate(self.resourceArn, name:"resourceArn", parent: name, min: 1)
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tags.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tagKeys", location: .querystring(locationName: "tagKeys"), required: true, type: .list)
        ]

        /// ARN of the resource for which tags are to be removed.
        public let resourceArn: String
        /// Array of tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 128)
            try validate(self.resourceArn, name:"resourceArn", parent: name, min: 1)
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:[a-z-]/[a-zA-Z0-9-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateChannelRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "authorized", required: false, type: .boolean), 
            AWSShapeMember(label: "latencyMode", required: false, type: .enum), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]

        /// ARN of the channel to be updated.
        public let arn: String
        /// Whether the channel is authorized. Default: false.
        public let authorized: Bool?
        /// Channel latency mode. Default: LOW.
        public let latencyMode: ChannelLatencyMode?
        /// Channel name.
        public let name: String?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable resolution or bitrate, the stream probably will disconnect immediately. Valid values:    STANDARD: Multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.    BASIC: Amazon IVS delivers the original input to viewers. The viewerâ€™s video-quality choice is limited to the original input. Vertical resolution can be up to 480 and bitrate can be up to 1.5 Mbps.   Default: STANDARD.
        public let `type`: ChannelType?

        public init(arn: String, authorized: Bool? = nil, latencyMode: ChannelLatencyMode? = nil, name: String? = nil, type: ChannelType? = nil) {
            self.arn = arn
            self.authorized = authorized
            self.latencyMode = latencyMode
            self.name = name
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.arn, name:"arn", parent: name, max: 128)
            try validate(self.arn, name:"arn", parent: name, min: 1)
            try validate(self.arn, name:"arn", parent: name, pattern: "^arn:aws:[is]vs:[a-z0-9-]+:[0-9]+:channel/[a-zA-Z0-9-]+$")
            try validate(self.name, name:"name", parent: name, max: 128)
            try validate(self.name, name:"name", parent: name, min: 0)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorized = "authorized"
            case latencyMode = "latencyMode"
            case name = "name"
            case `type` = "type"
        }
    }

    public struct UpdateChannelResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "channel", required: false, type: .structure)
        ]

        public let channel: Channel?

        public init(channel: Channel? = nil) {
            self.channel = channel
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "channel"
        }
    }
}

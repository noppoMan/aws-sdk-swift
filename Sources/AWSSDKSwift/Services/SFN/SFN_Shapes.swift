// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension SFN {
    //MARK: Enums

    public enum ExecutionStatus: String, CustomStringConvertible, Codable {
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        case failed = "FAILED"
        case timedOut = "TIMED_OUT"
        case aborted = "ABORTED"
        public var description: String { return self.rawValue }
    }

    public enum HistoryEventType: String, CustomStringConvertible, Codable {
        case activityfailed = "ActivityFailed"
        case activityscheduled = "ActivityScheduled"
        case activityschedulefailed = "ActivityScheduleFailed"
        case activitystarted = "ActivityStarted"
        case activitysucceeded = "ActivitySucceeded"
        case activitytimedout = "ActivityTimedOut"
        case choicestateentered = "ChoiceStateEntered"
        case choicestateexited = "ChoiceStateExited"
        case executionaborted = "ExecutionAborted"
        case executionfailed = "ExecutionFailed"
        case executionstarted = "ExecutionStarted"
        case executionsucceeded = "ExecutionSucceeded"
        case executiontimedout = "ExecutionTimedOut"
        case failstateentered = "FailStateEntered"
        case lambdafunctionfailed = "LambdaFunctionFailed"
        case lambdafunctionscheduled = "LambdaFunctionScheduled"
        case lambdafunctionschedulefailed = "LambdaFunctionScheduleFailed"
        case lambdafunctionstarted = "LambdaFunctionStarted"
        case lambdafunctionstartfailed = "LambdaFunctionStartFailed"
        case lambdafunctionsucceeded = "LambdaFunctionSucceeded"
        case lambdafunctiontimedout = "LambdaFunctionTimedOut"
        case mapiterationaborted = "MapIterationAborted"
        case mapiterationfailed = "MapIterationFailed"
        case mapiterationstarted = "MapIterationStarted"
        case mapiterationsucceeded = "MapIterationSucceeded"
        case mapstateaborted = "MapStateAborted"
        case mapstateentered = "MapStateEntered"
        case mapstateexited = "MapStateExited"
        case mapstatefailed = "MapStateFailed"
        case mapstatestarted = "MapStateStarted"
        case mapstatesucceeded = "MapStateSucceeded"
        case parallelstateaborted = "ParallelStateAborted"
        case parallelstateentered = "ParallelStateEntered"
        case parallelstateexited = "ParallelStateExited"
        case parallelstatefailed = "ParallelStateFailed"
        case parallelstatestarted = "ParallelStateStarted"
        case parallelstatesucceeded = "ParallelStateSucceeded"
        case passstateentered = "PassStateEntered"
        case passstateexited = "PassStateExited"
        case succeedstateentered = "SucceedStateEntered"
        case succeedstateexited = "SucceedStateExited"
        case taskfailed = "TaskFailed"
        case taskscheduled = "TaskScheduled"
        case taskstarted = "TaskStarted"
        case taskstartfailed = "TaskStartFailed"
        case taskstateaborted = "TaskStateAborted"
        case taskstateentered = "TaskStateEntered"
        case taskstateexited = "TaskStateExited"
        case tasksubmitfailed = "TaskSubmitFailed"
        case tasksubmitted = "TaskSubmitted"
        case tasksucceeded = "TaskSucceeded"
        case tasktimedout = "TaskTimedOut"
        case waitstateaborted = "WaitStateAborted"
        case waitstateentered = "WaitStateEntered"
        case waitstateexited = "WaitStateExited"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case error = "ERROR"
        case fatal = "FATAL"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum StateMachineStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum StateMachineType: String, CustomStringConvertible, Codable {
        case standard = "STANDARD"
        case express = "EXPRESS"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct ActivityFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ActivityListItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activityArn", required: true, type: .string), 
            AWSShapeMember(label: "creationDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) that identifies the activity.
        public let activityArn: String
        /// The date the activity is created.
        public let creationDate: TimeStamp
        /// The name of the activity. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String

        public init(activityArn: String, creationDate: TimeStamp, name: String) {
            self.activityArn = activityArn
            self.creationDate = creationDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case creationDate = "creationDate"
            case name = "name"
        }
    }

    public struct ActivityScheduleFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ActivityScheduledEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "heartbeatInSeconds", required: false, type: .long), 
            AWSShapeMember(label: "input", required: false, type: .string), 
            AWSShapeMember(label: "inputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "timeoutInSeconds", required: false, type: .long)
        ]

        /// The maximum allowed duration between two heartbeats for the activity task.
        public let heartbeatInSeconds: Int64?
        /// The JSON data input to the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about the input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled activity.
        public let resource: String
        /// The maximum allowed duration of the activity task.
        public let timeoutInSeconds: Int64?

        public init(heartbeatInSeconds: Int64? = nil, input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, timeoutInSeconds: Int64? = nil) {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.timeoutInSeconds = timeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case heartbeatInSeconds = "heartbeatInSeconds"
            case input = "input"
            case inputDetails = "inputDetails"
            case resource = "resource"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct ActivityStartedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "workerName", required: false, type: .string)
        ]

        /// The name of the worker that the task is assigned to. These names are provided by the workers when calling GetActivityTask.
        public let workerName: String?

        public init(workerName: String? = nil) {
            self.workerName = workerName
        }

        private enum CodingKeys: String, CodingKey {
            case workerName = "workerName"
        }
    }

    public struct ActivitySucceededEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "output", required: false, type: .string), 
            AWSShapeMember(label: "outputDetails", required: false, type: .structure)
        ]

        /// The JSON data output by the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct ActivityTimedOutEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the timeout.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct CloudWatchEventsExecutionDataDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "included", required: false, type: .boolean)
        ]

        /// Indicates whether input or output was included in the response. Always true for API calls, but may be false for CloudWatch Events.
        public let included: Bool?

        public init(included: Bool? = nil) {
            self.included = included
        }

        private enum CodingKeys: String, CodingKey {
            case included = "included"
        }
    }

    public struct CloudWatchLogsLogGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "logGroupArn", required: false, type: .string)
        ]

        /// The ARN of the the CloudWatch log group to which you want your logs emitted to. The ARN must end with :* 
        public let logGroupArn: String?

        public init(logGroupArn: String? = nil) {
            self.logGroupArn = logGroupArn
        }

        public func validate(name: String) throws {
            try validate(self.logGroupArn, name:"logGroupArn", parent: name, max: 256)
            try validate(self.logGroupArn, name:"logGroupArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "logGroupArn"
        }
    }

    public struct CreateActivityInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]

        /// The name of the activity to create. This name must be unique for your AWS account and region for 90 days. For more information, see  Limits Related to State Machine Executions in the AWS Step Functions Developer Guide. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String
        /// The list of tags to add to a resource. An array of key-value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide, and Controlling Access Using IAM Tags. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
        public let tags: [Tag]?

        public init(name: String, tags: [Tag]? = nil) {
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 80)
            try validate(self.name, name:"name", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateActivityOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activityArn", required: true, type: .string), 
            AWSShapeMember(label: "creationDate", required: true, type: .timestamp)
        ]

        /// The Amazon Resource Name (ARN) that identifies the created activity.
        public let activityArn: String
        /// The date the activity is created.
        public let creationDate: TimeStamp

        public init(activityArn: String, creationDate: TimeStamp) {
            self.activityArn = activityArn
            self.creationDate = creationDate
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case creationDate = "creationDate"
        }
    }

    public struct CreateStateMachineInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "definition", required: true, type: .string), 
            AWSShapeMember(label: "loggingConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "type", required: false, type: .enum)
        ]

        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String
        /// Defines what execution history events are logged and where they are logged.  By default, the level is set to OFF. For more information see Log Levels in the AWS Step Functions User Guide. 
        public let loggingConfiguration: LoggingConfiguration?
        /// The name of the state machine.  A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role to use for this state machine.
        public let roleArn: String
        /// Tags to be added when creating a state machine. An array of key-value pairs. For more information, see Using Cost Allocation Tags in the AWS Billing and Cost Management User Guide, and Controlling Access Using IAM Tags. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// Determines whether a Standard or Express state machine is created. The default is STANDARD. You cannot update the type of a state machine once it has been created.
        public let `type`: StateMachineType?

        public init(definition: String, loggingConfiguration: LoggingConfiguration? = nil, name: String, roleArn: String, tags: [Tag]? = nil, type: StateMachineType? = nil) {
            self.definition = definition
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.definition, name:"definition", parent: name, max: 1048576)
            try validate(self.definition, name:"definition", parent: name, min: 1)
            try self.loggingConfiguration?.validate(name: "\(name).loggingConfiguration")
            try validate(self.name, name:"name", parent: name, max: 80)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.roleArn, name:"roleArn", parent: name, max: 256)
            try validate(self.roleArn, name:"roleArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case loggingConfiguration = "loggingConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case tags = "tags"
            case `type` = "type"
        }
    }

    public struct CreateStateMachineOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string)
        ]

        /// The date the state machine is created.
        public let creationDate: TimeStamp
        /// The Amazon Resource Name (ARN) that identifies the created state machine.
        public let stateMachineArn: String

        public init(creationDate: TimeStamp, stateMachineArn: String) {
            self.creationDate = creationDate
            self.stateMachineArn = stateMachineArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct DeleteActivityInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activityArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the activity to delete.
        public let activityArn: String

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

        public func validate(name: String) throws {
            try validate(self.activityArn, name:"activityArn", parent: name, max: 256)
            try validate(self.activityArn, name:"activityArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
        }
    }

    public struct DeleteActivityOutput: AWSShape {


        public init() {
        }

    }

    public struct DeleteStateMachineInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the state machine to delete.
        public let stateMachineArn: String

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, max: 256)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct DeleteStateMachineOutput: AWSShape {


        public init() {
        }

    }

    public struct DescribeActivityInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activityArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the activity to describe.
        public let activityArn: String

        public init(activityArn: String) {
            self.activityArn = activityArn
        }

        public func validate(name: String) throws {
            try validate(self.activityArn, name:"activityArn", parent: name, max: 256)
            try validate(self.activityArn, name:"activityArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
        }
    }

    public struct DescribeActivityOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activityArn", required: true, type: .string), 
            AWSShapeMember(label: "creationDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) that identifies the activity.
        public let activityArn: String
        /// The date the activity is created.
        public let creationDate: TimeStamp
        /// The name of the activity. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String

        public init(activityArn: String, creationDate: TimeStamp, name: String) {
            self.activityArn = activityArn
            self.creationDate = creationDate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case creationDate = "creationDate"
            case name = "name"
        }
    }

    public struct DescribeExecutionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the execution to describe.
        public let executionArn: String

        public init(executionArn: String) {
            self.executionArn = executionArn
        }

        public func validate(name: String) throws {
            try validate(self.executionArn, name:"executionArn", parent: name, max: 256)
            try validate(self.executionArn, name:"executionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
        }
    }

    public struct DescribeExecutionOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionArn", required: true, type: .string), 
            AWSShapeMember(label: "input", required: false, type: .string), 
            AWSShapeMember(label: "inputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "output", required: false, type: .string), 
            AWSShapeMember(label: "outputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "startDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string), 
            AWSShapeMember(label: "status", required: true, type: .enum), 
            AWSShapeMember(label: "stopDate", required: false, type: .timestamp)
        ]

        /// The Amazon Resource Name (ARN) that id entifies the execution.
        public let executionArn: String
        /// The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        public let inputDetails: CloudWatchEventsExecutionDataDetails?
        /// The name of the execution. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String?
        /// The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.  This field is set only if the execution succeeds. If the execution fails, this field is null. 
        public let output: String?
        public let outputDetails: CloudWatchEventsExecutionDataDetails?
        /// The date the execution is started.
        public let startDate: TimeStamp
        /// The Amazon Resource Name (ARN) of the executed stated machine.
        public let stateMachineArn: String
        /// The current status of the execution.
        public let status: ExecutionStatus
        /// If the execution has already ended, the date the execution stopped.
        public let stopDate: TimeStamp?

        public init(executionArn: String, input: String? = nil, inputDetails: CloudWatchEventsExecutionDataDetails? = nil, name: String? = nil, output: String? = nil, outputDetails: CloudWatchEventsExecutionDataDetails? = nil, startDate: TimeStamp, stateMachineArn: String, status: ExecutionStatus, stopDate: TimeStamp? = nil) {
            self.executionArn = executionArn
            self.input = input
            self.inputDetails = inputDetails
            self.name = name
            self.output = output
            self.outputDetails = outputDetails
            self.startDate = startDate
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.stopDate = stopDate
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case input = "input"
            case inputDetails = "inputDetails"
            case name = "name"
            case output = "output"
            case outputDetails = "outputDetails"
            case startDate = "startDate"
            case stateMachineArn = "stateMachineArn"
            case status = "status"
            case stopDate = "stopDate"
        }
    }

    public struct DescribeStateMachineForExecutionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the execution you want state machine information for.
        public let executionArn: String

        public init(executionArn: String) {
            self.executionArn = executionArn
        }

        public func validate(name: String) throws {
            try validate(self.executionArn, name:"executionArn", parent: name, max: 256)
            try validate(self.executionArn, name:"executionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
        }
    }

    public struct DescribeStateMachineForExecutionOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "definition", required: true, type: .string), 
            AWSShapeMember(label: "loggingConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string), 
            AWSShapeMember(label: "updateDate", required: true, type: .timestamp)
        ]

        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String
        public let loggingConfiguration: LoggingConfiguration?
        /// The name of the state machine associated with the execution.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role of the State Machine for the execution. 
        public let roleArn: String
        /// The Amazon Resource Name (ARN) of the state machine associated with the execution.
        public let stateMachineArn: String
        /// The date and time the state machine associated with an execution was updated. For a newly created state machine, this is the creation date.
        public let updateDate: TimeStamp

        public init(definition: String, loggingConfiguration: LoggingConfiguration? = nil, name: String, roleArn: String, stateMachineArn: String, updateDate: TimeStamp) {
            self.definition = definition
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
            self.updateDate = updateDate
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case loggingConfiguration = "loggingConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case stateMachineArn = "stateMachineArn"
            case updateDate = "updateDate"
        }
    }

    public struct DescribeStateMachineInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the state machine to describe.
        public let stateMachineArn: String

        public init(stateMachineArn: String) {
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, max: 256)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct DescribeStateMachineOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "definition", required: true, type: .string), 
            AWSShapeMember(label: "loggingConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string), 
            AWSShapeMember(label: "status", required: false, type: .enum), 
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]

        /// The date the state machine is created.
        public let creationDate: TimeStamp
        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String
        public let loggingConfiguration: LoggingConfiguration?
        /// The name of the state machine. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String
        /// The Amazon Resource Name (ARN) of the IAM role used when creating this state machine. (The IAM role maintains security by granting Step Functions access to AWS resources.)
        public let roleArn: String
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        public let stateMachineArn: String
        /// The current status of the state machine.
        public let status: StateMachineStatus?
        /// The type of the state machine (STANDARD or EXPRESS).
        public let `type`: StateMachineType

        public init(creationDate: TimeStamp, definition: String, loggingConfiguration: LoggingConfiguration? = nil, name: String, roleArn: String, stateMachineArn: String, status: StateMachineStatus? = nil, type: StateMachineType) {
            self.creationDate = creationDate
            self.definition = definition
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case definition = "definition"
            case loggingConfiguration = "loggingConfiguration"
            case name = "name"
            case roleArn = "roleArn"
            case stateMachineArn = "stateMachineArn"
            case status = "status"
            case `type` = "type"
        }
    }

    public struct ExecutionAbortedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ExecutionFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ExecutionListItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionArn", required: true, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "startDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string), 
            AWSShapeMember(label: "status", required: true, type: .enum), 
            AWSShapeMember(label: "stopDate", required: false, type: .timestamp)
        ]

        /// The Amazon Resource Name (ARN) that id entifies the execution.
        public let executionArn: String
        /// The name of the execution. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String
        /// The date the execution started.
        public let startDate: TimeStamp
        /// The Amazon Resource Name (ARN) of the executed state machine.
        public let stateMachineArn: String
        /// The current status of the execution.
        public let status: ExecutionStatus
        /// If the execution already ended, the date the execution stopped.
        public let stopDate: TimeStamp?

        public init(executionArn: String, name: String, startDate: TimeStamp, stateMachineArn: String, status: ExecutionStatus, stopDate: TimeStamp? = nil) {
            self.executionArn = executionArn
            self.name = name
            self.startDate = startDate
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.stopDate = stopDate
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case name = "name"
            case startDate = "startDate"
            case stateMachineArn = "stateMachineArn"
            case status = "status"
            case stopDate = "stopDate"
        }
    }

    public struct ExecutionStartedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "input", required: false, type: .string), 
            AWSShapeMember(label: "inputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "roleArn", required: false, type: .string)
        ]

        /// The JSON data input to the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about the input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the IAM role used for executing AWS Lambda tasks.
        public let roleArn: String?

        public init(input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, roleArn: String? = nil) {
            self.input = input
            self.inputDetails = inputDetails
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case inputDetails = "inputDetails"
            case roleArn = "roleArn"
        }
    }

    public struct ExecutionSucceededEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "output", required: false, type: .string), 
            AWSShapeMember(label: "outputDetails", required: false, type: .structure)
        ]

        /// The JSON data output by the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct ExecutionTimedOutEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the timeout.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct GetActivityTaskInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activityArn", required: true, type: .string), 
            AWSShapeMember(label: "workerName", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the activity to retrieve tasks from (assigned when you create the task using CreateActivity.)
        public let activityArn: String
        /// You can provide an arbitrary name in order to identify the worker that the task is assigned to. This name is used when it is logged in the execution history.
        public let workerName: String?

        public init(activityArn: String, workerName: String? = nil) {
            self.activityArn = activityArn
            self.workerName = workerName
        }

        public func validate(name: String) throws {
            try validate(self.activityArn, name:"activityArn", parent: name, max: 256)
            try validate(self.activityArn, name:"activityArn", parent: name, min: 1)
            try validate(self.workerName, name:"workerName", parent: name, max: 80)
            try validate(self.workerName, name:"workerName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case activityArn = "activityArn"
            case workerName = "workerName"
        }
    }

    public struct GetActivityTaskOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "input", required: false, type: .string), 
            AWSShapeMember(label: "taskToken", required: false, type: .string)
        ]

        /// The string that contains the JSON input data for the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// A token that identifies the scheduled task. This token must be copied and included in subsequent calls to SendTaskHeartbeat, SendTaskSuccess or SendTaskFailure in order to report the progress or completion of the task.
        public let taskToken: String?

        public init(input: String? = nil, taskToken: String? = nil) {
            self.input = input
            self.taskToken = taskToken
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case taskToken = "taskToken"
        }
    }

    public struct GetExecutionHistoryInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionArn", required: true, type: .string), 
            AWSShapeMember(label: "includeExecutionData", required: false, type: .boolean), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "reverseOrder", required: false, type: .boolean)
        ]

        /// The Amazon Resource Name (ARN) of the execution.
        public let executionArn: String
        /// You can select whether execution data (input or output of a history event) is returned. The default is true.
        public let includeExecutionData: Bool?
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// Lists events in descending order of their timeStamp.
        public let reverseOrder: Bool?

        public init(executionArn: String, includeExecutionData: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, reverseOrder: Bool? = nil) {
            self.executionArn = executionArn
            self.includeExecutionData = includeExecutionData
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.reverseOrder = reverseOrder
        }

        public func validate(name: String) throws {
            try validate(self.executionArn, name:"executionArn", parent: name, max: 256)
            try validate(self.executionArn, name:"executionArn", parent: name, min: 1)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 0)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case includeExecutionData = "includeExecutionData"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case reverseOrder = "reverseOrder"
        }
    }

    public struct GetExecutionHistoryOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "events", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of events that occurred in the execution.
        public let events: [HistoryEvent]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(events: [HistoryEvent], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct HistoryEvent: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activityFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "activityScheduledEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "activityScheduleFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "activityStartedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "activitySucceededEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "activityTimedOutEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "executionAbortedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "executionFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "executionStartedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "executionSucceededEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "executionTimedOutEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "id", required: true, type: .long), 
            AWSShapeMember(label: "lambdaFunctionFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "lambdaFunctionScheduledEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "lambdaFunctionScheduleFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "lambdaFunctionStartFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "lambdaFunctionSucceededEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "lambdaFunctionTimedOutEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "mapIterationAbortedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "mapIterationFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "mapIterationStartedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "mapIterationSucceededEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "mapStateStartedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "previousEventId", required: false, type: .long), 
            AWSShapeMember(label: "stateEnteredEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "stateExitedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskScheduledEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskStartedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskStartFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskSubmitFailedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskSubmittedEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskSucceededEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "taskTimedOutEventDetails", required: false, type: .structure), 
            AWSShapeMember(label: "timestamp", required: true, type: .timestamp), 
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]

        public let activityFailedEventDetails: ActivityFailedEventDetails?
        public let activityScheduledEventDetails: ActivityScheduledEventDetails?
        /// Contains details about an activity schedule event that failed during an execution.
        public let activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails?
        public let activityStartedEventDetails: ActivityStartedEventDetails?
        public let activitySucceededEventDetails: ActivitySucceededEventDetails?
        public let activityTimedOutEventDetails: ActivityTimedOutEventDetails?
        public let executionAbortedEventDetails: ExecutionAbortedEventDetails?
        public let executionFailedEventDetails: ExecutionFailedEventDetails?
        public let executionStartedEventDetails: ExecutionStartedEventDetails?
        public let executionSucceededEventDetails: ExecutionSucceededEventDetails?
        public let executionTimedOutEventDetails: ExecutionTimedOutEventDetails?
        /// The id of the event. Events are numbered sequentially, starting at one.
        public let id: Int64
        public let lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails?
        public let lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails?
        public let lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails?
        /// Contains details about a lambda function that failed to start during an execution.
        public let lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails?
        /// Contains details about a lambda function that terminated successfully during an execution.
        public let lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails?
        public let lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails?
        /// Contains details about an iteration of a Map state that was aborted.
        public let mapIterationAbortedEventDetails: MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that failed.
        public let mapIterationFailedEventDetails: MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that was started.
        public let mapIterationStartedEventDetails: MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that succeeded.
        public let mapIterationSucceededEventDetails: MapIterationEventDetails?
        /// Contains details about Map state that was started.
        public let mapStateStartedEventDetails: MapStateStartedEventDetails?
        /// The id of the previous event.
        public let previousEventId: Int64?
        public let stateEnteredEventDetails: StateEnteredEventDetails?
        public let stateExitedEventDetails: StateExitedEventDetails?
        /// Contains details about the failure of a task.
        public let taskFailedEventDetails: TaskFailedEventDetails?
        /// Contains details about a task that was scheduled.
        public let taskScheduledEventDetails: TaskScheduledEventDetails?
        /// Contains details about a task that was started.
        public let taskStartedEventDetails: TaskStartedEventDetails?
        /// Contains details about a task that failed to start.
        public let taskStartFailedEventDetails: TaskStartFailedEventDetails?
        /// Contains details about a task that where the submit failed.
        public let taskSubmitFailedEventDetails: TaskSubmitFailedEventDetails?
        /// Contains details about a submitted task.
        public let taskSubmittedEventDetails: TaskSubmittedEventDetails?
        /// Contains details about a task that succeeded.
        public let taskSucceededEventDetails: TaskSucceededEventDetails?
        /// Contains details about a task that timed out.
        public let taskTimedOutEventDetails: TaskTimedOutEventDetails?
        /// The date and time the event occurred.
        public let timestamp: TimeStamp
        /// The type of the event.
        public let `type`: HistoryEventType

        public init(activityFailedEventDetails: ActivityFailedEventDetails? = nil, activityScheduledEventDetails: ActivityScheduledEventDetails? = nil, activityScheduleFailedEventDetails: ActivityScheduleFailedEventDetails? = nil, activityStartedEventDetails: ActivityStartedEventDetails? = nil, activitySucceededEventDetails: ActivitySucceededEventDetails? = nil, activityTimedOutEventDetails: ActivityTimedOutEventDetails? = nil, executionAbortedEventDetails: ExecutionAbortedEventDetails? = nil, executionFailedEventDetails: ExecutionFailedEventDetails? = nil, executionStartedEventDetails: ExecutionStartedEventDetails? = nil, executionSucceededEventDetails: ExecutionSucceededEventDetails? = nil, executionTimedOutEventDetails: ExecutionTimedOutEventDetails? = nil, id: Int64, lambdaFunctionFailedEventDetails: LambdaFunctionFailedEventDetails? = nil, lambdaFunctionScheduledEventDetails: LambdaFunctionScheduledEventDetails? = nil, lambdaFunctionScheduleFailedEventDetails: LambdaFunctionScheduleFailedEventDetails? = nil, lambdaFunctionStartFailedEventDetails: LambdaFunctionStartFailedEventDetails? = nil, lambdaFunctionSucceededEventDetails: LambdaFunctionSucceededEventDetails? = nil, lambdaFunctionTimedOutEventDetails: LambdaFunctionTimedOutEventDetails? = nil, mapIterationAbortedEventDetails: MapIterationEventDetails? = nil, mapIterationFailedEventDetails: MapIterationEventDetails? = nil, mapIterationStartedEventDetails: MapIterationEventDetails? = nil, mapIterationSucceededEventDetails: MapIterationEventDetails? = nil, mapStateStartedEventDetails: MapStateStartedEventDetails? = nil, previousEventId: Int64? = nil, stateEnteredEventDetails: StateEnteredEventDetails? = nil, stateExitedEventDetails: StateExitedEventDetails? = nil, taskFailedEventDetails: TaskFailedEventDetails? = nil, taskScheduledEventDetails: TaskScheduledEventDetails? = nil, taskStartedEventDetails: TaskStartedEventDetails? = nil, taskStartFailedEventDetails: TaskStartFailedEventDetails? = nil, taskSubmitFailedEventDetails: TaskSubmitFailedEventDetails? = nil, taskSubmittedEventDetails: TaskSubmittedEventDetails? = nil, taskSucceededEventDetails: TaskSucceededEventDetails? = nil, taskTimedOutEventDetails: TaskTimedOutEventDetails? = nil, timestamp: TimeStamp, type: HistoryEventType) {
            self.activityFailedEventDetails = activityFailedEventDetails
            self.activityScheduledEventDetails = activityScheduledEventDetails
            self.activityScheduleFailedEventDetails = activityScheduleFailedEventDetails
            self.activityStartedEventDetails = activityStartedEventDetails
            self.activitySucceededEventDetails = activitySucceededEventDetails
            self.activityTimedOutEventDetails = activityTimedOutEventDetails
            self.executionAbortedEventDetails = executionAbortedEventDetails
            self.executionFailedEventDetails = executionFailedEventDetails
            self.executionStartedEventDetails = executionStartedEventDetails
            self.executionSucceededEventDetails = executionSucceededEventDetails
            self.executionTimedOutEventDetails = executionTimedOutEventDetails
            self.id = id
            self.lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails
            self.lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails
            self.lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails
            self.lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails
            self.lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails
            self.lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails
            self.mapIterationAbortedEventDetails = mapIterationAbortedEventDetails
            self.mapIterationFailedEventDetails = mapIterationFailedEventDetails
            self.mapIterationStartedEventDetails = mapIterationStartedEventDetails
            self.mapIterationSucceededEventDetails = mapIterationSucceededEventDetails
            self.mapStateStartedEventDetails = mapStateStartedEventDetails
            self.previousEventId = previousEventId
            self.stateEnteredEventDetails = stateEnteredEventDetails
            self.stateExitedEventDetails = stateExitedEventDetails
            self.taskFailedEventDetails = taskFailedEventDetails
            self.taskScheduledEventDetails = taskScheduledEventDetails
            self.taskStartedEventDetails = taskStartedEventDetails
            self.taskStartFailedEventDetails = taskStartFailedEventDetails
            self.taskSubmitFailedEventDetails = taskSubmitFailedEventDetails
            self.taskSubmittedEventDetails = taskSubmittedEventDetails
            self.taskSucceededEventDetails = taskSucceededEventDetails
            self.taskTimedOutEventDetails = taskTimedOutEventDetails
            self.timestamp = timestamp
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case activityFailedEventDetails = "activityFailedEventDetails"
            case activityScheduledEventDetails = "activityScheduledEventDetails"
            case activityScheduleFailedEventDetails = "activityScheduleFailedEventDetails"
            case activityStartedEventDetails = "activityStartedEventDetails"
            case activitySucceededEventDetails = "activitySucceededEventDetails"
            case activityTimedOutEventDetails = "activityTimedOutEventDetails"
            case executionAbortedEventDetails = "executionAbortedEventDetails"
            case executionFailedEventDetails = "executionFailedEventDetails"
            case executionStartedEventDetails = "executionStartedEventDetails"
            case executionSucceededEventDetails = "executionSucceededEventDetails"
            case executionTimedOutEventDetails = "executionTimedOutEventDetails"
            case id = "id"
            case lambdaFunctionFailedEventDetails = "lambdaFunctionFailedEventDetails"
            case lambdaFunctionScheduledEventDetails = "lambdaFunctionScheduledEventDetails"
            case lambdaFunctionScheduleFailedEventDetails = "lambdaFunctionScheduleFailedEventDetails"
            case lambdaFunctionStartFailedEventDetails = "lambdaFunctionStartFailedEventDetails"
            case lambdaFunctionSucceededEventDetails = "lambdaFunctionSucceededEventDetails"
            case lambdaFunctionTimedOutEventDetails = "lambdaFunctionTimedOutEventDetails"
            case mapIterationAbortedEventDetails = "mapIterationAbortedEventDetails"
            case mapIterationFailedEventDetails = "mapIterationFailedEventDetails"
            case mapIterationStartedEventDetails = "mapIterationStartedEventDetails"
            case mapIterationSucceededEventDetails = "mapIterationSucceededEventDetails"
            case mapStateStartedEventDetails = "mapStateStartedEventDetails"
            case previousEventId = "previousEventId"
            case stateEnteredEventDetails = "stateEnteredEventDetails"
            case stateExitedEventDetails = "stateExitedEventDetails"
            case taskFailedEventDetails = "taskFailedEventDetails"
            case taskScheduledEventDetails = "taskScheduledEventDetails"
            case taskStartedEventDetails = "taskStartedEventDetails"
            case taskStartFailedEventDetails = "taskStartFailedEventDetails"
            case taskSubmitFailedEventDetails = "taskSubmitFailedEventDetails"
            case taskSubmittedEventDetails = "taskSubmittedEventDetails"
            case taskSucceededEventDetails = "taskSucceededEventDetails"
            case taskTimedOutEventDetails = "taskTimedOutEventDetails"
            case timestamp = "timestamp"
            case `type` = "type"
        }
    }

    public struct HistoryEventExecutionDataDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "truncated", required: false, type: .boolean)
        ]

        /// Indicates whether input or output was truncated in the response. Always false.
        public let truncated: Bool?

        public init(truncated: Bool? = nil) {
            self.truncated = truncated
        }

        private enum CodingKeys: String, CodingKey {
            case truncated = "truncated"
        }
    }

    public struct LambdaFunctionFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct LambdaFunctionScheduleFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct LambdaFunctionScheduledEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "input", required: false, type: .string), 
            AWSShapeMember(label: "inputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "timeoutInSeconds", required: false, type: .long)
        ]

        /// The JSON data input to the lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled lambda function.
        public let resource: String
        /// The maximum allowed duration of the lambda function.
        public let timeoutInSeconds: Int64?

        public init(input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, timeoutInSeconds: Int64? = nil) {
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.timeoutInSeconds = timeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case inputDetails = "inputDetails"
            case resource = "resource"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct LambdaFunctionStartFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct LambdaFunctionSucceededEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "output", required: false, type: .string), 
            AWSShapeMember(label: "outputDetails", required: false, type: .structure)
        ]

        /// The JSON data output by the lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct LambdaFunctionTimedOutEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string)
        ]

        /// A more detailed explanation of the cause of the timeout.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?

        public init(cause: String? = nil, error: String? = nil) {
            self.cause = cause
            self.error = error
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
        }
    }

    public struct ListActivitiesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 0)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListActivitiesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "activities", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of activities.
        public let activities: [ActivityListItem]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(activities: [ActivityListItem], nextToken: String? = nil) {
            self.activities = activities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case activities = "activities"
            case nextToken = "nextToken"
        }
    }

    public struct ListExecutionsInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string), 
            AWSShapeMember(label: "statusFilter", required: false, type: .enum)
        ]

        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the state machine whose executions is listed.
        public let stateMachineArn: String
        /// If specified, only list the executions whose current execution status matches the given filter.
        public let statusFilter: ExecutionStatus?

        public init(maxResults: Int? = nil, nextToken: String? = nil, stateMachineArn: String, statusFilter: ExecutionStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stateMachineArn = stateMachineArn
            self.statusFilter = statusFilter
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 0)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3096)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, max: 256)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case stateMachineArn = "stateMachineArn"
            case statusFilter = "statusFilter"
        }
    }

    public struct ListExecutionsOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executions", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of matching executions.
        public let executions: [ExecutionListItem]
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(executions: [ExecutionListItem], nextToken: String? = nil) {
            self.executions = executions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case executions = "executions"
            case nextToken = "nextToken"
        }
    }

    public struct ListStateMachinesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
        public let maxResults: Int?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 1000)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 0)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 1024)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListStateMachinesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "stateMachines", required: true, type: .list)
        ]

        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
        public let nextToken: String?
        public let stateMachines: [StateMachineListItem]

        public init(nextToken: String? = nil, stateMachines: [StateMachineListItem]) {
            self.nextToken = nextToken
            self.stateMachines = stateMachines
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case stateMachines = "stateMachines"
        }
    }

    public struct ListTagsForResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 256)
            try validate(self.resourceArn, name:"resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]

        /// An array of tags associated with the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LogDestination: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cloudWatchLogsLogGroup", required: false, type: .structure)
        ]

        /// An object describing a CloudWatch log group. For more information, see AWS::Logs::LogGroup in the AWS CloudFormation User Guide.
        public let cloudWatchLogsLogGroup: CloudWatchLogsLogGroup?

        public init(cloudWatchLogsLogGroup: CloudWatchLogsLogGroup? = nil) {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsLogGroup?.validate(name: "\(name).cloudWatchLogsLogGroup")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroup = "cloudWatchLogsLogGroup"
        }
    }

    public struct LoggingConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "destinations", required: false, type: .list), 
            AWSShapeMember(label: "includeExecutionData", required: false, type: .boolean), 
            AWSShapeMember(label: "level", required: false, type: .enum)
        ]

        /// An array of objects that describes where your execution history events will be logged. Limited to size 1. Required, if your log level is not set to OFF.
        public let destinations: [LogDestination]?
        /// Determines whether execution data is included in your log. When set to false, data is excluded.
        public let includeExecutionData: Bool?
        /// Defines which category of execution history events are logged.
        public let level: LogLevel?

        public init(destinations: [LogDestination]? = nil, includeExecutionData: Bool? = nil, level: LogLevel? = nil) {
            self.destinations = destinations
            self.includeExecutionData = includeExecutionData
            self.level = level
        }

        public func validate(name: String) throws {
            try self.destinations?.forEach {
                try $0.validate(name: "\(name).destinations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "destinations"
            case includeExecutionData = "includeExecutionData"
            case level = "level"
        }
    }

    public struct MapIterationEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "index", required: false, type: .integer), 
            AWSShapeMember(label: "name", required: false, type: .string)
        ]

        /// The index of the array belonging to the Map state iteration.
        public let index: Int?
        /// The name of the iteration’s parent Map state.
        public let name: String?

        public init(index: Int? = nil, name: String? = nil) {
            self.index = index
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case index = "index"
            case name = "name"
        }
    }

    public struct MapStateStartedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "length", required: false, type: .integer)
        ]

        /// The size of the array for Map state iterations.
        public let length: Int?

        public init(length: Int? = nil) {
            self.length = length
        }

        private enum CodingKeys: String, CodingKey {
            case length = "length"
        }
    }

    public struct SendTaskFailureInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string), 
            AWSShapeMember(label: "taskToken", required: true, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the context object when a workflow enters a task state. See GetActivityTaskOutput$taskToken.
        public let taskToken: String

        public init(cause: String? = nil, error: String? = nil, taskToken: String) {
            self.cause = cause
            self.error = error
            self.taskToken = taskToken
        }

        public func validate(name: String) throws {
            try validate(self.cause, name:"cause", parent: name, max: 32768)
            try validate(self.cause, name:"cause", parent: name, min: 0)
            try validate(self.error, name:"error", parent: name, max: 256)
            try validate(self.error, name:"error", parent: name, min: 0)
            try validate(self.taskToken, name:"taskToken", parent: name, max: 1024)
            try validate(self.taskToken, name:"taskToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case taskToken = "taskToken"
        }
    }

    public struct SendTaskFailureOutput: AWSShape {


        public init() {
        }

    }

    public struct SendTaskHeartbeatInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "taskToken", required: true, type: .string)
        ]

        /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the context object when a workflow enters a task state. See GetActivityTaskOutput$taskToken.
        public let taskToken: String

        public init(taskToken: String) {
            self.taskToken = taskToken
        }

        public func validate(name: String) throws {
            try validate(self.taskToken, name:"taskToken", parent: name, max: 1024)
            try validate(self.taskToken, name:"taskToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case taskToken = "taskToken"
        }
    }

    public struct SendTaskHeartbeatOutput: AWSShape {


        public init() {
        }

    }

    public struct SendTaskSuccessInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "output", required: true, type: .string), 
            AWSShapeMember(label: "taskToken", required: true, type: .string)
        ]

        /// The JSON output of the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String
        /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the context object when a workflow enters a task state. See GetActivityTaskOutput$taskToken.
        public let taskToken: String

        public init(output: String, taskToken: String) {
            self.output = output
            self.taskToken = taskToken
        }

        public func validate(name: String) throws {
            try validate(self.output, name:"output", parent: name, max: 262144)
            try validate(self.taskToken, name:"taskToken", parent: name, max: 1024)
            try validate(self.taskToken, name:"taskToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case taskToken = "taskToken"
        }
    }

    public struct SendTaskSuccessOutput: AWSShape {


        public init() {
        }

    }

    public struct StartExecutionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "input", required: false, type: .string), 
            AWSShapeMember(label: "name", required: false, type: .string), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string)
        ]

        /// The string that contains the JSON input data for the execution, for example:  "input": "{\"first_name\" : \"test\"}"   If you don't include any JSON input data, you still must include the two braces, for example: "input": "{}"   Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// The name of the execution. This name must be unique for your AWS account, region, and state machine for 90 days. For more information, see  Limits Related to State Machine Executions in the AWS Step Functions Developer Guide. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the state machine to execute.
        public let stateMachineArn: String

        public init(input: String? = nil, name: String? = nil, stateMachineArn: String) {
            self.input = input
            self.name = name
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try validate(self.input, name:"input", parent: name, max: 262144)
            try validate(self.name, name:"name", parent: name, max: 80)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, max: 256)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case name = "name"
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct StartExecutionOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionArn", required: true, type: .string), 
            AWSShapeMember(label: "startDate", required: true, type: .timestamp)
        ]

        /// The Amazon Resource Name (ARN) that id entifies the execution.
        public let executionArn: String
        /// The date the execution is started.
        public let startDate: TimeStamp

        public init(executionArn: String, startDate: TimeStamp) {
            self.executionArn = executionArn
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case executionArn = "executionArn"
            case startDate = "startDate"
        }
    }

    public struct StateEnteredEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "input", required: false, type: .string), 
            AWSShapeMember(label: "inputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// The string that contains the JSON input data for the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let input: String?
        /// Contains details about the input for an execution history event.
        public let inputDetails: HistoryEventExecutionDataDetails?
        /// The name of the state.
        public let name: String

        public init(input: String? = nil, inputDetails: HistoryEventExecutionDataDetails? = nil, name: String) {
            self.input = input
            self.inputDetails = inputDetails
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case inputDetails = "inputDetails"
            case name = "name"
        }
    }

    public struct StateExitedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "output", required: false, type: .string), 
            AWSShapeMember(label: "outputDetails", required: false, type: .structure)
        ]

        /// The name of the state. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String
        /// The JSON output data of the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?

        public init(name: String, output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil) {
            self.name = name
            self.output = output
            self.outputDetails = outputDetails
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case output = "output"
            case outputDetails = "outputDetails"
        }
    }

    public struct StateMachineListItem: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "creationDate", required: true, type: .timestamp), 
            AWSShapeMember(label: "name", required: true, type: .string), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string), 
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]

        /// The date the state machine is created.
        public let creationDate: TimeStamp
        /// The name of the state machine. A name must not contain:   white space   brackets &lt; &gt; { } [ ]    wildcard characters ? *    special characters " # % \ ^ | ~ ` $ &amp; , ; : /    control characters (U+0000-001F, U+007F-009F)   To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        public let name: String
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        public let stateMachineArn: String
        public let `type`: StateMachineType

        public init(creationDate: TimeStamp, name: String, stateMachineArn: String, type: StateMachineType) {
            self.creationDate = creationDate
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case name = "name"
            case stateMachineArn = "stateMachineArn"
            case `type` = "type"
        }
    }

    public struct StopExecutionInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string), 
            AWSShapeMember(label: "executionArn", required: true, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The Amazon Resource Name (ARN) of the execution to stop.
        public let executionArn: String

        public init(cause: String? = nil, error: String? = nil, executionArn: String) {
            self.cause = cause
            self.error = error
            self.executionArn = executionArn
        }

        public func validate(name: String) throws {
            try validate(self.cause, name:"cause", parent: name, max: 32768)
            try validate(self.cause, name:"cause", parent: name, min: 0)
            try validate(self.error, name:"error", parent: name, max: 256)
            try validate(self.error, name:"error", parent: name, min: 0)
            try validate(self.executionArn, name:"executionArn", parent: name, max: 256)
            try validate(self.executionArn, name:"executionArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case executionArn = "executionArn"
        }
    }

    public struct StopExecutionOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "stopDate", required: true, type: .timestamp)
        ]

        /// The date the execution is stopped.
        public let stopDate: TimeStamp

        public init(stopDate: TimeStamp) {
            self.stopDate = stopDate
        }

        private enum CodingKeys: String, CodingKey {
            case stopDate = "stopDate"
        }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: false, type: .string), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]

        /// The key of a tag.
        public let key: String?
        /// The value of a tag.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 128)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: true, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
        public let resourceArn: String
        /// The list of tags to add to a resource. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 256)
            try validate(self.resourceArn, name:"resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSShape {


        public init() {
        }

    }

    public struct TaskFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskScheduledEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "heartbeatInSeconds", required: false, type: .long), 
            AWSShapeMember(label: "parameters", required: true, type: .string), 
            AWSShapeMember(label: "region", required: true, type: .string), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string), 
            AWSShapeMember(label: "timeoutInSeconds", required: false, type: .long)
        ]

        /// The maximum allowed duration between two heartbeats for the task.
        public let heartbeatInSeconds: Int64?
        /// The JSON data passed to the resource referenced in a task state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let parameters: String
        /// The region of the scheduled task
        public let region: String
        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String
        /// The maximum allowed duration of the task.
        public let timeoutInSeconds: Int64?

        public init(heartbeatInSeconds: Int64? = nil, parameters: String, region: String, resource: String, resourceType: String, timeoutInSeconds: Int64? = nil) {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.parameters = parameters
            self.region = region
            self.resource = resource
            self.resourceType = resourceType
            self.timeoutInSeconds = timeoutInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case heartbeatInSeconds = "heartbeatInSeconds"
            case parameters = "parameters"
            case region = "region"
            case resource = "resource"
            case resourceType = "resourceType"
            case timeoutInSeconds = "timeoutInSeconds"
        }
    }

    public struct TaskStartFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskStartedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string)
        ]

        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String

        public init(resource: String, resourceType: String) {
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskSubmitFailedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskSubmittedEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "output", required: false, type: .string), 
            AWSShapeMember(label: "outputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string)
        ]

        /// The response from a resource when a task has started. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?
        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, resourceType: String) {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskSucceededEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "output", required: false, type: .string), 
            AWSShapeMember(label: "outputDetails", required: false, type: .structure), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string)
        ]

        /// The full JSON response from a resource when a task has succeeded. This response becomes the output of the related task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public let output: String?
        /// Contains details about the output of an execution history event.
        public let outputDetails: HistoryEventExecutionDataDetails?
        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String

        public init(output: String? = nil, outputDetails: HistoryEventExecutionDataDetails? = nil, resource: String, resourceType: String) {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
            case outputDetails = "outputDetails"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct TaskTimedOutEventDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "cause", required: false, type: .string), 
            AWSShapeMember(label: "error", required: false, type: .string), 
            AWSShapeMember(label: "resource", required: true, type: .string), 
            AWSShapeMember(label: "resourceType", required: true, type: .string)
        ]

        /// A more detailed explanation of the cause of the failure.
        public let cause: String?
        /// The error code of the failure.
        public let error: String?
        /// The service name of the resource in a task state.
        public let resource: String
        /// The action of the resource called by a task state.
        public let resourceType: String

        public init(cause: String? = nil, error: String? = nil, resource: String, resourceType: String) {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case cause = "cause"
            case error = "error"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct UntagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", required: true, type: .string), 
            AWSShapeMember(label: "tagKeys", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
        public let resourceArn: String
        /// The list of tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 256)
            try validate(self.resourceArn, name:"resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceOutput: AWSShape {


        public init() {
        }

    }

    public struct UpdateStateMachineInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "definition", required: false, type: .string), 
            AWSShapeMember(label: "loggingConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "roleArn", required: false, type: .string), 
            AWSShapeMember(label: "stateMachineArn", required: true, type: .string)
        ]

        /// The Amazon States Language definition of the state machine. See Amazon States Language.
        public let definition: String?
        /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
        public let loggingConfiguration: LoggingConfiguration?
        /// The Amazon Resource Name (ARN) of the IAM role of the state machine.
        public let roleArn: String?
        /// The Amazon Resource Name (ARN) of the state machine.
        public let stateMachineArn: String

        public init(definition: String? = nil, loggingConfiguration: LoggingConfiguration? = nil, roleArn: String? = nil, stateMachineArn: String) {
            self.definition = definition
            self.loggingConfiguration = loggingConfiguration
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
        }

        public func validate(name: String) throws {
            try validate(self.definition, name:"definition", parent: name, max: 1048576)
            try validate(self.definition, name:"definition", parent: name, min: 1)
            try self.loggingConfiguration?.validate(name: "\(name).loggingConfiguration")
            try validate(self.roleArn, name:"roleArn", parent: name, max: 256)
            try validate(self.roleArn, name:"roleArn", parent: name, min: 1)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, max: 256)
            try validate(self.stateMachineArn, name:"stateMachineArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case loggingConfiguration = "loggingConfiguration"
            case roleArn = "roleArn"
            case stateMachineArn = "stateMachineArn"
        }
    }

    public struct UpdateStateMachineOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "updateDate", required: true, type: .timestamp)
        ]

        /// The date and time the state machine was updated.
        public let updateDate: TimeStamp

        public init(updateDate: TimeStamp) {
            self.updateDate = updateDate
        }

        private enum CodingKeys: String, CodingKey {
            case updateDate = "updateDate"
        }
    }
}

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension Appflow {
    //MARK: Enums

    public enum AggregationType: String, CustomStringConvertible, Codable {
        case none = "None"
        case singlefile = "SingleFile"
        public var description: String { return self.rawValue }
    }

    public enum AmplitudeConnectorOperator: String, CustomStringConvertible, Codable {
        case between = "BETWEEN"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionMode: String, CustomStringConvertible, Codable {
        case `public` = "Public"
        case `private` = "Private"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorType: String, CustomStringConvertible, Codable {
        case salesforce = "Salesforce"
        case singular = "Singular"
        case slack = "Slack"
        case redshift = "Redshift"
        case s3 = "S3"
        case marketo = "Marketo"
        case googleanalytics = "Googleanalytics"
        case zendesk = "Zendesk"
        case servicenow = "Servicenow"
        case datadog = "Datadog"
        case trendmicro = "Trendmicro"
        case snowflake = "Snowflake"
        case dynatrace = "Dynatrace"
        case infornexus = "Infornexus"
        case amplitude = "Amplitude"
        case veeva = "Veeva"
        case eventbridge = "EventBridge"
        public var description: String { return self.rawValue }
    }

    public enum DataPullMode: String, CustomStringConvertible, Codable {
        case incremental = "Incremental"
        case complete = "Complete"
        public var description: String { return self.rawValue }
    }

    public enum DatadogConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case between = "BETWEEN"
        case equalTo = "EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum DynatraceConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case between = "BETWEEN"
        case equalTo = "EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum ExecutionStatus: String, CustomStringConvertible, Codable {
        case inprogress = "InProgress"
        case successful = "Successful"
        case error = "Error"
        public var description: String { return self.rawValue }
    }

    public enum FileType: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case json = "JSON"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum FlowStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case deprecated = "Deprecated"
        case deleted = "Deleted"
        case draft = "Draft"
        case errored = "Errored"
        case suspended = "Suspended"
        public var description: String { return self.rawValue }
    }

    public enum GoogleAnalyticsConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case between = "BETWEEN"
        public var description: String { return self.rawValue }
    }

    public enum InforNexusConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case between = "BETWEEN"
        case equalTo = "EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum MarketoConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case between = "BETWEEN"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum `Operator`: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case contains = "CONTAINS"
        case between = "BETWEEN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case equalTo = "EQUAL_TO"
        case notEqualTo = "NOT_EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum OperatorPropertiesKeys: String, CustomStringConvertible, Codable {
        case value = "VALUE"
        case values = "VALUES"
        case dataType = "DATA_TYPE"
        case upperBound = "UPPER_BOUND"
        case lowerBound = "LOWER_BOUND"
        case sourceDataType = "SOURCE_DATA_TYPE"
        case destinationDataType = "DESTINATION_DATA_TYPE"
        case validationAction = "VALIDATION_ACTION"
        case maskValue = "MASK_VALUE"
        case maskLength = "MASK_LENGTH"
        case truncateLength = "TRUNCATE_LENGTH"
        case mathOperationFieldsOrder = "MATH_OPERATION_FIELDS_ORDER"
        case concatFormat = "CONCAT_FORMAT"
        case subfieldCategoryMap = "SUBFIELD_CATEGORY_MAP"
        public var description: String { return self.rawValue }
    }

    public enum PrefixFormat: String, CustomStringConvertible, Codable {
        case year = "YEAR"
        case month = "MONTH"
        case day = "DAY"
        case hour = "HOUR"
        case minute = "MINUTE"
        public var description: String { return self.rawValue }
    }

    public enum PrefixType: String, CustomStringConvertible, Codable {
        case filename = "FILENAME"
        case path = "PATH"
        case pathAndFilename = "PATH_AND_FILENAME"
        public var description: String { return self.rawValue }
    }

    public enum S3ConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case between = "BETWEEN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case equalTo = "EQUAL_TO"
        case notEqualTo = "NOT_EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case lessThan = "LESS_THAN"
        case contains = "CONTAINS"
        case greaterThan = "GREATER_THAN"
        case between = "BETWEEN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case equalTo = "EQUAL_TO"
        case notEqualTo = "NOT_EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleFrequencyType: String, CustomStringConvertible, Codable {
        case byminute = "BYMINUTE"
        case hourly = "HOURLY"
        case daily = "DAILY"
        case weekly = "WEEKLY"
        case monthly = "MONTHLY"
        case once = "ONCE"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNowConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case contains = "CONTAINS"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case between = "BETWEEN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case equalTo = "EQUAL_TO"
        case notEqualTo = "NOT_EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum SingularConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case equalTo = "EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum SlackConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case between = "BETWEEN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case equalTo = "EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum TaskType: String, CustomStringConvertible, Codable {
        case arithmetic = "Arithmetic"
        case filter = "Filter"
        case map = "Map"
        case mask = "Mask"
        case merge = "Merge"
        case truncate = "Truncate"
        case validate = "Validate"
        public var description: String { return self.rawValue }
    }

    public enum TrendmicroConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case equalTo = "EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable {
        case scheduled = "Scheduled"
        case event = "Event"
        case ondemand = "OnDemand"
        public var description: String { return self.rawValue }
    }

    public enum VeevaConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case lessThan = "LESS_THAN"
        case greaterThan = "GREATER_THAN"
        case contains = "CONTAINS"
        case between = "BETWEEN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case equalTo = "EQUAL_TO"
        case notEqualTo = "NOT_EQUAL_TO"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    public enum ZendeskConnectorOperator: String, CustomStringConvertible, Codable {
        case projection = "PROJECTION"
        case greaterThan = "GREATER_THAN"
        case addition = "ADDITION"
        case multiplication = "MULTIPLICATION"
        case division = "DIVISION"
        case subtraction = "SUBTRACTION"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNumeric = "VALIDATE_NUMERIC"
        case noOp = "NO_OP"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AggregationConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "aggregationType", required: false, type: .enum)
        ]

        ///  Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated. 
        public let aggregationType: AggregationType?

        public init(aggregationType: AggregationType? = nil) {
            self.aggregationType = aggregationType
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationType = "aggregationType"
        }
    }

    public struct AmplitudeConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiKey", required: true, type: .string), 
            AWSShapeMember(label: "secretKey", required: true, type: .string)
        ]

        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API. 
        public let apiKey: String
        ///  The Secret Access Key portion of the credentials. 
        public let secretKey: String

        public init(apiKey: String, secretKey: String) {
            self.apiKey = apiKey
            self.secretKey = secretKey
        }

        public func validate(name: String) throws {
            try validate(self.apiKey, name:"apiKey", parent: name, max: 256)
            try validate(self.apiKey, name:"apiKey", parent: name, pattern: "\\S+")
            try validate(self.secretKey, name:"secretKey", parent: name, max: 256)
            try validate(self.secretKey, name:"secretKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case secretKey = "secretKey"
        }
    }

    public struct AmplitudeConnectorProfileProperties: AWSShape {


        public init() {
        }

    }

    public struct AmplitudeMetadata: AWSShape {


        public init() {
        }

    }

    public struct AmplitudeSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Amplitude flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct ConnectorConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "canUseAsDestination", required: false, type: .boolean), 
            AWSShapeMember(label: "canUseAsSource", required: false, type: .boolean), 
            AWSShapeMember(label: "connectorMetadata", required: false, type: .structure), 
            AWSShapeMember(label: "isPrivateLinkEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "isPrivateLinkEndpointUrlRequired", required: false, type: .boolean), 
            AWSShapeMember(label: "supportedDestinationConnectors", required: false, type: .list), 
            AWSShapeMember(label: "supportedSchedulingFrequencies", required: false, type: .list), 
            AWSShapeMember(label: "supportedTriggerTypes", required: false, type: .list)
        ]

        ///  Specifies whether the connector can be used as a destination. 
        public let canUseAsDestination: Bool?
        ///  Specifies whether the connector can be used as a source. 
        public let canUseAsSource: Bool?
        ///  Specifies connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on. 
        public let connectorMetadata: ConnectorMetadata?
        ///  Specifies if PrivateLink is enabled for that connector. 
        public let isPrivateLinkEnabled: Bool?
        ///  Specifies if a PrivateLink endpoint URL is required. 
        public let isPrivateLinkEndpointUrlRequired: Bool?
        ///  Lists the connectors that are available for use as destinations. 
        public let supportedDestinationConnectors: [ConnectorType]?
        ///  Specifies the supported flow frequency for that connector. 
        public let supportedSchedulingFrequencies: [ScheduleFrequencyType]?
        ///  Specifies the supported trigger types for the flow. 
        public let supportedTriggerTypes: [TriggerType]?

        public init(canUseAsDestination: Bool? = nil, canUseAsSource: Bool? = nil, connectorMetadata: ConnectorMetadata? = nil, isPrivateLinkEnabled: Bool? = nil, isPrivateLinkEndpointUrlRequired: Bool? = nil, supportedDestinationConnectors: [ConnectorType]? = nil, supportedSchedulingFrequencies: [ScheduleFrequencyType]? = nil, supportedTriggerTypes: [TriggerType]? = nil) {
            self.canUseAsDestination = canUseAsDestination
            self.canUseAsSource = canUseAsSource
            self.connectorMetadata = connectorMetadata
            self.isPrivateLinkEnabled = isPrivateLinkEnabled
            self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
            self.supportedDestinationConnectors = supportedDestinationConnectors
            self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
            self.supportedTriggerTypes = supportedTriggerTypes
        }

        private enum CodingKeys: String, CodingKey {
            case canUseAsDestination = "canUseAsDestination"
            case canUseAsSource = "canUseAsSource"
            case connectorMetadata = "connectorMetadata"
            case isPrivateLinkEnabled = "isPrivateLinkEnabled"
            case isPrivateLinkEndpointUrlRequired = "isPrivateLinkEndpointUrlRequired"
            case supportedDestinationConnectors = "supportedDestinationConnectors"
            case supportedSchedulingFrequencies = "supportedSchedulingFrequencies"
            case supportedTriggerTypes = "supportedTriggerTypes"
        }
    }

    public struct ConnectorEntity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "hasNestedEntities", required: false, type: .boolean), 
            AWSShapeMember(label: "label", required: false, type: .string), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        ///  Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with entitiesPath = "the_current_entity_name_with_hasNestedEntities_true", then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion. 
        public let hasNestedEntities: Bool?
        ///  The label applied to the connector entity. 
        public let label: String?
        ///  The name of the connector entity. 
        public let name: String

        public init(hasNestedEntities: Bool? = nil, label: String? = nil, name: String) {
            self.hasNestedEntities = hasNestedEntities
            self.label = label
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case hasNestedEntities = "hasNestedEntities"
            case label = "label"
            case name = "name"
        }
    }

    public struct ConnectorEntityField: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "destinationProperties", required: false, type: .structure), 
            AWSShapeMember(label: "identifier", required: true, type: .string), 
            AWSShapeMember(label: "label", required: false, type: .string), 
            AWSShapeMember(label: "sourceProperties", required: false, type: .structure), 
            AWSShapeMember(label: "supportedFieldTypeDetails", required: false, type: .structure)
        ]

        ///  A description of the connector entity field. 
        public let description: String?
        ///  The properties applied to a field when the connector is being used as a destination. 
        public let destinationProperties: DestinationFieldProperties?
        ///  The unique identifier of the connector field. 
        public let identifier: String
        ///  The label applied to a connector entity field. 
        public let label: String?
        ///  The properties that can be applied to a field when the connector is being used as a source. 
        public let sourceProperties: SourceFieldProperties?
        ///  Contains details regarding the supported FieldType, including the corresponding filterOperators and supportedValues. 
        public let supportedFieldTypeDetails: SupportedFieldTypeDetails?

        public init(description: String? = nil, destinationProperties: DestinationFieldProperties? = nil, identifier: String, label: String? = nil, sourceProperties: SourceFieldProperties? = nil, supportedFieldTypeDetails: SupportedFieldTypeDetails? = nil) {
            self.description = description
            self.destinationProperties = destinationProperties
            self.identifier = identifier
            self.label = label
            self.sourceProperties = sourceProperties
            self.supportedFieldTypeDetails = supportedFieldTypeDetails
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case destinationProperties = "destinationProperties"
            case identifier = "identifier"
            case label = "label"
            case sourceProperties = "sourceProperties"
            case supportedFieldTypeDetails = "supportedFieldTypeDetails"
        }
    }

    public struct ConnectorMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Amplitude", required: false, type: .structure), 
            AWSShapeMember(label: "Datadog", required: false, type: .structure), 
            AWSShapeMember(label: "Dynatrace", required: false, type: .structure), 
            AWSShapeMember(label: "EventBridge", required: false, type: .structure), 
            AWSShapeMember(label: "GoogleAnalytics", required: false, type: .structure), 
            AWSShapeMember(label: "InforNexus", required: false, type: .structure), 
            AWSShapeMember(label: "Marketo", required: false, type: .structure), 
            AWSShapeMember(label: "Redshift", required: false, type: .structure), 
            AWSShapeMember(label: "S3", required: false, type: .structure), 
            AWSShapeMember(label: "Salesforce", required: false, type: .structure), 
            AWSShapeMember(label: "ServiceNow", required: false, type: .structure), 
            AWSShapeMember(label: "Singular", required: false, type: .structure), 
            AWSShapeMember(label: "Slack", required: false, type: .structure), 
            AWSShapeMember(label: "Snowflake", required: false, type: .structure), 
            AWSShapeMember(label: "Trendmicro", required: false, type: .structure), 
            AWSShapeMember(label: "Veeva", required: false, type: .structure), 
            AWSShapeMember(label: "Zendesk", required: false, type: .structure)
        ]

        ///  The connector metadata specific to Amplitude. 
        public let amplitude: AmplitudeMetadata?
        ///  The connector metadata specific to Datadog. 
        public let datadog: DatadogMetadata?
        ///  The connector metadata specific to Dynatrace. 
        public let dynatrace: DynatraceMetadata?
        ///  The connector metadata specific to Amazon EventBridge. 
        public let eventBridge: EventBridgeMetadata?
        ///  The connector metadata specific to Google Analytics. 
        public let googleAnalytics: GoogleAnalyticsMetadata?
        ///  The connector metadata specific to Infor Nexus. 
        public let inforNexus: InforNexusMetadata?
        ///  The connector metadata specific to Marketo. 
        public let marketo: MarketoMetadata?
        ///  The connector metadata specific to Amazon Redshift. 
        public let redshift: RedshiftMetadata?
        ///  The connector metadata specific to Amazon S3. 
        public let s3: S3Metadata?
        ///  The connector metadata specific to Salesforce. 
        public let salesforce: SalesforceMetadata?
        ///  The connector metadata specific to ServiceNow. 
        public let serviceNow: ServiceNowMetadata?
        ///  The connector metadata specific to Singular. 
        public let singular: SingularMetadata?
        ///  The connector metadata specific to Slack. 
        public let slack: SlackMetadata?
        ///  The connector metadata specific to Snowflake. 
        public let snowflake: SnowflakeMetadata?
        ///  The connector metadata specific to Trend Micro. 
        public let trendmicro: TrendmicroMetadata?
        ///  The connector metadata specific to Veeva. 
        public let veeva: VeevaMetadata?
        ///  The connector metadata specific to Zendesk. 
        public let zendesk: ZendeskMetadata?

        public init(amplitude: AmplitudeMetadata? = nil, datadog: DatadogMetadata? = nil, dynatrace: DynatraceMetadata? = nil, eventBridge: EventBridgeMetadata? = nil, googleAnalytics: GoogleAnalyticsMetadata? = nil, inforNexus: InforNexusMetadata? = nil, marketo: MarketoMetadata? = nil, redshift: RedshiftMetadata? = nil, s3: S3Metadata? = nil, salesforce: SalesforceMetadata? = nil, serviceNow: ServiceNowMetadata? = nil, singular: SingularMetadata? = nil, slack: SlackMetadata? = nil, snowflake: SnowflakeMetadata? = nil, trendmicro: TrendmicroMetadata? = nil, veeva: VeevaMetadata? = nil, zendesk: ZendeskMetadata? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.eventBridge = eventBridge
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case eventBridge = "EventBridge"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case redshift = "Redshift"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorOAuthRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "authCode", required: false, type: .string), 
            AWSShapeMember(label: "redirectUri", required: false, type: .string)
        ]

        ///  The code provided by the connector when it has been authenticated via the connected app. 
        public let authCode: String?
        ///  The URL to which the authentication server redirects the browser after authorization has been granted. 
        public let redirectUri: String?

        public init(authCode: String? = nil, redirectUri: String? = nil) {
            self.authCode = authCode
            self.redirectUri = redirectUri
        }

        public func validate(name: String) throws {
            try validate(self.authCode, name:"authCode", parent: name, max: 512)
            try validate(self.authCode, name:"authCode", parent: name, pattern: "\\S+")
            try validate(self.redirectUri, name:"redirectUri", parent: name, max: 512)
            try validate(self.redirectUri, name:"redirectUri", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case authCode = "authCode"
            case redirectUri = "redirectUri"
        }
    }

    public struct ConnectorOperator: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Amplitude", required: false, type: .enum), 
            AWSShapeMember(label: "Datadog", required: false, type: .enum), 
            AWSShapeMember(label: "Dynatrace", required: false, type: .enum), 
            AWSShapeMember(label: "GoogleAnalytics", required: false, type: .enum), 
            AWSShapeMember(label: "InforNexus", required: false, type: .enum), 
            AWSShapeMember(label: "Marketo", required: false, type: .enum), 
            AWSShapeMember(label: "S3", required: false, type: .enum), 
            AWSShapeMember(label: "Salesforce", required: false, type: .enum), 
            AWSShapeMember(label: "ServiceNow", required: false, type: .enum), 
            AWSShapeMember(label: "Singular", required: false, type: .enum), 
            AWSShapeMember(label: "Slack", required: false, type: .enum), 
            AWSShapeMember(label: "Trendmicro", required: false, type: .enum), 
            AWSShapeMember(label: "Veeva", required: false, type: .enum), 
            AWSShapeMember(label: "Zendesk", required: false, type: .enum)
        ]

        ///  The operation to be performed on the provided Amplitude source fields. 
        public let amplitude: AmplitudeConnectorOperator?
        ///  The operation to be performed on the provided Datadog source fields. 
        public let datadog: DatadogConnectorOperator?
        ///  The operation to be performed on the provided Dynatrace source fields. 
        public let dynatrace: DynatraceConnectorOperator?
        ///  The operation to be performed on the provided Google Analytics source fields. 
        public let googleAnalytics: GoogleAnalyticsConnectorOperator?
        ///  The operation to be performed on the provided Infor Nexus source fields. 
        public let inforNexus: InforNexusConnectorOperator?
        ///  The operation to be performed on the provided Marketo source fields. 
        public let marketo: MarketoConnectorOperator?
        ///  The operation to be performed on the provided Amazon S3 source fields. 
        public let s3: S3ConnectorOperator?
        ///  The operation to be performed on the provided Salesforce source fields. 
        public let salesforce: SalesforceConnectorOperator?
        ///  The operation to be performed on the provided ServiceNow source fields. 
        public let serviceNow: ServiceNowConnectorOperator?
        ///  The operation to be performed on the provided Singular source fields. 
        public let singular: SingularConnectorOperator?
        ///  The operation to be performed on the provided Slack source fields. 
        public let slack: SlackConnectorOperator?
        ///  The operation to be performed on the provided Trend Micro source fields. 
        public let trendmicro: TrendmicroConnectorOperator?
        ///  The operation to be performed on the provided Veeva source fields. 
        public let veeva: VeevaConnectorOperator?
        ///  The operation to be performed on the provided Zendesk source fields. 
        public let zendesk: ZendeskConnectorOperator?

        public init(amplitude: AmplitudeConnectorOperator? = nil, datadog: DatadogConnectorOperator? = nil, dynatrace: DynatraceConnectorOperator? = nil, googleAnalytics: GoogleAnalyticsConnectorOperator? = nil, inforNexus: InforNexusConnectorOperator? = nil, marketo: MarketoConnectorOperator? = nil, s3: S3ConnectorOperator? = nil, salesforce: SalesforceConnectorOperator? = nil, serviceNow: ServiceNowConnectorOperator? = nil, singular: SingularConnectorOperator? = nil, slack: SlackConnectorOperator? = nil, trendmicro: TrendmicroConnectorOperator? = nil, veeva: VeevaConnectorOperator? = nil, zendesk: ZendeskConnectorOperator? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorProfile: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionMode", required: false, type: .enum), 
            AWSShapeMember(label: "connectorProfileArn", required: false, type: .string), 
            AWSShapeMember(label: "connectorProfileName", required: false, type: .string), 
            AWSShapeMember(label: "connectorProfileProperties", required: false, type: .structure), 
            AWSShapeMember(label: "connectorType", required: false, type: .enum), 
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "credentialsArn", required: false, type: .string), 
            AWSShapeMember(label: "lastUpdatedAt", required: false, type: .timestamp)
        ]

        ///  Indicates the connection mode and if it is public or private. 
        public let connectionMode: ConnectionMode?
        ///  The Amazon Resource Name (ARN) of the connector profile. 
        public let connectorProfileArn: String?
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account. 
        public let connectorProfileName: String?
        ///  The connector-specific properties of the profile configuration. 
        public let connectorProfileProperties: ConnectorProfileProperties?
        ///  The type of connector, such as Salesforce, Amplitude, and so on. 
        public let connectorType: ConnectorType?
        ///  Specifies when the connector profile was created. 
        public let createdAt: TimeStamp?
        ///  The Amazon Resource Name (ARN) of the connector profile credentials. 
        public let credentialsArn: String?
        ///  Specifies when the connector profile was last updated. 
        public let lastUpdatedAt: TimeStamp?

        public init(connectionMode: ConnectionMode? = nil, connectorProfileArn: String? = nil, connectorProfileName: String? = nil, connectorProfileProperties: ConnectorProfileProperties? = nil, connectorType: ConnectorType? = nil, createdAt: TimeStamp? = nil, credentialsArn: String? = nil, lastUpdatedAt: TimeStamp? = nil) {
            self.connectionMode = connectionMode
            self.connectorProfileArn = connectorProfileArn
            self.connectorProfileName = connectorProfileName
            self.connectorProfileProperties = connectorProfileProperties
            self.connectorType = connectorType
            self.createdAt = createdAt
            self.credentialsArn = credentialsArn
            self.lastUpdatedAt = lastUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case connectionMode = "connectionMode"
            case connectorProfileArn = "connectorProfileArn"
            case connectorProfileName = "connectorProfileName"
            case connectorProfileProperties = "connectorProfileProperties"
            case connectorType = "connectorType"
            case createdAt = "createdAt"
            case credentialsArn = "credentialsArn"
            case lastUpdatedAt = "lastUpdatedAt"
        }
    }

    public struct ConnectorProfileConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileCredentials", required: true, type: .structure), 
            AWSShapeMember(label: "connectorProfileProperties", required: true, type: .structure)
        ]

        ///  The connector-specific credentials required by each connector. 
        public let connectorProfileCredentials: ConnectorProfileCredentials
        ///  The connector-specific properties of the profile configuration. 
        public let connectorProfileProperties: ConnectorProfileProperties

        public init(connectorProfileCredentials: ConnectorProfileCredentials, connectorProfileProperties: ConnectorProfileProperties) {
            self.connectorProfileCredentials = connectorProfileCredentials
            self.connectorProfileProperties = connectorProfileProperties
        }

        public func validate(name: String) throws {
            try self.connectorProfileCredentials.validate(name: "\(name).connectorProfileCredentials")
            try self.connectorProfileProperties.validate(name: "\(name).connectorProfileProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileCredentials = "connectorProfileCredentials"
            case connectorProfileProperties = "connectorProfileProperties"
        }
    }

    public struct ConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Amplitude", required: false, type: .structure), 
            AWSShapeMember(label: "Datadog", required: false, type: .structure), 
            AWSShapeMember(label: "Dynatrace", required: false, type: .structure), 
            AWSShapeMember(label: "GoogleAnalytics", required: false, type: .structure), 
            AWSShapeMember(label: "InforNexus", required: false, type: .structure), 
            AWSShapeMember(label: "Marketo", required: false, type: .structure), 
            AWSShapeMember(label: "Redshift", required: false, type: .structure), 
            AWSShapeMember(label: "Salesforce", required: false, type: .structure), 
            AWSShapeMember(label: "ServiceNow", required: false, type: .structure), 
            AWSShapeMember(label: "Singular", required: false, type: .structure), 
            AWSShapeMember(label: "Slack", required: false, type: .structure), 
            AWSShapeMember(label: "Snowflake", required: false, type: .structure), 
            AWSShapeMember(label: "Trendmicro", required: false, type: .structure), 
            AWSShapeMember(label: "Veeva", required: false, type: .structure), 
            AWSShapeMember(label: "Zendesk", required: false, type: .structure)
        ]

        ///  The connector-specific credentials required when using Amplitude. 
        public let amplitude: AmplitudeConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Datadog. 
        public let datadog: DatadogConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Dynatrace. 
        public let dynatrace: DynatraceConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Google Analytics. 
        public let googleAnalytics: GoogleAnalyticsConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Infor Nexus. 
        public let inforNexus: InforNexusConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Marketo. 
        public let marketo: MarketoConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Amazon Redshift. 
        public let redshift: RedshiftConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Salesforce. 
        public let salesforce: SalesforceConnectorProfileCredentials?
        ///  The connector-specific credentials required when using ServiceNow. 
        public let serviceNow: ServiceNowConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Singular. 
        public let singular: SingularConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Slack. 
        public let slack: SlackConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Snowflake. 
        public let snowflake: SnowflakeConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Trend Micro. 
        public let trendmicro: TrendmicroConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Veeva. 
        public let veeva: VeevaConnectorProfileCredentials?
        ///  The connector-specific credentials required when using Zendesk. 
        public let zendesk: ZendeskConnectorProfileCredentials?

        public init(amplitude: AmplitudeConnectorProfileCredentials? = nil, datadog: DatadogConnectorProfileCredentials? = nil, dynatrace: DynatraceConnectorProfileCredentials? = nil, googleAnalytics: GoogleAnalyticsConnectorProfileCredentials? = nil, inforNexus: InforNexusConnectorProfileCredentials? = nil, marketo: MarketoConnectorProfileCredentials? = nil, redshift: RedshiftConnectorProfileCredentials? = nil, salesforce: SalesforceConnectorProfileCredentials? = nil, serviceNow: ServiceNowConnectorProfileCredentials? = nil, singular: SingularConnectorProfileCredentials? = nil, slack: SlackConnectorProfileCredentials? = nil, snowflake: SnowflakeConnectorProfileCredentials? = nil, trendmicro: TrendmicroConnectorProfileCredentials? = nil, veeva: VeevaConnectorProfileCredentials? = nil, zendesk: ZendeskConnectorProfileCredentials? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.amplitude?.validate(name: "\(name).amplitude")
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.googleAnalytics?.validate(name: "\(name).googleAnalytics")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.singular?.validate(name: "\(name).singular")
            try self.slack?.validate(name: "\(name).slack")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.trendmicro?.validate(name: "\(name).trendmicro")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case redshift = "Redshift"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct ConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Amplitude", required: false, type: .structure), 
            AWSShapeMember(label: "Datadog", required: false, type: .structure), 
            AWSShapeMember(label: "Dynatrace", required: false, type: .structure), 
            AWSShapeMember(label: "GoogleAnalytics", required: false, type: .structure), 
            AWSShapeMember(label: "InforNexus", required: false, type: .structure), 
            AWSShapeMember(label: "Marketo", required: false, type: .structure), 
            AWSShapeMember(label: "Redshift", required: false, type: .structure), 
            AWSShapeMember(label: "Salesforce", required: false, type: .structure), 
            AWSShapeMember(label: "ServiceNow", required: false, type: .structure), 
            AWSShapeMember(label: "Singular", required: false, type: .structure), 
            AWSShapeMember(label: "Slack", required: false, type: .structure), 
            AWSShapeMember(label: "Snowflake", required: false, type: .structure), 
            AWSShapeMember(label: "Trendmicro", required: false, type: .structure), 
            AWSShapeMember(label: "Veeva", required: false, type: .structure), 
            AWSShapeMember(label: "Zendesk", required: false, type: .structure)
        ]

        ///  The connector-specific properties required by Amplitude. 
        public let amplitude: AmplitudeConnectorProfileProperties?
        ///  The connector-specific properties required by Datadog. 
        public let datadog: DatadogConnectorProfileProperties?
        ///  The connector-specific properties required by Dynatrace. 
        public let dynatrace: DynatraceConnectorProfileProperties?
        ///  The connector-specific properties required Google Analytics. 
        public let googleAnalytics: GoogleAnalyticsConnectorProfileProperties?
        ///  The connector-specific properties required by Infor Nexus. 
        public let inforNexus: InforNexusConnectorProfileProperties?
        ///  The connector-specific properties required by Marketo. 
        public let marketo: MarketoConnectorProfileProperties?
        ///  The connector-specific properties required by Amazon Redshift. 
        public let redshift: RedshiftConnectorProfileProperties?
        ///  The connector-specific properties required by Salesforce. 
        public let salesforce: SalesforceConnectorProfileProperties?
        ///  The connector-specific properties required by serviceNow. 
        public let serviceNow: ServiceNowConnectorProfileProperties?
        ///  The connector-specific properties required by Singular. 
        public let singular: SingularConnectorProfileProperties?
        ///  The connector-specific properties required by Slack. 
        public let slack: SlackConnectorProfileProperties?
        ///  The connector-specific properties required by Snowflake. 
        public let snowflake: SnowflakeConnectorProfileProperties?
        ///  The connector-specific properties required by Trend Micro. 
        public let trendmicro: TrendmicroConnectorProfileProperties?
        ///  The connector-specific properties required by Veeva. 
        public let veeva: VeevaConnectorProfileProperties?
        ///  The connector-specific properties required by Zendesk. 
        public let zendesk: ZendeskConnectorProfileProperties?

        public init(amplitude: AmplitudeConnectorProfileProperties? = nil, datadog: DatadogConnectorProfileProperties? = nil, dynatrace: DynatraceConnectorProfileProperties? = nil, googleAnalytics: GoogleAnalyticsConnectorProfileProperties? = nil, inforNexus: InforNexusConnectorProfileProperties? = nil, marketo: MarketoConnectorProfileProperties? = nil, redshift: RedshiftConnectorProfileProperties? = nil, salesforce: SalesforceConnectorProfileProperties? = nil, serviceNow: ServiceNowConnectorProfileProperties? = nil, singular: SingularConnectorProfileProperties? = nil, slack: SlackConnectorProfileProperties? = nil, snowflake: SnowflakeConnectorProfileProperties? = nil, trendmicro: TrendmicroConnectorProfileProperties? = nil, veeva: VeevaConnectorProfileProperties? = nil, zendesk: ZendeskConnectorProfileProperties? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.redshift = redshift
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.slack?.validate(name: "\(name).slack")
            try self.snowflake?.validate(name: "\(name).snowflake")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case redshift = "Redshift"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case snowflake = "Snowflake"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct CreateConnectorProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionMode", required: true, type: .enum), 
            AWSShapeMember(label: "connectorProfileConfig", required: true, type: .structure), 
            AWSShapeMember(label: "connectorProfileName", required: true, type: .string), 
            AWSShapeMember(label: "connectorType", required: true, type: .enum), 
            AWSShapeMember(label: "kmsArn", required: false, type: .string)
        ]

        ///  Indicates the connection mode and specifies whether it is public or private. Private flows use AWS PrivateLink to route data over AWS infrastructure without exposing it to the public internet. 
        public let connectionMode: ConnectionMode
        ///  Defines the connector-specific configuration and credentials. 
        public let connectorProfileConfig: ConnectorProfileConfig
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in your AWS account. 
        public let connectorProfileName: String
        ///  The type of connector, such as Salesforce, Amplitude, and so on. 
        public let connectorType: ConnectorType
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key. 
        public let kmsArn: String?

        public init(connectionMode: ConnectionMode, connectorProfileConfig: ConnectorProfileConfig, connectorProfileName: String, connectorType: ConnectorType, kmsArn: String? = nil) {
            self.connectionMode = connectionMode
            self.connectorProfileConfig = connectorProfileConfig
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.kmsArn = kmsArn
        }

        public func validate(name: String) throws {
            try self.connectorProfileConfig.validate(name: "\(name).connectorProfileConfig")
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, max: 256)
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try validate(self.kmsArn, name:"kmsArn", parent: name, max: 2048)
            try validate(self.kmsArn, name:"kmsArn", parent: name, min: 20)
            try validate(self.kmsArn, name:"kmsArn", parent: name, pattern: "arn:aws:kms:.*:[0-9]+:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionMode = "connectionMode"
            case connectorProfileConfig = "connectorProfileConfig"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case kmsArn = "kmsArn"
        }
    }

    public struct CreateConnectorProfileResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileArn", required: false, type: .string)
        ]

        ///  The Amazon Resource Name (ARN) of the connector profile. 
        public let connectorProfileArn: String?

        public init(connectorProfileArn: String? = nil) {
            self.connectorProfileArn = connectorProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileArn = "connectorProfileArn"
        }
    }

    public struct CreateFlowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "destinationFlowConfigList", required: true, type: .list), 
            AWSShapeMember(label: "flowName", required: true, type: .string), 
            AWSShapeMember(label: "kmsArn", required: false, type: .string), 
            AWSShapeMember(label: "sourceFlowConfig", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .map), 
            AWSShapeMember(label: "tasks", required: true, type: .list), 
            AWSShapeMember(label: "triggerConfig", required: true, type: .structure)
        ]

        ///  A description of the flow you want to create. 
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow places data in the destination connector. 
        public let destinationFlowConfigList: [DestinationFlowConfig]
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key. 
        public let kmsArn: String?
        ///  The configuration that controls how Amazon AppFlow retrieves data from the source connector. 
        public let sourceFlowConfig: SourceFlowConfig
        ///  The tags used to organize, track, or control access for your flow. 
        public let tags: [String: String]?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run. 
        public let tasks: [Task]
        ///  The trigger settings that determine how and when the flow runs. 
        public let triggerConfig: TriggerConfig

        public init(description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig], flowName: String, kmsArn: String? = nil, sourceFlowConfig: SourceFlowConfig, tags: [String: String]? = nil, tasks: [Task], triggerConfig: TriggerConfig) {
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.sourceFlowConfig = sourceFlowConfig
            self.tags = tags
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try validate(self.description, name:"description", parent: name, max: 2048)
            try validate(self.description, name:"description", parent: name, pattern: "[\\w!@#\\-.?,\\s]*")
            try self.destinationFlowConfigList.forEach {
                try $0.validate(name: "\(name).destinationFlowConfigList[]")
            }
            try validate(self.flowName, name:"flowName", parent: name, max: 256)
            try validate(self.flowName, name:"flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try validate(self.kmsArn, name:"kmsArn", parent: name, max: 2048)
            try validate(self.kmsArn, name:"kmsArn", parent: name, min: 20)
            try validate(self.kmsArn, name:"kmsArn", parent: name, pattern: "arn:aws:kms:.*:[0-9]+:.*")
            try self.sourceFlowConfig.validate(name: "\(name).sourceFlowConfig")
            try self.tags?.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, pattern: "[\\s\\w+-=\\.:/@]*")
            }
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case destinationFlowConfigList = "destinationFlowConfigList"
            case flowName = "flowName"
            case kmsArn = "kmsArn"
            case sourceFlowConfig = "sourceFlowConfig"
            case tags = "tags"
            case tasks = "tasks"
            case triggerConfig = "triggerConfig"
        }
    }

    public struct CreateFlowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowArn", required: false, type: .string), 
            AWSShapeMember(label: "flowStatus", required: false, type: .enum)
        ]

        ///  The flow's Amazon Resource Name (ARN). 
        public let flowArn: String?
        ///  Indicates the current status of the flow. 
        public let flowStatus: FlowStatus?

        public init(flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowArn = "flowArn"
            case flowStatus = "flowStatus"
        }
    }

    public struct DatadogConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiKey", required: true, type: .string), 
            AWSShapeMember(label: "applicationKey", required: true, type: .string)
        ]

        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API. 
        public let apiKey: String
        ///  Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API. 
        public let applicationKey: String

        public init(apiKey: String, applicationKey: String) {
            self.apiKey = apiKey
            self.applicationKey = applicationKey
        }

        public func validate(name: String) throws {
            try validate(self.apiKey, name:"apiKey", parent: name, max: 256)
            try validate(self.apiKey, name:"apiKey", parent: name, pattern: "\\S+")
            try validate(self.applicationKey, name:"applicationKey", parent: name, max: 512)
            try validate(self.applicationKey, name:"applicationKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
            case applicationKey = "applicationKey"
        }
    }

    public struct DatadogConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the Datadog resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct DatadogMetadata: AWSShape {


        public init() {
        }

    }

    public struct DatadogSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Datadog flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct DeleteConnectorProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileName", required: true, type: .string), 
            AWSShapeMember(label: "forceDelete", required: false, type: .boolean)
        ]

        ///  The name of the connector profile. The name is unique for each ConnectorProfile in your account. 
        public let connectorProfileName: String
        ///  Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows. 
        public let forceDelete: Bool?

        public init(connectorProfileName: String, forceDelete: Bool? = nil) {
            self.connectorProfileName = connectorProfileName
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, max: 256)
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "connectorProfileName"
            case forceDelete = "forceDelete"
        }
    }

    public struct DeleteConnectorProfileResponse: AWSShape {


        public init() {
        }

    }

    public struct DeleteFlowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowName", required: true, type: .string), 
            AWSShapeMember(label: "forceDelete", required: false, type: .boolean)
        ]

        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String
        ///  Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use. 
        public let forceDelete: Bool?

        public init(flowName: String, forceDelete: Bool? = nil) {
            self.flowName = flowName
            self.forceDelete = forceDelete
        }

        public func validate(name: String) throws {
            try validate(self.flowName, name:"flowName", parent: name, max: 256)
            try validate(self.flowName, name:"flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
            case forceDelete = "forceDelete"
        }
    }

    public struct DeleteFlowResponse: AWSShape {


        public init() {
        }

    }

    public struct DescribeConnectorEntityRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorEntityName", required: true, type: .string), 
            AWSShapeMember(label: "connectorProfileName", required: false, type: .string), 
            AWSShapeMember(label: "connectorType", required: false, type: .enum)
        ]

        ///  The entity name for that connector. 
        public let connectorEntityName: String
        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account. 
        public let connectorProfileName: String?
        ///  The type of connector application, such as Salesforce, Amplitude, and so on. 
        public let connectorType: ConnectorType?

        public init(connectorEntityName: String, connectorProfileName: String? = nil, connectorType: ConnectorType? = nil) {
            self.connectorEntityName = connectorEntityName
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
        }

        public func validate(name: String) throws {
            try validate(self.connectorEntityName, name:"connectorEntityName", parent: name, max: 128)
            try validate(self.connectorEntityName, name:"connectorEntityName", parent: name, pattern: "\\S+")
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, max: 256)
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityName = "connectorEntityName"
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
        }
    }

    public struct DescribeConnectorEntityResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorEntityFields", required: true, type: .list)
        ]

        ///  Describes the fields for that connector entity. For example, for an account entity, the fields would be account name, account ID, and so on. 
        public let connectorEntityFields: [ConnectorEntityField]

        public init(connectorEntityFields: [ConnectorEntityField]) {
            self.connectorEntityFields = connectorEntityFields
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityFields = "connectorEntityFields"
        }
    }

    public struct DescribeConnectorProfilesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileNames", required: false, type: .list), 
            AWSShapeMember(label: "connectorType", required: false, type: .enum), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account. 
        public let connectorProfileNames: [String]?
        ///  The type of connector, such as Salesforce, Amplitude, and so on. 
        public let connectorType: ConnectorType?
        ///  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations). 
        public let maxResults: Int?
        ///  The pagination token for the next page of data. 
        public let nextToken: String?

        public init(connectorProfileNames: [String]? = nil, connectorType: ConnectorType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectorProfileNames = connectorProfileNames
            self.connectorType = connectorType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.connectorProfileNames?.forEach {
                try validate($0, name: "connectorProfileNames[]", parent: name, max: 256)
                try validate($0, name: "connectorProfileNames[]", parent: name, pattern: "[\\w/!@#+=.-]+")
            }
            try validate(self.connectorProfileNames, name:"connectorProfileNames", parent: name, max: 100)
            try validate(self.connectorProfileNames, name:"connectorProfileNames", parent: name, min: 0)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2048)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileNames = "connectorProfileNames"
            case connectorType = "connectorType"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeConnectorProfilesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileDetails", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  Returns information about the connector profiles associated with the flow. 
        public let connectorProfileDetails: [ConnectorProfile]?
        ///  The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched. 
        public let nextToken: String?

        public init(connectorProfileDetails: [ConnectorProfile]? = nil, nextToken: String? = nil) {
            self.connectorProfileDetails = connectorProfileDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileDetails = "connectorProfileDetails"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeConnectorsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorTypes", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  The type of connector, such as Salesforce, Amplitude, and so on. 
        public let connectorTypes: [ConnectorType]?
        ///  The pagination token for the next page of data. 
        public let nextToken: String?

        public init(connectorTypes: [ConnectorType]? = nil, nextToken: String? = nil) {
            self.connectorTypes = connectorTypes
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.connectorTypes, name:"connectorTypes", parent: name, max: 100)
            try validate(self.connectorTypes, name:"connectorTypes", parent: name, min: 0)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2048)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorTypes = "connectorTypes"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeConnectorsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorConfigurations", required: false, type: .map), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  The configuration that is applied to the connectors used in the flow. 
        public let connectorConfigurations: [ConnectorType: ConnectorConfiguration]?
        ///  The pagination token for the next page of data. 
        public let nextToken: String?

        public init(connectorConfigurations: [ConnectorType: ConnectorConfiguration]? = nil, nextToken: String? = nil) {
            self.connectorConfigurations = connectorConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorConfigurations = "connectorConfigurations"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeFlowExecutionRecordsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowName", required: true, type: .string), 
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String
        ///  Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations). 
        public let maxResults: Int?
        ///  The pagination token for the next page of data. 
        public let nextToken: String?

        public init(flowName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.flowName = flowName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.flowName, name:"flowName", parent: name, max: 256)
            try validate(self.flowName, name:"flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2048)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeFlowExecutionRecordsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowExecutions", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  Returns a list of all instances when this flow was run. 
        public let flowExecutions: [ExecutionRecord]?
        ///  The pagination token for the next page of data. 
        public let nextToken: String?

        public init(flowExecutions: [ExecutionRecord]? = nil, nextToken: String? = nil) {
            self.flowExecutions = flowExecutions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowExecutions = "flowExecutions"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeFlowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowName", required: true, type: .string)
        ]

        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String

        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try validate(self.flowName, name:"flowName", parent: name, max: 256)
            try validate(self.flowName, name:"flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
        }
    }

    public struct DescribeFlowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "createdBy", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "destinationFlowConfigList", required: false, type: .list), 
            AWSShapeMember(label: "flowArn", required: false, type: .string), 
            AWSShapeMember(label: "flowName", required: false, type: .string), 
            AWSShapeMember(label: "flowStatus", required: false, type: .enum), 
            AWSShapeMember(label: "flowStatusMessage", required: false, type: .string), 
            AWSShapeMember(label: "kmsArn", required: false, type: .string), 
            AWSShapeMember(label: "lastRunExecutionDetails", required: false, type: .structure), 
            AWSShapeMember(label: "lastUpdatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedBy", required: false, type: .string), 
            AWSShapeMember(label: "sourceFlowConfig", required: false, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .map), 
            AWSShapeMember(label: "tasks", required: false, type: .list), 
            AWSShapeMember(label: "triggerConfig", required: false, type: .structure)
        ]

        ///  Specifies when the flow was created. 
        public let createdAt: TimeStamp?
        ///  The ARN of the user who created the flow. 
        public let createdBy: String?
        ///  A description of the flow. 
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow transfers data to the destination connector. 
        public let destinationFlowConfigList: [DestinationFlowConfig]?
        ///  The flow's Amazon Resource Name (ARN). 
        public let flowArn: String?
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String?
        ///  Indicates the current status of the flow. 
        public let flowStatus: FlowStatus?
        ///  Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows. 
        public let flowStatusMessage: String?
        ///  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key. 
        public let kmsArn: String?
        ///  Describes the details of the most recent flow run. 
        public let lastRunExecutionDetails: ExecutionDetails?
        ///  Specifies when the flow was last updated. 
        public let lastUpdatedAt: TimeStamp?
        ///  Specifies the user name of the account that performed the most recent update. 
        public let lastUpdatedBy: String?
        ///  The configuration that controls how Amazon AppFlow retrieves data from the source connector. 
        public let sourceFlowConfig: SourceFlowConfig?
        ///  The tags used to organize, track, or control access for your flow. 
        public let tags: [String: String]?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run. 
        public let tasks: [Task]?
        ///  The trigger settings that determine how and when the flow runs. 
        public let triggerConfig: TriggerConfig?

        public init(createdAt: TimeStamp? = nil, createdBy: String? = nil, description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig]? = nil, flowArn: String? = nil, flowName: String? = nil, flowStatus: FlowStatus? = nil, flowStatusMessage: String? = nil, kmsArn: String? = nil, lastRunExecutionDetails: ExecutionDetails? = nil, lastUpdatedAt: TimeStamp? = nil, lastUpdatedBy: String? = nil, sourceFlowConfig: SourceFlowConfig? = nil, tags: [String: String]? = nil, tasks: [Task]? = nil, triggerConfig: TriggerConfig? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.flowStatusMessage = flowStatusMessage
            self.kmsArn = kmsArn
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceFlowConfig = sourceFlowConfig
            self.tags = tags
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case destinationFlowConfigList = "destinationFlowConfigList"
            case flowArn = "flowArn"
            case flowName = "flowName"
            case flowStatus = "flowStatus"
            case flowStatusMessage = "flowStatusMessage"
            case kmsArn = "kmsArn"
            case lastRunExecutionDetails = "lastRunExecutionDetails"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case sourceFlowConfig = "sourceFlowConfig"
            case tags = "tags"
            case tasks = "tasks"
            case triggerConfig = "triggerConfig"
        }
    }

    public struct DestinationConnectorProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EventBridge", required: false, type: .structure), 
            AWSShapeMember(label: "Redshift", required: false, type: .structure), 
            AWSShapeMember(label: "S3", required: false, type: .structure), 
            AWSShapeMember(label: "Salesforce", required: false, type: .structure), 
            AWSShapeMember(label: "Snowflake", required: false, type: .structure)
        ]

        ///  The properties required to query Amazon EventBridge. 
        public let eventBridge: EventBridgeDestinationProperties?
        ///  The properties required to query Amazon Redshift. 
        public let redshift: RedshiftDestinationProperties?
        ///  The properties required to query Amazon S3. 
        public let s3: S3DestinationProperties?
        ///  The properties required to query Salesforce. 
        public let salesforce: SalesforceDestinationProperties?
        ///  The properties required to query Snowflake. 
        public let snowflake: SnowflakeDestinationProperties?

        public init(eventBridge: EventBridgeDestinationProperties? = nil, redshift: RedshiftDestinationProperties? = nil, s3: S3DestinationProperties? = nil, salesforce: SalesforceDestinationProperties? = nil, snowflake: SnowflakeDestinationProperties? = nil) {
            self.eventBridge = eventBridge
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.snowflake = snowflake
        }

        public func validate(name: String) throws {
            try self.eventBridge?.validate(name: "\(name).eventBridge")
            try self.redshift?.validate(name: "\(name).redshift")
            try self.s3?.validate(name: "\(name).s3")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.snowflake?.validate(name: "\(name).snowflake")
        }

        private enum CodingKeys: String, CodingKey {
            case eventBridge = "EventBridge"
            case redshift = "Redshift"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case snowflake = "Snowflake"
        }
    }

    public struct DestinationFieldProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isCreatable", required: false, type: .boolean), 
            AWSShapeMember(label: "isNullable", required: false, type: .boolean), 
            AWSShapeMember(label: "isUpsertable", required: false, type: .boolean)
        ]

        ///  Specifies if the destination field can be created by the current user. 
        public let isCreatable: Bool?
        ///  Specifies if the destination field can have a null value. 
        public let isNullable: Bool?
        ///  Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do. 
        public let isUpsertable: Bool?

        public init(isCreatable: Bool? = nil, isNullable: Bool? = nil, isUpsertable: Bool? = nil) {
            self.isCreatable = isCreatable
            self.isNullable = isNullable
            self.isUpsertable = isUpsertable
        }

        private enum CodingKeys: String, CodingKey {
            case isCreatable = "isCreatable"
            case isNullable = "isNullable"
            case isUpsertable = "isUpsertable"
        }
    }

    public struct DestinationFlowConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileName", required: false, type: .string), 
            AWSShapeMember(label: "connectorType", required: true, type: .enum), 
            AWSShapeMember(label: "destinationConnectorProperties", required: true, type: .structure)
        ]

        ///  The name of the connector profile. This name must be unique for each connector profile in the AWS account. 
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on. 
        public let connectorType: ConnectorType
        ///  This stores the information that is required to query a particular connector. 
        public let destinationConnectorProperties: DestinationConnectorProperties

        public init(connectorProfileName: String? = nil, connectorType: ConnectorType, destinationConnectorProperties: DestinationConnectorProperties) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.destinationConnectorProperties = destinationConnectorProperties
        }

        public func validate(name: String) throws {
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, max: 256)
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try self.destinationConnectorProperties.validate(name: "\(name).destinationConnectorProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case destinationConnectorProperties = "destinationConnectorProperties"
        }
    }

    public struct DynatraceConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiToken", required: true, type: .string)
        ]

        ///  The API tokens used by Dynatrace API to authenticate various API calls. 
        public let apiToken: String

        public init(apiToken: String) {
            self.apiToken = apiToken
        }

        public func validate(name: String) throws {
            try validate(self.apiToken, name:"apiToken", parent: name, max: 256)
            try validate(self.apiToken, name:"apiToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiToken = "apiToken"
        }
    }

    public struct DynatraceConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the Dynatrace resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct DynatraceMetadata: AWSShape {


        public init() {
        }

    }

    public struct DynatraceSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Dynatrace flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct ErrorHandlingConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketName", required: false, type: .string), 
            AWSShapeMember(label: "bucketPrefix", required: false, type: .string), 
            AWSShapeMember(label: "failOnFirstDestinationError", required: false, type: .boolean)
        ]

        ///  Specifies the name of the Amazon S3 bucket. 
        public let bucketName: String?
        ///  Specifies the Amazon S3 bucket prefix. 
        public let bucketPrefix: String?
        ///  Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination. 
        public let failOnFirstDestinationError: Bool?

        public init(bucketName: String? = nil, bucketPrefix: String? = nil, failOnFirstDestinationError: Bool? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.failOnFirstDestinationError = failOnFirstDestinationError
        }

        public func validate(name: String) throws {
            try validate(self.bucketName, name:"bucketName", parent: name, max: 63)
            try validate(self.bucketName, name:"bucketName", parent: name, min: 3)
            try validate(self.bucketName, name:"bucketName", parent: name, pattern: "\\S+")
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, max: 512)
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case failOnFirstDestinationError = "failOnFirstDestinationError"
        }
    }

    public struct ErrorInfo: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionMessage", required: false, type: .string), 
            AWSShapeMember(label: "putFailuresCount", required: false, type: .long)
        ]

        ///  Specifies the error message that appears if a flow fails. 
        public let executionMessage: String?
        ///  Specifies the failure count for the attempted flow. 
        public let putFailuresCount: Int64?

        public init(executionMessage: String? = nil, putFailuresCount: Int64? = nil) {
            self.executionMessage = executionMessage
            self.putFailuresCount = putFailuresCount
        }

        private enum CodingKeys: String, CodingKey {
            case executionMessage = "executionMessage"
            case putFailuresCount = "putFailuresCount"
        }
    }

    public struct EventBridgeDestinationProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "errorHandlingConfig", required: false, type: .structure), 
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The object specified in the Amazon EventBridge flow destination. 
        public let object: String

        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, object: String) {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig = "errorHandlingConfig"
            case object = "object"
        }
    }

    public struct EventBridgeMetadata: AWSShape {


        public init() {
        }

    }

    public struct ExecutionDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mostRecentExecutionMessage", required: false, type: .string), 
            AWSShapeMember(label: "mostRecentExecutionStatus", required: false, type: .enum), 
            AWSShapeMember(label: "mostRecentExecutionTime", required: false, type: .timestamp)
        ]

        ///  Describes the details of the most recent flow run. 
        public let mostRecentExecutionMessage: String?
        ///  Specifies the status of the most recent flow run. 
        public let mostRecentExecutionStatus: ExecutionStatus?
        ///  Specifies the time of the most recent flow run. 
        public let mostRecentExecutionTime: TimeStamp?

        public init(mostRecentExecutionMessage: String? = nil, mostRecentExecutionStatus: ExecutionStatus? = nil, mostRecentExecutionTime: TimeStamp? = nil) {
            self.mostRecentExecutionMessage = mostRecentExecutionMessage
            self.mostRecentExecutionStatus = mostRecentExecutionStatus
            self.mostRecentExecutionTime = mostRecentExecutionTime
        }

        private enum CodingKeys: String, CodingKey {
            case mostRecentExecutionMessage = "mostRecentExecutionMessage"
            case mostRecentExecutionStatus = "mostRecentExecutionStatus"
            case mostRecentExecutionTime = "mostRecentExecutionTime"
        }
    }

    public struct ExecutionRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "executionId", required: false, type: .string), 
            AWSShapeMember(label: "executionResult", required: false, type: .structure), 
            AWSShapeMember(label: "executionStatus", required: false, type: .enum), 
            AWSShapeMember(label: "lastUpdatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "startedAt", required: false, type: .timestamp)
        ]

        ///  Specifies the identifier of the given flow run. 
        public let executionId: String?
        ///  Describes the result of the given flow run. 
        public let executionResult: ExecutionResult?
        ///  Specifies the flow run status and whether it is in progress, has completed successfully, or has failed. 
        public let executionStatus: ExecutionStatus?
        ///  Specifies the time of the most recent update. 
        public let lastUpdatedAt: TimeStamp?
        ///  Specifies the start time of the flow run. 
        public let startedAt: TimeStamp?

        public init(executionId: String? = nil, executionResult: ExecutionResult? = nil, executionStatus: ExecutionStatus? = nil, lastUpdatedAt: TimeStamp? = nil, startedAt: TimeStamp? = nil) {
            self.executionId = executionId
            self.executionResult = executionResult
            self.executionStatus = executionStatus
            self.lastUpdatedAt = lastUpdatedAt
            self.startedAt = startedAt
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
            case executionResult = "executionResult"
            case executionStatus = "executionStatus"
            case lastUpdatedAt = "lastUpdatedAt"
            case startedAt = "startedAt"
        }
    }

    public struct ExecutionResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bytesProcessed", required: false, type: .long), 
            AWSShapeMember(label: "bytesWritten", required: false, type: .long), 
            AWSShapeMember(label: "errorInfo", required: false, type: .structure), 
            AWSShapeMember(label: "recordsProcessed", required: false, type: .long)
        ]

        ///  The total number of bytes processed by the flow run. 
        public let bytesProcessed: Int64?
        ///  The total number of bytes written as a result of the flow run. 
        public let bytesWritten: Int64?
        ///  Provides any error message information related to the flow run. 
        public let errorInfo: ErrorInfo?
        ///  The number of records processed in the flow run. 
        public let recordsProcessed: Int64?

        public init(bytesProcessed: Int64? = nil, bytesWritten: Int64? = nil, errorInfo: ErrorInfo? = nil, recordsProcessed: Int64? = nil) {
            self.bytesProcessed = bytesProcessed
            self.bytesWritten = bytesWritten
            self.errorInfo = errorInfo
            self.recordsProcessed = recordsProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case bytesProcessed = "bytesProcessed"
            case bytesWritten = "bytesWritten"
            case errorInfo = "errorInfo"
            case recordsProcessed = "recordsProcessed"
        }
    }

    public struct FieldTypeDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "fieldType", required: true, type: .string), 
            AWSShapeMember(label: "filterOperators", required: true, type: .list), 
            AWSShapeMember(label: "supportedValues", required: false, type: .list)
        ]

        ///  The type of field, such as string, integer, date, and so on. 
        public let fieldType: String
        ///  The list of operators supported by a field. 
        public let filterOperators: [Operator]
        ///  The list of values that a field can contain. For example, a Boolean fieldType can have two values: "true" and "false". 
        public let supportedValues: [String]?

        public init(fieldType: String, filterOperators: [Operator], supportedValues: [String]? = nil) {
            self.fieldType = fieldType
            self.filterOperators = filterOperators
            self.supportedValues = supportedValues
        }

        private enum CodingKeys: String, CodingKey {
            case fieldType = "fieldType"
            case filterOperators = "filterOperators"
            case supportedValues = "supportedValues"
        }
    }

    public struct FlowDefinition: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "createdAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "createdBy", required: false, type: .string), 
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "destinationConnectorType", required: false, type: .enum), 
            AWSShapeMember(label: "flowArn", required: false, type: .string), 
            AWSShapeMember(label: "flowName", required: false, type: .string), 
            AWSShapeMember(label: "flowStatus", required: false, type: .enum), 
            AWSShapeMember(label: "lastRunExecutionDetails", required: false, type: .structure), 
            AWSShapeMember(label: "lastUpdatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedBy", required: false, type: .string), 
            AWSShapeMember(label: "sourceConnectorType", required: false, type: .enum), 
            AWSShapeMember(label: "tags", required: false, type: .map), 
            AWSShapeMember(label: "triggerType", required: false, type: .enum)
        ]

        ///  Specifies when the flow was created. 
        public let createdAt: TimeStamp?
        ///  The ARN of the user who created the flow. 
        public let createdBy: String?
        ///  A user-entered description of the flow. 
        public let description: String?
        ///  Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on. 
        public let destinationConnectorType: ConnectorType?
        ///  The flow's Amazon Resource Name (ARN). 
        public let flowArn: String?
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String?
        ///  Indicates the current status of the flow. 
        public let flowStatus: FlowStatus?
        ///  Describes the details of the most recent flow run. 
        public let lastRunExecutionDetails: ExecutionDetails?
        ///  Specifies when the flow was last updated. 
        public let lastUpdatedAt: TimeStamp?
        ///  Specifies the account user name that most recently updated the flow. 
        public let lastUpdatedBy: String?
        ///  Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on. 
        public let sourceConnectorType: ConnectorType?
        ///  The tags used to organize, track, or control access for your flow. 
        public let tags: [String: String]?
        ///  Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event. 
        public let triggerType: TriggerType?

        public init(createdAt: TimeStamp? = nil, createdBy: String? = nil, description: String? = nil, destinationConnectorType: ConnectorType? = nil, flowArn: String? = nil, flowName: String? = nil, flowStatus: FlowStatus? = nil, lastRunExecutionDetails: ExecutionDetails? = nil, lastUpdatedAt: TimeStamp? = nil, lastUpdatedBy: String? = nil, sourceConnectorType: ConnectorType? = nil, tags: [String: String]? = nil, triggerType: TriggerType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationConnectorType = destinationConnectorType
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceConnectorType = sourceConnectorType
            self.tags = tags
            self.triggerType = triggerType
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case destinationConnectorType = "destinationConnectorType"
            case flowArn = "flowArn"
            case flowName = "flowName"
            case flowStatus = "flowStatus"
            case lastRunExecutionDetails = "lastRunExecutionDetails"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case sourceConnectorType = "sourceConnectorType"
            case tags = "tags"
            case triggerType = "triggerType"
        }
    }

    public struct GoogleAnalyticsConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessToken", required: false, type: .string), 
            AWSShapeMember(label: "clientId", required: true, type: .string), 
            AWSShapeMember(label: "clientSecret", required: true, type: .string), 
            AWSShapeMember(label: "oAuthRequest", required: false, type: .structure), 
            AWSShapeMember(label: "refreshToken", required: false, type: .string)
        ]

        ///  The credentials used to access protected Google Analytics resources. 
        public let accessToken: String?
        ///  The identifier for the desired client. 
        public let clientId: String
        ///  The client secret used by the oauth client to authenticate to the authorization server. 
        public let clientSecret: String
        ///  The oauth requirement needed to request security tokens from the connector endpoint. 
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens. 
        public let refreshToken: String?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try validate(self.accessToken, name:"accessToken", parent: name, max: 512)
            try validate(self.accessToken, name:"accessToken", parent: name, pattern: "\\S+")
            try validate(self.clientId, name:"clientId", parent: name, max: 512)
            try validate(self.clientId, name:"clientId", parent: name, pattern: "\\S+")
            try validate(self.clientSecret, name:"clientSecret", parent: name, max: 512)
            try validate(self.clientSecret, name:"clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try validate(self.refreshToken, name:"refreshToken", parent: name, max: 512)
            try validate(self.refreshToken, name:"refreshToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct GoogleAnalyticsConnectorProfileProperties: AWSShape {


        public init() {
        }

    }

    public struct GoogleAnalyticsMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "oAuthScopes", required: false, type: .list)
        ]

        ///  The desired authorization scope for the Google Analytics account. 
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct GoogleAnalyticsSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Google Analytics flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct InforNexusConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessKeyId", required: true, type: .string), 
            AWSShapeMember(label: "datakey", required: true, type: .string), 
            AWSShapeMember(label: "secretAccessKey", required: true, type: .string), 
            AWSShapeMember(label: "userId", required: true, type: .string)
        ]

        ///  The Access Key portion of the credentials. 
        public let accessKeyId: String
        ///  The encryption keys used to encrypt data. 
        public let datakey: String
        ///  The secret key used to sign requests. 
        public let secretAccessKey: String
        ///  The identifier for the user. 
        public let userId: String

        public init(accessKeyId: String, datakey: String, secretAccessKey: String, userId: String) {
            self.accessKeyId = accessKeyId
            self.datakey = datakey
            self.secretAccessKey = secretAccessKey
            self.userId = userId
        }

        public func validate(name: String) throws {
            try validate(self.accessKeyId, name:"accessKeyId", parent: name, max: 256)
            try validate(self.accessKeyId, name:"accessKeyId", parent: name, pattern: "\\S+")
            try validate(self.datakey, name:"datakey", parent: name, max: 512)
            try validate(self.datakey, name:"datakey", parent: name, pattern: "\\S+")
            try validate(self.secretAccessKey, name:"secretAccessKey", parent: name, max: 512)
            try validate(self.secretAccessKey, name:"secretAccessKey", parent: name, pattern: "\\S+")
            try validate(self.userId, name:"userId", parent: name, max: 512)
            try validate(self.userId, name:"userId", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case datakey = "datakey"
            case secretAccessKey = "secretAccessKey"
            case userId = "userId"
        }
    }

    public struct InforNexusConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the Infor Nexus resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct InforNexusMetadata: AWSShape {


        public init() {
        }

    }

    public struct InforNexusSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Infor Nexus flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct ListConnectorEntitiesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileName", required: false, type: .string), 
            AWSShapeMember(label: "connectorType", required: false, type: .enum), 
            AWSShapeMember(label: "entitiesPath", required: false, type: .string)
        ]

        ///  The name of the connector profile. The name is unique for each ConnectorProfile in the AWS account, and is used to query the downstream connector. 
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on. 
        public let connectorType: ConnectorType?
        ///  This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the entitiesPath parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider. 
        public let entitiesPath: String?

        public init(connectorProfileName: String? = nil, connectorType: ConnectorType? = nil, entitiesPath: String? = nil) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.entitiesPath = entitiesPath
        }

        public func validate(name: String) throws {
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, max: 256)
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try validate(self.entitiesPath, name:"entitiesPath", parent: name, max: 256)
            try validate(self.entitiesPath, name:"entitiesPath", parent: name, pattern: "[\\s\\w/!@#+=.-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case entitiesPath = "entitiesPath"
        }
    }

    public struct ListConnectorEntitiesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorEntityMap", required: true, type: .map)
        ]

        ///  The response of ListConnectorEntities lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group. 
        public let connectorEntityMap: [String: [ConnectorEntity]]

        public init(connectorEntityMap: [String: [ConnectorEntity]]) {
            self.connectorEntityMap = connectorEntityMap
        }

        private enum CodingKeys: String, CodingKey {
            case connectorEntityMap = "connectorEntityMap"
        }
    }

    public struct ListFlowsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "maxResults", required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  Specifies the maximum number of items that should be returned in the result set. 
        public let maxResults: Int?
        ///  The pagination token for next page of data. 
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 2048)
            try validate(self.nextToken, name:"nextToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListFlowsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flows", required: false, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        ///  The list of flows associated with your account. 
        public let flows: [FlowDefinition]?
        ///  The pagination token for next page of data. 
        public let nextToken: String?

        public init(flows: [FlowDefinition]? = nil, nextToken: String? = nil) {
            self.flows = flows
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flows = "flows"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string)
        ]

        ///  The Amazon Resource Name (ARN) of the specified flow. 
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 512)
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "arn:aws:.*:.*:[0-9]+:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tags", required: false, type: .map)
        ]

        ///  The tags used to organize, track, or control access for your flow. 
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MarketoConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessToken", required: false, type: .string), 
            AWSShapeMember(label: "clientId", required: true, type: .string), 
            AWSShapeMember(label: "clientSecret", required: true, type: .string), 
            AWSShapeMember(label: "oAuthRequest", required: false, type: .structure)
        ]

        ///  The credentials used to access protected Marketo resources. 
        public let accessToken: String?
        ///  The identifier for the desired client. 
        public let clientId: String
        ///  The client secret used by the oauth client to authenticate to the authorization server. 
        public let clientSecret: String
        ///  The oauth requirement needed to request security tokens from the connector endpoint. 
        public let oAuthRequest: ConnectorOAuthRequest?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try validate(self.accessToken, name:"accessToken", parent: name, max: 512)
            try validate(self.accessToken, name:"accessToken", parent: name, pattern: "\\S+")
            try validate(self.clientId, name:"clientId", parent: name, max: 512)
            try validate(self.clientId, name:"clientId", parent: name, pattern: "\\S+")
            try validate(self.clientSecret, name:"clientSecret", parent: name, max: 512)
            try validate(self.clientSecret, name:"clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
        }
    }

    public struct MarketoConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the Marketo resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct MarketoMetadata: AWSShape {


        public init() {
        }

    }

    public struct MarketoSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Marketo flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct PrefixConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "prefixFormat", required: false, type: .enum), 
            AWSShapeMember(label: "prefixType", required: false, type: .enum)
        ]

        ///  Determines the format of the prefix, and whether it applies to the file name, file path, or both. 
        public let prefixFormat: PrefixFormat?
        ///  Determines the level of granularity that's included in the prefix. 
        public let prefixType: PrefixType?

        public init(prefixFormat: PrefixFormat? = nil, prefixType: PrefixType? = nil) {
            self.prefixFormat = prefixFormat
            self.prefixType = prefixType
        }

        private enum CodingKeys: String, CodingKey {
            case prefixFormat = "prefixFormat"
            case prefixType = "prefixType"
        }
    }

    public struct RedshiftConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "password", required: true, type: .string), 
            AWSShapeMember(label: "username", required: true, type: .string)
        ]

        ///  The password that corresponds to the user name. 
        public let password: String
        ///  The name of the user. 
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try validate(self.password, name:"password", parent: name, max: 512)
            try validate(self.password, name:"password", parent: name, pattern: ".*")
            try validate(self.username, name:"username", parent: name, max: 512)
            try validate(self.username, name:"username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct RedshiftConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketName", required: true, type: .string), 
            AWSShapeMember(label: "bucketPrefix", required: false, type: .string), 
            AWSShapeMember(label: "databaseUrl", required: true, type: .string), 
            AWSShapeMember(label: "roleArn", required: true, type: .string)
        ]

        ///  A name for the associated Amazon S3 bucket. 
        public let bucketName: String
        ///  The object key for the destination bucket in which Amazon AppFlow places the files. 
        public let bucketPrefix: String?
        ///  The JDBC URL of the Amazon Redshift cluster. 
        public let databaseUrl: String
        ///  The Amazon Resource Name (ARN) of the IAM role. 
        public let roleArn: String

        public init(bucketName: String, bucketPrefix: String? = nil, databaseUrl: String, roleArn: String) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.databaseUrl = databaseUrl
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try validate(self.bucketName, name:"bucketName", parent: name, max: 63)
            try validate(self.bucketName, name:"bucketName", parent: name, min: 3)
            try validate(self.bucketName, name:"bucketName", parent: name, pattern: "\\S+")
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, max: 512)
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, pattern: ".*")
            try validate(self.databaseUrl, name:"databaseUrl", parent: name, max: 512)
            try validate(self.databaseUrl, name:"databaseUrl", parent: name, pattern: "\\S+")
            try validate(self.roleArn, name:"roleArn", parent: name, max: 512)
            try validate(self.roleArn, name:"roleArn", parent: name, pattern: "arn:aws:iam:.*:[0-9]+:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case databaseUrl = "databaseUrl"
            case roleArn = "roleArn"
        }
    }

    public struct RedshiftDestinationProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketPrefix", required: false, type: .string), 
            AWSShapeMember(label: "errorHandlingConfig", required: false, type: .structure), 
            AWSShapeMember(label: "intermediateBucketName", required: true, type: .string), 
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object key for the bucket in which Amazon AppFlow places the destination files. 
        public let bucketPrefix: String?
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details. 
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift. 
        public let intermediateBucketName: String
        ///  The object specified in the Amazon Redshift flow destination. 
        public let object: String

        public init(bucketPrefix: String? = nil, errorHandlingConfig: ErrorHandlingConfig? = nil, intermediateBucketName: String, object: String) {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, max: 512)
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, pattern: ".*")
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try validate(self.intermediateBucketName, name:"intermediateBucketName", parent: name, max: 63)
            try validate(self.intermediateBucketName, name:"intermediateBucketName", parent: name, min: 3)
            try validate(self.intermediateBucketName, name:"intermediateBucketName", parent: name, pattern: "\\S+")
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketPrefix = "bucketPrefix"
            case errorHandlingConfig = "errorHandlingConfig"
            case intermediateBucketName = "intermediateBucketName"
            case object = "object"
        }
    }

    public struct RedshiftMetadata: AWSShape {


        public init() {
        }

    }

    public struct S3DestinationProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketName", required: true, type: .string), 
            AWSShapeMember(label: "bucketPrefix", required: false, type: .string), 
            AWSShapeMember(label: "s3OutputFormatConfig", required: false, type: .structure)
        ]

        ///  The Amazon S3 bucket name in which Amazon AppFlow places the transferred data. 
        public let bucketName: String
        ///  The object key for the destination bucket in which Amazon AppFlow places the files. 
        public let bucketPrefix: String?
        public let s3OutputFormatConfig: S3OutputFormatConfig?

        public init(bucketName: String, bucketPrefix: String? = nil, s3OutputFormatConfig: S3OutputFormatConfig? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }

        public func validate(name: String) throws {
            try validate(self.bucketName, name:"bucketName", parent: name, max: 63)
            try validate(self.bucketName, name:"bucketName", parent: name, min: 3)
            try validate(self.bucketName, name:"bucketName", parent: name, pattern: "\\S+")
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, max: 512)
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case s3OutputFormatConfig = "s3OutputFormatConfig"
        }
    }

    public struct S3Metadata: AWSShape {


        public init() {
        }

    }

    public struct S3OutputFormatConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "aggregationConfig", required: false, type: .structure), 
            AWSShapeMember(label: "fileType", required: false, type: .enum), 
            AWSShapeMember(label: "prefixConfig", required: false, type: .structure)
        ]

        public let aggregationConfig: AggregationConfig?
        ///  Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket. 
        public let fileType: FileType?
        ///  Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date. 
        public let prefixConfig: PrefixConfig?

        public init(aggregationConfig: AggregationConfig? = nil, fileType: FileType? = nil, prefixConfig: PrefixConfig? = nil) {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationConfig = "aggregationConfig"
            case fileType = "fileType"
            case prefixConfig = "prefixConfig"
        }
    }

    public struct S3SourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketName", required: true, type: .string), 
            AWSShapeMember(label: "bucketPrefix", required: false, type: .string)
        ]

        ///  The Amazon S3 bucket name where the source files are stored. 
        public let bucketName: String
        ///  The object key for the Amazon S3 bucket in which the source files are stored. 
        public let bucketPrefix: String?

        public init(bucketName: String, bucketPrefix: String? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }

        public func validate(name: String) throws {
            try validate(self.bucketName, name:"bucketName", parent: name, max: 63)
            try validate(self.bucketName, name:"bucketName", parent: name, min: 3)
            try validate(self.bucketName, name:"bucketName", parent: name, pattern: "\\S+")
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, max: 512)
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
        }
    }

    public struct SalesforceConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessToken", required: false, type: .string), 
            AWSShapeMember(label: "oAuthRequest", required: false, type: .structure), 
            AWSShapeMember(label: "refreshToken", required: false, type: .string)
        ]

        ///  The credentials used to access protected Salesforce resources. 
        public let accessToken: String?
        ///  The oauth requirement needed to request security tokens from the connector endpoint. 
        public let oAuthRequest: ConnectorOAuthRequest?
        ///  The credentials used to acquire new access tokens. 
        public let refreshToken: String?

        public init(accessToken: String? = nil, oAuthRequest: ConnectorOAuthRequest? = nil, refreshToken: String? = nil) {
            self.accessToken = accessToken
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }

        public func validate(name: String) throws {
            try validate(self.accessToken, name:"accessToken", parent: name, max: 512)
            try validate(self.accessToken, name:"accessToken", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
            try validate(self.refreshToken, name:"refreshToken", parent: name, max: 512)
            try validate(self.refreshToken, name:"refreshToken", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case oAuthRequest = "oAuthRequest"
            case refreshToken = "refreshToken"
        }
    }

    public struct SalesforceConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: false, type: .string), 
            AWSShapeMember(label: "isSandboxEnvironment", required: false, type: .boolean)
        ]

        ///  The location of the Salesforce resource. 
        public let instanceUrl: String?
        ///  Indicates whether the connector profile applies to a sandbox or production environment. 
        public let isSandboxEnvironment: Bool?

        public init(instanceUrl: String? = nil, isSandboxEnvironment: Bool? = nil) {
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
            case isSandboxEnvironment = "isSandboxEnvironment"
        }
    }

    public struct SalesforceDestinationProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "errorHandlingConfig", required: false, type: .structure), 
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details. 
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The object specified in the Salesforce flow destination. 
        public let object: String

        public init(errorHandlingConfig: ErrorHandlingConfig? = nil, object: String) {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }

        public func validate(name: String) throws {
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case errorHandlingConfig = "errorHandlingConfig"
            case object = "object"
        }
    }

    public struct SalesforceMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "oAuthScopes", required: false, type: .list)
        ]

        ///  The desired authorization scope for the Salesforce account. 
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct SalesforceSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "enableDynamicFieldUpdate", required: false, type: .boolean), 
            AWSShapeMember(label: "includeDeletedRecords", required: false, type: .boolean), 
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow. 
        public let enableDynamicFieldUpdate: Bool?
        ///  Indicates whether Amazon AppFlow includes deleted files in the flow run. 
        public let includeDeletedRecords: Bool?
        ///  The object specified in the Salesforce flow source. 
        public let object: String

        public init(enableDynamicFieldUpdate: Bool? = nil, includeDeletedRecords: Bool? = nil, object: String) {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case enableDynamicFieldUpdate = "enableDynamicFieldUpdate"
            case includeDeletedRecords = "includeDeletedRecords"
            case object = "object"
        }
    }

    public struct ScheduledTriggerProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "dataPullMode", required: false, type: .enum), 
            AWSShapeMember(label: "scheduleEndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "scheduleExpression", required: true, type: .string), 
            AWSShapeMember(label: "scheduleStartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "timezone", required: false, type: .string)
        ]

        ///  Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run. 
        public let dataPullMode: DataPullMode?
        ///  Specifies the scheduled end time for a schedule-triggered flow. 
        public let scheduleEndTime: TimeStamp?
        ///  The scheduling expression that determines when and how often the rule runs. 
        public let scheduleExpression: String
        ///  Specifies the scheduled start time for a schedule-triggered flow. 
        public let scheduleStartTime: TimeStamp?
        ///  Specifies the time zone used when referring to the date and time of a scheduled-triggered flow. 
        public let timezone: String?

        public init(dataPullMode: DataPullMode? = nil, scheduleEndTime: TimeStamp? = nil, scheduleExpression: String, scheduleStartTime: TimeStamp? = nil, timezone: String? = nil) {
            self.dataPullMode = dataPullMode
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try validate(self.scheduleExpression, name:"scheduleExpression", parent: name, max: 256)
            try validate(self.scheduleExpression, name:"scheduleExpression", parent: name, pattern: ".*")
            try validate(self.timezone, name:"timezone", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case dataPullMode = "dataPullMode"
            case scheduleEndTime = "scheduleEndTime"
            case scheduleExpression = "scheduleExpression"
            case scheduleStartTime = "scheduleStartTime"
            case timezone = "timezone"
        }
    }

    public struct ServiceNowConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "password", required: true, type: .string), 
            AWSShapeMember(label: "username", required: true, type: .string)
        ]

        ///  The password that corresponds to the user name. 
        public let password: String
        ///  The name of the user. 
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try validate(self.password, name:"password", parent: name, max: 512)
            try validate(self.password, name:"password", parent: name, pattern: ".*")
            try validate(self.username, name:"username", parent: name, max: 512)
            try validate(self.username, name:"username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct ServiceNowConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the ServiceNow resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct ServiceNowMetadata: AWSShape {


        public init() {
        }

    }

    public struct ServiceNowSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the ServiceNow flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct SingularConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiKey", required: true, type: .string)
        ]

        ///  A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API. 
        public let apiKey: String

        public init(apiKey: String) {
            self.apiKey = apiKey
        }

        public func validate(name: String) throws {
            try validate(self.apiKey, name:"apiKey", parent: name, max: 256)
            try validate(self.apiKey, name:"apiKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct SingularConnectorProfileProperties: AWSShape {


        public init() {
        }

    }

    public struct SingularMetadata: AWSShape {


        public init() {
        }

    }

    public struct SingularSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Singular flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct SlackConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessToken", required: false, type: .string), 
            AWSShapeMember(label: "clientId", required: true, type: .string), 
            AWSShapeMember(label: "clientSecret", required: true, type: .string), 
            AWSShapeMember(label: "oAuthRequest", required: false, type: .structure)
        ]

        ///  The credentials used to access protected Slack resources. 
        public let accessToken: String?
        ///  The identifier for the client. 
        public let clientId: String
        ///  The client secret used by the oauth client to authenticate to the authorization server. 
        public let clientSecret: String
        ///  The oauth requirement needed to request security tokens from the connector endpoint. 
        public let oAuthRequest: ConnectorOAuthRequest?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try validate(self.accessToken, name:"accessToken", parent: name, max: 512)
            try validate(self.accessToken, name:"accessToken", parent: name, pattern: "\\S+")
            try validate(self.clientId, name:"clientId", parent: name, max: 512)
            try validate(self.clientId, name:"clientId", parent: name, pattern: "\\S+")
            try validate(self.clientSecret, name:"clientSecret", parent: name, max: 512)
            try validate(self.clientSecret, name:"clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
        }
    }

    public struct SlackConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the Slack resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct SlackMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "oAuthScopes", required: false, type: .list)
        ]

        ///  The desired authorization scope for the Slack account. 
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct SlackSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Slack flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct SnowflakeConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "password", required: true, type: .string), 
            AWSShapeMember(label: "username", required: true, type: .string)
        ]

        ///  The password that corresponds to the user name. 
        public let password: String
        ///  The name of the user. 
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try validate(self.password, name:"password", parent: name, max: 512)
            try validate(self.password, name:"password", parent: name, pattern: ".*")
            try validate(self.username, name:"username", parent: name, max: 512)
            try validate(self.username, name:"username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct SnowflakeConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accountName", required: false, type: .string), 
            AWSShapeMember(label: "bucketName", required: true, type: .string), 
            AWSShapeMember(label: "bucketPrefix", required: false, type: .string), 
            AWSShapeMember(label: "privateLinkServiceName", required: false, type: .string), 
            AWSShapeMember(label: "region", required: false, type: .string), 
            AWSShapeMember(label: "stage", required: true, type: .string), 
            AWSShapeMember(label: "warehouse", required: true, type: .string)
        ]

        ///  The name of the account. 
        public let accountName: String?
        ///  The name of the Amazon S3 bucket associated with Snowflake. 
        public let bucketName: String
        ///  The bucket path that refers to the Amazon S3 bucket associated with Snowflake. 
        public let bucketPrefix: String?
        ///  The Snowflake Private Link service name to be used for private data transfers. 
        public let privateLinkServiceName: String?
        ///  The AWS Region of the Snowflake account. 
        public let region: String?
        ///  The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: &lt; Database&gt;&lt; Schema&gt;&lt;Stage Name&gt;. 
        public let stage: String
        ///  The name of the Snowflake warehouse. 
        public let warehouse: String

        public init(accountName: String? = nil, bucketName: String, bucketPrefix: String? = nil, privateLinkServiceName: String? = nil, region: String? = nil, stage: String, warehouse: String) {
            self.accountName = accountName
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.privateLinkServiceName = privateLinkServiceName
            self.region = region
            self.stage = stage
            self.warehouse = warehouse
        }

        public func validate(name: String) throws {
            try validate(self.accountName, name:"accountName", parent: name, max: 512)
            try validate(self.accountName, name:"accountName", parent: name, pattern: "\\S+")
            try validate(self.bucketName, name:"bucketName", parent: name, max: 63)
            try validate(self.bucketName, name:"bucketName", parent: name, min: 3)
            try validate(self.bucketName, name:"bucketName", parent: name, pattern: "\\S+")
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, max: 512)
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, pattern: ".*")
            try validate(self.privateLinkServiceName, name:"privateLinkServiceName", parent: name, max: 512)
            try validate(self.privateLinkServiceName, name:"privateLinkServiceName", parent: name, pattern: "\\S+")
            try validate(self.region, name:"region", parent: name, max: 64)
            try validate(self.region, name:"region", parent: name, pattern: "\\S+")
            try validate(self.stage, name:"stage", parent: name, max: 512)
            try validate(self.stage, name:"stage", parent: name, pattern: "\\S+")
            try validate(self.warehouse, name:"warehouse", parent: name, max: 512)
            try validate(self.warehouse, name:"warehouse", parent: name, pattern: "[\\s\\w/!@#+=.-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountName = "accountName"
            case bucketName = "bucketName"
            case bucketPrefix = "bucketPrefix"
            case privateLinkServiceName = "privateLinkServiceName"
            case region = "region"
            case stage = "stage"
            case warehouse = "warehouse"
        }
    }

    public struct SnowflakeDestinationProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "bucketPrefix", required: false, type: .string), 
            AWSShapeMember(label: "errorHandlingConfig", required: false, type: .structure), 
            AWSShapeMember(label: "intermediateBucketName", required: true, type: .string), 
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object key for the destination bucket in which Amazon AppFlow places the files. 
        public let bucketPrefix: String?
        ///  The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details. 
        public let errorHandlingConfig: ErrorHandlingConfig?
        ///  The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake. 
        public let intermediateBucketName: String
        ///  The object specified in the Snowflake flow destination. 
        public let object: String

        public init(bucketPrefix: String? = nil, errorHandlingConfig: ErrorHandlingConfig? = nil, intermediateBucketName: String, object: String) {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, max: 512)
            try validate(self.bucketPrefix, name:"bucketPrefix", parent: name, pattern: ".*")
            try self.errorHandlingConfig?.validate(name: "\(name).errorHandlingConfig")
            try validate(self.intermediateBucketName, name:"intermediateBucketName", parent: name, max: 63)
            try validate(self.intermediateBucketName, name:"intermediateBucketName", parent: name, min: 3)
            try validate(self.intermediateBucketName, name:"intermediateBucketName", parent: name, pattern: "\\S+")
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketPrefix = "bucketPrefix"
            case errorHandlingConfig = "errorHandlingConfig"
            case intermediateBucketName = "intermediateBucketName"
            case object = "object"
        }
    }

    public struct SnowflakeMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "supportedRegions", required: false, type: .list)
        ]

        ///  Specifies the supported AWS Regions when using Snowflake. 
        public let supportedRegions: [String]?

        public init(supportedRegions: [String]? = nil) {
            self.supportedRegions = supportedRegions
        }

        private enum CodingKeys: String, CodingKey {
            case supportedRegions = "supportedRegions"
        }
    }

    public struct SourceConnectorProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Amplitude", required: false, type: .structure), 
            AWSShapeMember(label: "Datadog", required: false, type: .structure), 
            AWSShapeMember(label: "Dynatrace", required: false, type: .structure), 
            AWSShapeMember(label: "GoogleAnalytics", required: false, type: .structure), 
            AWSShapeMember(label: "InforNexus", required: false, type: .structure), 
            AWSShapeMember(label: "Marketo", required: false, type: .structure), 
            AWSShapeMember(label: "S3", required: false, type: .structure), 
            AWSShapeMember(label: "Salesforce", required: false, type: .structure), 
            AWSShapeMember(label: "ServiceNow", required: false, type: .structure), 
            AWSShapeMember(label: "Singular", required: false, type: .structure), 
            AWSShapeMember(label: "Slack", required: false, type: .structure), 
            AWSShapeMember(label: "Trendmicro", required: false, type: .structure), 
            AWSShapeMember(label: "Veeva", required: false, type: .structure), 
            AWSShapeMember(label: "Zendesk", required: false, type: .structure)
        ]

        ///  Specifies the information that is required for querying Amplitude. 
        public let amplitude: AmplitudeSourceProperties?
        ///  Specifies the information that is required for querying Datadog. 
        public let datadog: DatadogSourceProperties?
        ///  Specifies the information that is required for querying Dynatrace. 
        public let dynatrace: DynatraceSourceProperties?
        ///  Specifies the information that is required for querying Google Analytics. 
        public let googleAnalytics: GoogleAnalyticsSourceProperties?
        ///  Specifies the information that is required for querying Infor Nexus. 
        public let inforNexus: InforNexusSourceProperties?
        ///  Specifies the information that is required for querying Marketo. 
        public let marketo: MarketoSourceProperties?
        ///  Specifies the information that is required for querying Amazon S3. 
        public let s3: S3SourceProperties?
        ///  Specifies the information that is required for querying Salesforce. 
        public let salesforce: SalesforceSourceProperties?
        ///  Specifies the information that is required for querying ServiceNow. 
        public let serviceNow: ServiceNowSourceProperties?
        ///  Specifies the information that is required for querying Singular. 
        public let singular: SingularSourceProperties?
        ///  Specifies the information that is required for querying Slack. 
        public let slack: SlackSourceProperties?
        ///  Specifies the information that is required for querying Trend Micro. 
        public let trendmicro: TrendmicroSourceProperties?
        ///  Specifies the information that is required for querying Veeva. 
        public let veeva: VeevaSourceProperties?
        ///  Specifies the information that is required for querying Zendesk. 
        public let zendesk: ZendeskSourceProperties?

        public init(amplitude: AmplitudeSourceProperties? = nil, datadog: DatadogSourceProperties? = nil, dynatrace: DynatraceSourceProperties? = nil, googleAnalytics: GoogleAnalyticsSourceProperties? = nil, inforNexus: InforNexusSourceProperties? = nil, marketo: MarketoSourceProperties? = nil, s3: S3SourceProperties? = nil, salesforce: SalesforceSourceProperties? = nil, serviceNow: ServiceNowSourceProperties? = nil, singular: SingularSourceProperties? = nil, slack: SlackSourceProperties? = nil, trendmicro: TrendmicroSourceProperties? = nil, veeva: VeevaSourceProperties? = nil, zendesk: ZendeskSourceProperties? = nil) {
            self.amplitude = amplitude
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.amplitude?.validate(name: "\(name).amplitude")
            try self.datadog?.validate(name: "\(name).datadog")
            try self.dynatrace?.validate(name: "\(name).dynatrace")
            try self.googleAnalytics?.validate(name: "\(name).googleAnalytics")
            try self.inforNexus?.validate(name: "\(name).inforNexus")
            try self.marketo?.validate(name: "\(name).marketo")
            try self.s3?.validate(name: "\(name).s3")
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.singular?.validate(name: "\(name).singular")
            try self.slack?.validate(name: "\(name).slack")
            try self.trendmicro?.validate(name: "\(name).trendmicro")
            try self.veeva?.validate(name: "\(name).veeva")
            try self.zendesk?.validate(name: "\(name).zendesk")
        }

        private enum CodingKeys: String, CodingKey {
            case amplitude = "Amplitude"
            case datadog = "Datadog"
            case dynatrace = "Dynatrace"
            case googleAnalytics = "GoogleAnalytics"
            case inforNexus = "InforNexus"
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case singular = "Singular"
            case slack = "Slack"
            case trendmicro = "Trendmicro"
            case veeva = "Veeva"
            case zendesk = "Zendesk"
        }
    }

    public struct SourceFieldProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "isQueryable", required: false, type: .boolean), 
            AWSShapeMember(label: "isRetrievable", required: false, type: .boolean)
        ]

        ///  Indicates if the field can be queried. 
        public let isQueryable: Bool?
        ///  Indicates whether the field can be returned in a search result. 
        public let isRetrievable: Bool?

        public init(isQueryable: Bool? = nil, isRetrievable: Bool? = nil) {
            self.isQueryable = isQueryable
            self.isRetrievable = isRetrievable
        }

        private enum CodingKeys: String, CodingKey {
            case isQueryable = "isQueryable"
            case isRetrievable = "isRetrievable"
        }
    }

    public struct SourceFlowConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileName", required: false, type: .string), 
            AWSShapeMember(label: "connectorType", required: true, type: .enum), 
            AWSShapeMember(label: "sourceConnectorProperties", required: true, type: .structure)
        ]

        ///  The name of the connector profile. This name must be unique for each connector profile in the AWS account. 
        public let connectorProfileName: String?
        ///  The type of connector, such as Salesforce, Amplitude, and so on. 
        public let connectorType: ConnectorType
        ///  Specifies the information that is required to query a particular source connector. 
        public let sourceConnectorProperties: SourceConnectorProperties

        public init(connectorProfileName: String? = nil, connectorType: ConnectorType, sourceConnectorProperties: SourceConnectorProperties) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.sourceConnectorProperties = sourceConnectorProperties
        }

        public func validate(name: String) throws {
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, max: 256)
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try self.sourceConnectorProperties.validate(name: "\(name).sourceConnectorProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "connectorProfileName"
            case connectorType = "connectorType"
            case sourceConnectorProperties = "sourceConnectorProperties"
        }
    }

    public struct StartFlowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowName", required: true, type: .string)
        ]

        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String

        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try validate(self.flowName, name:"flowName", parent: name, max: 256)
            try validate(self.flowName, name:"flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
        }
    }

    public struct StartFlowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowArn", required: false, type: .string), 
            AWSShapeMember(label: "flowStatus", required: false, type: .enum)
        ]

        ///  The flow's Amazon Resource Name (ARN). 
        public let flowArn: String?
        ///  Indicates the current status of the flow. 
        public let flowStatus: FlowStatus?

        public init(flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowArn = "flowArn"
            case flowStatus = "flowStatus"
        }
    }

    public struct StopFlowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowName", required: true, type: .string)
        ]

        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String

        public init(flowName: String) {
            self.flowName = flowName
        }

        public func validate(name: String) throws {
            try validate(self.flowName, name:"flowName", parent: name, max: 256)
            try validate(self.flowName, name:"flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case flowName = "flowName"
        }
    }

    public struct StopFlowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowArn", required: false, type: .string), 
            AWSShapeMember(label: "flowStatus", required: false, type: .enum)
        ]

        ///  The flow's Amazon Resource Name (ARN). 
        public let flowArn: String?
        ///  Indicates the current status of the flow. 
        public let flowStatus: FlowStatus?

        public init(flowArn: String? = nil, flowStatus: FlowStatus? = nil) {
            self.flowArn = flowArn
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowArn = "flowArn"
            case flowStatus = "flowStatus"
        }
    }

    public struct SupportedFieldTypeDetails: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "v1", required: true, type: .structure)
        ]

        ///  The initial supported version for fieldType. If this is later changed to a different version, v2 will be introduced. 
        public let v1: FieldTypeDetails

        public init(v1: FieldTypeDetails) {
            self.v1 = v1
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .map)
        ]

        ///  The Amazon Resource Name (ARN) of the flow that you want to tag. 
        public let resourceArn: String
        ///  The tags used to organize, track, or control access for your flow. 
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 512)
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "arn:aws:.*:.*:[0-9]+:.*")
            try self.tags.forEach {
                try validate($0.key, name:"tags.key", parent: name, max: 128)
                try validate($0.key, name:"tags.key", parent: name, min: 1)
                try validate($0.key, name:"tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name:"tags[\"\($0.key)\"]", parent: name, pattern: "[\\s\\w+-=\\.:/@]*")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct Task: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorOperator", required: false, type: .structure), 
            AWSShapeMember(label: "destinationField", required: false, type: .string), 
            AWSShapeMember(label: "sourceFields", required: true, type: .list), 
            AWSShapeMember(label: "taskProperties", required: false, type: .map), 
            AWSShapeMember(label: "taskType", required: true, type: .enum)
        ]

        ///  The operation to be performed on the provided source fields. 
        public let connectorOperator: ConnectorOperator?
        ///  A field in a destination connector, or a field value against which Amazon AppFlow validates a source field. 
        public let destinationField: String?
        ///  The source fields to which a particular task is applied. 
        public let sourceFields: [String]
        ///  A map used to store task-related information. The execution service looks for particular information based on the TaskType. 
        public let taskProperties: [OperatorPropertiesKeys: String]?
        ///  Specifies the particular task implementation that Amazon AppFlow performs. 
        public let taskType: TaskType

        public init(connectorOperator: ConnectorOperator? = nil, destinationField: String? = nil, sourceFields: [String], taskProperties: [OperatorPropertiesKeys: String]? = nil, taskType: TaskType) {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }

        public func validate(name: String) throws {
            try validate(self.destinationField, name:"destinationField", parent: name, max: 256)
            try validate(self.destinationField, name:"destinationField", parent: name, pattern: ".*")
            try self.sourceFields.forEach {
                try validate($0, name: "sourceFields[]", parent: name, max: 2048)
                try validate($0, name: "sourceFields[]", parent: name, pattern: ".*")
            }
            try self.taskProperties?.forEach {
                try validate($0.value, name:"taskProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name:"taskProperties[\"\($0.key)\"]", parent: name, pattern: ".+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectorOperator = "connectorOperator"
            case destinationField = "destinationField"
            case sourceFields = "sourceFields"
            case taskProperties = "taskProperties"
            case taskType = "taskType"
        }
    }

    public struct TrendmicroConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "apiSecretKey", required: true, type: .string)
        ]

        ///  The Secret Access Key portion of the credentials. 
        public let apiSecretKey: String

        public init(apiSecretKey: String) {
            self.apiSecretKey = apiSecretKey
        }

        public func validate(name: String) throws {
            try validate(self.apiSecretKey, name:"apiSecretKey", parent: name, max: 256)
            try validate(self.apiSecretKey, name:"apiSecretKey", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case apiSecretKey = "apiSecretKey"
        }
    }

    public struct TrendmicroConnectorProfileProperties: AWSShape {


        public init() {
        }

    }

    public struct TrendmicroMetadata: AWSShape {


        public init() {
        }

    }

    public struct TrendmicroSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Trend Micro flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct TriggerConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "triggerProperties", required: false, type: .structure), 
            AWSShapeMember(label: "triggerType", required: true, type: .enum)
        ]

        ///  Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type. 
        public let triggerProperties: TriggerProperties?
        ///  Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event. 
        public let triggerType: TriggerType

        public init(triggerProperties: TriggerProperties? = nil, triggerType: TriggerType) {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }

        public func validate(name: String) throws {
            try self.triggerProperties?.validate(name: "\(name).triggerProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case triggerProperties = "triggerProperties"
            case triggerType = "triggerType"
        }
    }

    public struct TriggerProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Scheduled", required: false, type: .structure)
        ]

        ///  Specifies the configuration details of a schedule-triggered flow as defined by the user. 
        public let scheduled: ScheduledTriggerProperties?

        public init(scheduled: ScheduledTriggerProperties? = nil) {
            self.scheduled = scheduled
        }

        public func validate(name: String) throws {
            try self.scheduled?.validate(name: "\(name).scheduled")
        }

        private enum CodingKeys: String, CodingKey {
            case scheduled = "Scheduled"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .uri(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tagKeys", location: .querystring(locationName: "tagKeys"), required: true, type: .list)
        ]

        ///  The Amazon Resource Name (ARN) of the flow that you want to untag. 
        public let resourceArn: String
        ///  The tag keys associated with the tag that you want to remove from your flow. 
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceArn, name:"resourceArn", parent: name, max: 512)
            try validate(self.resourceArn, name:"resourceArn", parent: name, pattern: "arn:aws:.*:.*:[0-9]+:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateConnectorProfileRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectionMode", required: true, type: .enum), 
            AWSShapeMember(label: "connectorProfileConfig", required: true, type: .structure), 
            AWSShapeMember(label: "connectorProfileName", required: true, type: .string)
        ]

        ///  Indicates the connection mode and if it is public or private. 
        public let connectionMode: ConnectionMode
        ///  Defines the connector-specific profile configuration and credentials. 
        public let connectorProfileConfig: ConnectorProfileConfig
        ///  The name of the connector profile and is unique for each ConnectorProfile in the AWS Account. 
        public let connectorProfileName: String

        public init(connectionMode: ConnectionMode, connectorProfileConfig: ConnectorProfileConfig, connectorProfileName: String) {
            self.connectionMode = connectionMode
            self.connectorProfileConfig = connectorProfileConfig
            self.connectorProfileName = connectorProfileName
        }

        public func validate(name: String) throws {
            try self.connectorProfileConfig.validate(name: "\(name).connectorProfileConfig")
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, max: 256)
            try validate(self.connectorProfileName, name:"connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionMode = "connectionMode"
            case connectorProfileConfig = "connectorProfileConfig"
            case connectorProfileName = "connectorProfileName"
        }
    }

    public struct UpdateConnectorProfileResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "connectorProfileArn", required: false, type: .string)
        ]

        ///  The Amazon Resource Name (ARN) of the connector profile. 
        public let connectorProfileArn: String?

        public init(connectorProfileArn: String? = nil) {
            self.connectorProfileArn = connectorProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileArn = "connectorProfileArn"
        }
    }

    public struct UpdateFlowRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "description", required: false, type: .string), 
            AWSShapeMember(label: "destinationFlowConfigList", required: true, type: .list), 
            AWSShapeMember(label: "flowName", required: true, type: .string), 
            AWSShapeMember(label: "sourceFlowConfig", required: false, type: .structure), 
            AWSShapeMember(label: "tasks", required: true, type: .list), 
            AWSShapeMember(label: "triggerConfig", required: true, type: .structure)
        ]

        ///  A description of the flow. 
        public let description: String?
        ///  The configuration that controls how Amazon AppFlow transfers data to the destination connector. 
        public let destinationFlowConfigList: [DestinationFlowConfig]
        ///  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only. 
        public let flowName: String
        public let sourceFlowConfig: SourceFlowConfig?
        ///  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run. 
        public let tasks: [Task]
        ///  The trigger settings that determine how and when the flow runs. 
        public let triggerConfig: TriggerConfig

        public init(description: String? = nil, destinationFlowConfigList: [DestinationFlowConfig], flowName: String, sourceFlowConfig: SourceFlowConfig? = nil, tasks: [Task], triggerConfig: TriggerConfig) {
            self.description = description
            self.destinationFlowConfigList = destinationFlowConfigList
            self.flowName = flowName
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try validate(self.description, name:"description", parent: name, max: 2048)
            try validate(self.description, name:"description", parent: name, pattern: "[\\w!@#\\-.?,\\s]*")
            try self.destinationFlowConfigList.forEach {
                try $0.validate(name: "\(name).destinationFlowConfigList[]")
            }
            try validate(self.flowName, name:"flowName", parent: name, max: 256)
            try validate(self.flowName, name:"flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try self.sourceFlowConfig?.validate(name: "\(name).sourceFlowConfig")
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case destinationFlowConfigList = "destinationFlowConfigList"
            case flowName = "flowName"
            case sourceFlowConfig = "sourceFlowConfig"
            case tasks = "tasks"
            case triggerConfig = "triggerConfig"
        }
    }

    public struct UpdateFlowResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "flowStatus", required: false, type: .enum)
        ]

        /// Indicates the current status of the flow. 
        public let flowStatus: FlowStatus?

        public init(flowStatus: FlowStatus? = nil) {
            self.flowStatus = flowStatus
        }

        private enum CodingKeys: String, CodingKey {
            case flowStatus = "flowStatus"
        }
    }

    public struct VeevaConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "password", required: true, type: .string), 
            AWSShapeMember(label: "username", required: true, type: .string)
        ]

        ///  The password that corresponds to the user name. 
        public let password: String
        ///  The name of the user. 
        public let username: String

        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try validate(self.password, name:"password", parent: name, max: 512)
            try validate(self.password, name:"password", parent: name, pattern: ".*")
            try validate(self.username, name:"username", parent: name, max: 512)
            try validate(self.username, name:"username", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct VeevaConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the Veeva resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct VeevaMetadata: AWSShape {


        public init() {
        }

    }

    public struct VeevaSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Veeva flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }

    public struct ZendeskConnectorProfileCredentials: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessToken", required: false, type: .string), 
            AWSShapeMember(label: "clientId", required: true, type: .string), 
            AWSShapeMember(label: "clientSecret", required: true, type: .string), 
            AWSShapeMember(label: "oAuthRequest", required: false, type: .structure)
        ]

        ///  The credentials used to access protected Zendesk resources. 
        public let accessToken: String?
        ///  The identifier for the desired client. 
        public let clientId: String
        ///  The client secret used by the oauth client to authenticate to the authorization server. 
        public let clientSecret: String
        ///  The oauth requirement needed to request security tokens from the connector endpoint. 
        public let oAuthRequest: ConnectorOAuthRequest?

        public init(accessToken: String? = nil, clientId: String, clientSecret: String, oAuthRequest: ConnectorOAuthRequest? = nil) {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }

        public func validate(name: String) throws {
            try validate(self.accessToken, name:"accessToken", parent: name, max: 512)
            try validate(self.accessToken, name:"accessToken", parent: name, pattern: "\\S+")
            try validate(self.clientId, name:"clientId", parent: name, max: 512)
            try validate(self.clientId, name:"clientId", parent: name, pattern: "\\S+")
            try validate(self.clientSecret, name:"clientSecret", parent: name, max: 512)
            try validate(self.clientSecret, name:"clientSecret", parent: name, pattern: "\\S+")
            try self.oAuthRequest?.validate(name: "\(name).oAuthRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case oAuthRequest = "oAuthRequest"
        }
    }

    public struct ZendeskConnectorProfileProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "instanceUrl", required: true, type: .string)
        ]

        ///  The location of the Zendesk resource. 
        public let instanceUrl: String

        public init(instanceUrl: String) {
            self.instanceUrl = instanceUrl
        }

        public func validate(name: String) throws {
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, max: 256)
            try validate(self.instanceUrl, name:"instanceUrl", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceUrl = "instanceUrl"
        }
    }

    public struct ZendeskMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "oAuthScopes", required: false, type: .list)
        ]

        ///  The desired authorization scope for the Zendesk account. 
        public let oAuthScopes: [String]?

        public init(oAuthScopes: [String]? = nil) {
            self.oAuthScopes = oAuthScopes
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthScopes = "oAuthScopes"
        }
    }

    public struct ZendeskSourceProperties: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "object", required: true, type: .string)
        ]

        ///  The object specified in the Zendesk flow source. 
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try validate(self.object, name:"object", parent: name, max: 512)
            try validate(self.object, name:"object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "object"
        }
    }
}

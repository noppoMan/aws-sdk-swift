// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension GlobalAccelerator {

    public struct Accelerator: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: false, type: .string), 
            AWSShapeMember(label: "CreatedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "IpAddressType", required: false, type: .enum), 
            AWSShapeMember(label: "IpSets", required: false, type: .list), 
            AWSShapeMember(label: "LastModifiedTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum)
        ]

        /// The Amazon Resource Name (ARN) of the accelerator.
        public let acceleratorArn: String?
        /// The date and time that the accelerator was created.
        public let createdTime: TimeStamp?
        /// Indicates whether the accelerator is enabled. The value is true or false. The default value is true.  If the value is set to true, the accelerator cannot be deleted. If set to false, accelerator can be deleted.
        public let enabled: Bool?
        /// The value for the address type must be IPv4. 
        public let ipAddressType: IpAddressType?
        /// The static IP addresses that Global Accelerator associates with the accelerator.
        public let ipSets: [IpSet]?
        /// The date and time that the accelerator was last modified.
        public let lastModifiedTime: TimeStamp?
        /// The name of the accelerator. The name must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public let name: String?
        /// Describes the deployment status of the accelerator.
        public let status: AcceleratorStatus?

        public init(acceleratorArn: String? = nil, createdTime: TimeStamp? = nil, enabled: Bool? = nil, ipAddressType: IpAddressType? = nil, ipSets: [IpSet]? = nil, lastModifiedTime: TimeStamp? = nil, name: String? = nil, status: AcceleratorStatus? = nil) {
            self.acceleratorArn = acceleratorArn
            self.createdTime = createdTime
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.ipSets = ipSets
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case createdTime = "CreatedTime"
            case enabled = "Enabled"
            case ipAddressType = "IpAddressType"
            case ipSets = "IpSets"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct AcceleratorAttributes: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FlowLogsEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FlowLogsS3Bucket", required: false, type: .string), 
            AWSShapeMember(label: "FlowLogsS3Prefix", required: false, type: .string)
        ]

        /// Indicates whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see Flow Logs in the AWS Global Accelerator Developer Guide.
        public let flowLogsEnabled: Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the bucket.
        public let flowLogsS3Bucket: String?
        /// The prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you don’t specify a prefix, the flow logs are stored in the root of the bucket.
        public let flowLogsS3Prefix: String?

        public init(flowLogsEnabled: Bool? = nil, flowLogsS3Bucket: String? = nil, flowLogsS3Prefix: String? = nil) {
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }

        private enum CodingKeys: String, CodingKey {
            case flowLogsEnabled = "FlowLogsEnabled"
            case flowLogsS3Bucket = "FlowLogsS3Bucket"
            case flowLogsS3Prefix = "FlowLogsS3Prefix"
        }
    }

    public enum AcceleratorStatus: String, CustomStringConvertible, Codable {
        case deployed = "DEPLOYED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ClientAffinity: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case sourceIp = "SOURCE_IP"
        public var description: String { return self.rawValue }
    }

    public struct CreateAcceleratorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "IdempotencyToken", required: true, type: .string), 
            AWSShapeMember(label: "IpAddressType", required: false, type: .enum), 
            AWSShapeMember(label: "Name", required: true, type: .string)
        ]

        /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true.  If the value is set to true, an accelerator cannot be deleted. If set to false, the accelerator can be deleted.
        public let enabled: Bool?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of an accelerator.
        public let idempotencyToken: String
        /// The value for the address type must be IPv4. 
        public let ipAddressType: IpAddressType?
        /// The name of an accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public let name: String

        public init(enabled: Bool? = nil, idempotencyToken: String, ipAddressType: IpAddressType? = nil, name: String) {
            self.enabled = enabled
            self.idempotencyToken = idempotencyToken
            self.ipAddressType = ipAddressType
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.idempotencyToken, name:"idempotencyToken", parent: name, max: 255)
            try validate(self.name, name:"name", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case idempotencyToken = "IdempotencyToken"
            case ipAddressType = "IpAddressType"
            case name = "Name"
        }
    }

    public struct CreateAcceleratorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Accelerator", required: false, type: .structure)
        ]

        /// The accelerator that is created by specifying a listener and the supported IP address types.
        public let accelerator: Accelerator?

        public init(accelerator: Accelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct CreateEndpointGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointConfigurations", required: false, type: .list), 
            AWSShapeMember(label: "EndpointGroupRegion", required: true, type: .string), 
            AWSShapeMember(label: "HealthCheckIntervalSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "HealthCheckPath", required: false, type: .string), 
            AWSShapeMember(label: "HealthCheckPort", required: false, type: .integer), 
            AWSShapeMember(label: "HealthCheckProtocol", required: false, type: .enum), 
            AWSShapeMember(label: "IdempotencyToken", required: true, type: .string), 
            AWSShapeMember(label: "ListenerArn", required: true, type: .string), 
            AWSShapeMember(label: "ThresholdCount", required: false, type: .integer), 
            AWSShapeMember(label: "TrafficDialPercentage", required: false, type: .float)
        ]

        /// The list of endpoint objects.
        public let endpointConfigurations: [EndpointConfiguration]?
        /// The name of the AWS Region where the endpoint group is located. A listener can have only one endpoint group in a specific Region.
        public let endpointGroupRegion: String
        /// The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
        public let healthCheckIntervalSeconds: Int?
        /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
        public let healthCheckPath: String?
        /// The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If listener port is a list of ports, Global Accelerator uses the first port in the list.
        public let healthCheckPort: Int?
        /// The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
        public let healthCheckProtocol: HealthCheckProtocol?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
        public let idempotencyToken: String
        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
        public let thresholdCount: Int?
        /// The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for this listener.  Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
        public let trafficDialPercentage: Float?

        public init(endpointConfigurations: [EndpointConfiguration]? = nil, endpointGroupRegion: String, healthCheckIntervalSeconds: Int? = nil, healthCheckPath: String? = nil, healthCheckPort: Int? = nil, healthCheckProtocol: HealthCheckProtocol? = nil, idempotencyToken: String, listenerArn: String, thresholdCount: Int? = nil, trafficDialPercentage: Float? = nil) {
            self.endpointConfigurations = endpointConfigurations
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.idempotencyToken = idempotencyToken
            self.listenerArn = listenerArn
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }

        public func validate(name: String) throws {
            try self.endpointConfigurations?.forEach {
                try $0.validate(name: "\(name).endpointConfigurations[]")
            }
            try validate(self.endpointConfigurations, name:"endpointConfigurations", parent: name, max: 10)
            try validate(self.endpointConfigurations, name:"endpointConfigurations", parent: name, min: 0)
            try validate(self.endpointGroupRegion, name:"endpointGroupRegion", parent: name, max: 255)
            try validate(self.healthCheckIntervalSeconds, name:"healthCheckIntervalSeconds", parent: name, max: 30)
            try validate(self.healthCheckIntervalSeconds, name:"healthCheckIntervalSeconds", parent: name, min: 10)
            try validate(self.healthCheckPath, name:"healthCheckPath", parent: name, max: 255)
            try validate(self.healthCheckPort, name:"healthCheckPort", parent: name, max: 65535)
            try validate(self.healthCheckPort, name:"healthCheckPort", parent: name, min: 1)
            try validate(self.idempotencyToken, name:"idempotencyToken", parent: name, max: 255)
            try validate(self.listenerArn, name:"listenerArn", parent: name, max: 255)
            try validate(self.thresholdCount, name:"thresholdCount", parent: name, max: 10)
            try validate(self.thresholdCount, name:"thresholdCount", parent: name, min: 1)
            try validate(self.trafficDialPercentage, name:"trafficDialPercentage", parent: name, max: 100)
            try validate(self.trafficDialPercentage, name:"trafficDialPercentage", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigurations = "EndpointConfigurations"
            case endpointGroupRegion = "EndpointGroupRegion"
            case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
            case healthCheckPath = "HealthCheckPath"
            case healthCheckPort = "HealthCheckPort"
            case healthCheckProtocol = "HealthCheckProtocol"
            case idempotencyToken = "IdempotencyToken"
            case listenerArn = "ListenerArn"
            case thresholdCount = "ThresholdCount"
            case trafficDialPercentage = "TrafficDialPercentage"
        }
    }

    public struct CreateEndpointGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointGroup", required: false, type: .structure)
        ]

        /// The information about the endpoint group that was created.
        public let endpointGroup: EndpointGroup?

        public init(endpointGroup: EndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct CreateListenerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: true, type: .string), 
            AWSShapeMember(label: "ClientAffinity", required: false, type: .enum), 
            AWSShapeMember(label: "IdempotencyToken", required: true, type: .string), 
            AWSShapeMember(label: "PortRanges", required: true, type: .list), 
            AWSShapeMember(label: "Protocol", required: true, type: .enum)
        ]

        /// The Amazon Resource Name (ARN) of your accelerator.
        public let acceleratorArn: String
        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Clienty affinity gives you control over whether to always route each client to the same specific endpoint. AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes.  If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
        public let clientAffinity: ClientAffinity?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency—that is, the uniqueness—of the request.
        public let idempotencyToken: String
        /// The list of port ranges to support for connections from clients to your accelerator.
        public let portRanges: [PortRange]
        /// The protocol for connections from clients to your accelerator.
        public let `protocol`: Protocol

        public init(acceleratorArn: String, clientAffinity: ClientAffinity? = nil, idempotencyToken: String, portRanges: [PortRange], protocol: Protocol) {
            self.acceleratorArn = acceleratorArn
            self.clientAffinity = clientAffinity
            self.idempotencyToken = idempotencyToken
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.acceleratorArn, name:"acceleratorArn", parent: name, max: 255)
            try validate(self.idempotencyToken, name:"idempotencyToken", parent: name, max: 255)
            try self.portRanges.forEach {
                try $0.validate(name: "\(name).portRanges[]")
            }
            try validate(self.portRanges, name:"portRanges", parent: name, max: 10)
            try validate(self.portRanges, name:"portRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case clientAffinity = "ClientAffinity"
            case idempotencyToken = "IdempotencyToken"
            case portRanges = "PortRanges"
            case `protocol` = "Protocol"
        }
    }

    public struct CreateListenerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Listener", required: false, type: .structure)
        ]

        /// The listener that you've created.
        public let listener: Listener?

        public init(listener: Listener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct DeleteAcceleratorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of an accelerator.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try validate(self.acceleratorArn, name:"acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DeleteEndpointGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointGroupArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the endpoint group to delete.
        public let endpointGroupArn: String

        public init(endpointGroupArn: String) {
            self.endpointGroupArn = endpointGroupArn
        }

        public func validate(name: String) throws {
            try validate(self.endpointGroupArn, name:"endpointGroupArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct DeleteListenerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ListenerArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String

        public init(listenerArn: String) {
            self.listenerArn = listenerArn
        }

        public func validate(name: String) throws {
            try validate(self.listenerArn, name:"listenerArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
        }
    }

    public struct DescribeAcceleratorAttributesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the accelerator with the attributes that you want to describe.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try validate(self.acceleratorArn, name:"acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DescribeAcceleratorAttributesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorAttributes", required: false, type: .structure)
        ]

        /// The attributes of the accelerator.
        public let acceleratorAttributes: AcceleratorAttributes?

        public init(acceleratorAttributes: AcceleratorAttributes? = nil) {
            self.acceleratorAttributes = acceleratorAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorAttributes = "AcceleratorAttributes"
        }
    }

    public struct DescribeAcceleratorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the accelerator to describe.
        public let acceleratorArn: String

        public init(acceleratorArn: String) {
            self.acceleratorArn = acceleratorArn
        }

        public func validate(name: String) throws {
            try validate(self.acceleratorArn, name:"acceleratorArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
        }
    }

    public struct DescribeAcceleratorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Accelerator", required: false, type: .structure)
        ]

        /// The description of the accelerator.
        public let accelerator: Accelerator?

        public init(accelerator: Accelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct DescribeEndpointGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointGroupArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the endpoint group to describe.
        public let endpointGroupArn: String

        public init(endpointGroupArn: String) {
            self.endpointGroupArn = endpointGroupArn
        }

        public func validate(name: String) throws {
            try validate(self.endpointGroupArn, name:"endpointGroupArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroupArn = "EndpointGroupArn"
        }
    }

    public struct DescribeEndpointGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointGroup", required: false, type: .structure)
        ]

        /// The description of an endpoint group.
        public let endpointGroup: EndpointGroup?

        public init(endpointGroup: EndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct DescribeListenerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ListenerArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the listener to describe.
        public let listenerArn: String

        public init(listenerArn: String) {
            self.listenerArn = listenerArn
        }

        public func validate(name: String) throws {
            try validate(self.listenerArn, name:"listenerArn", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
        }
    }

    public struct DescribeListenerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Listener", required: false, type: .structure)
        ]

        /// The description of a listener.
        public let listener: Listener?

        public init(listener: Listener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }

    public struct EndpointConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientIPPreservationEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "EndpointId", required: false, type: .string), 
            AWSShapeMember(label: "Weight", required: false, type: .integer)
        ]

        /// Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint. The value is true or false. The default value is true for new accelerators.  If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator. For more information, see  Viewing Client IP Addresses in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let clientIPPreservationEnabled: Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID.
        public let endpointId: String?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see Endpoint Weights in the AWS Global Accelerator Developer Guide.
        public let weight: Int?

        public init(clientIPPreservationEnabled: Bool? = nil, endpointId: String? = nil, weight: Int? = nil) {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.weight = weight
        }

        public func validate(name: String) throws {
            try validate(self.endpointId, name:"endpointId", parent: name, max: 255)
            try validate(self.weight, name:"weight", parent: name, max: 255)
            try validate(self.weight, name:"weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
            case endpointId = "EndpointId"
            case weight = "Weight"
        }
    }

    public struct EndpointDescription: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientIPPreservationEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "EndpointId", required: false, type: .string), 
            AWSShapeMember(label: "HealthReason", required: false, type: .string), 
            AWSShapeMember(label: "HealthState", required: false, type: .enum), 
            AWSShapeMember(label: "Weight", required: false, type: .integer)
        ]

        /// Indicates whether client IP address preservation is enabled for an Application Load Balancer endpoint. The value is true or false. The default value is true for new accelerators.  If the value is set to true, the client's IP address is preserved in the X-Forwarded-For request header as traffic travels to applications on the Application Load Balancer endpoint fronted by the accelerator. For more information, see  Viewing Client IP Addresses in AWS Global Accelerator in the AWS Global Accelerator Developer Guide.
        public let clientIPPreservationEnabled: Bool?
        /// An ID for the endpoint. If the endpoint is a Network Load Balancer or Application Load Balancer, this is the Amazon Resource Name (ARN) of the resource. If the endpoint is an Elastic IP address, this is the Elastic IP address allocation ID. An Application Load Balancer can be either internal or internet-facing.
        public let endpointId: String?
        /// The reason code associated with why the endpoint is not healthy. If the endpoint state is healthy, a reason code is not provided. If the endpoint state is unhealthy, the reason code can be one of the following values:    Timeout: The health check requests to the endpoint are timing out before returning a status.    Failed: The health check failed, for example because the endpoint response was invalid (malformed).   If the endpoint state is initial, the reason code can be one of the following values:    ProvisioningInProgress: The endpoint is in the process of being provisioned.    InitialHealthChecking: Global Accelerator is still setting up the minimum number of health checks for the endpoint that are required to determine its health status.  
        public let healthReason: String?
        /// The health status of the endpoint.
        public let healthState: HealthState?
        /// The weight associated with the endpoint. When you add weights to endpoints, you configure AWS Global Accelerator to route traffic based on proportions that you specify. For example, you might specify endpoint weights of 4, 5, 5, and 6 (sum=20). The result is that 4/20 of your traffic, on average, is routed to the first endpoint, 5/20 is routed both to the second and third endpoints, and 6/20 is routed to the last endpoint. For more information, see Endpoint Weights in the AWS Global Accelerator Developer Guide. 
        public let weight: Int?

        public init(clientIPPreservationEnabled: Bool? = nil, endpointId: String? = nil, healthReason: String? = nil, healthState: HealthState? = nil, weight: Int? = nil) {
            self.clientIPPreservationEnabled = clientIPPreservationEnabled
            self.endpointId = endpointId
            self.healthReason = healthReason
            self.healthState = healthState
            self.weight = weight
        }

        private enum CodingKeys: String, CodingKey {
            case clientIPPreservationEnabled = "ClientIPPreservationEnabled"
            case endpointId = "EndpointId"
            case healthReason = "HealthReason"
            case healthState = "HealthState"
            case weight = "Weight"
        }
    }

    public struct EndpointGroup: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointDescriptions", required: false, type: .list), 
            AWSShapeMember(label: "EndpointGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "EndpointGroupRegion", required: false, type: .string), 
            AWSShapeMember(label: "HealthCheckIntervalSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "HealthCheckPath", required: false, type: .string), 
            AWSShapeMember(label: "HealthCheckPort", required: false, type: .integer), 
            AWSShapeMember(label: "HealthCheckProtocol", required: false, type: .enum), 
            AWSShapeMember(label: "ThresholdCount", required: false, type: .integer), 
            AWSShapeMember(label: "TrafficDialPercentage", required: false, type: .float)
        ]

        /// The list of endpoint objects.
        public let endpointDescriptions: [EndpointDescription]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String?
        /// The AWS Region that this endpoint group belongs.
        public let endpointGroupRegion: String?
        /// The time—10 seconds or 30 seconds—between health checks for each endpoint. The default value is 30.
        public let healthCheckIntervalSeconds: Int?
        /// If the protocol is HTTP/S, then this value provides the ping path that Global Accelerator uses for the destination on the endpoints for health checks. The default is slash (/).
        public let healthCheckPath: String?
        /// The port that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group.  The default port is the port for the listener that this endpoint group is associated with. If the listener port is a list, Global Accelerator uses the first specified port in the list of ports.
        public let healthCheckPort: Int?
        /// The protocol that Global Accelerator uses to perform health checks on endpoints that are part of this endpoint group. The default value is TCP.
        public let healthCheckProtocol: HealthCheckProtocol?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
        public let thresholdCount: Int?
        /// The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for this listener.  Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
        public let trafficDialPercentage: Float?

        public init(endpointDescriptions: [EndpointDescription]? = nil, endpointGroupArn: String? = nil, endpointGroupRegion: String? = nil, healthCheckIntervalSeconds: Int? = nil, healthCheckPath: String? = nil, healthCheckPort: Int? = nil, healthCheckProtocol: HealthCheckProtocol? = nil, thresholdCount: Int? = nil, trafficDialPercentage: Float? = nil) {
            self.endpointDescriptions = endpointDescriptions
            self.endpointGroupArn = endpointGroupArn
            self.endpointGroupRegion = endpointGroupRegion
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }

        private enum CodingKeys: String, CodingKey {
            case endpointDescriptions = "EndpointDescriptions"
            case endpointGroupArn = "EndpointGroupArn"
            case endpointGroupRegion = "EndpointGroupRegion"
            case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
            case healthCheckPath = "HealthCheckPath"
            case healthCheckPort = "HealthCheckPort"
            case healthCheckProtocol = "HealthCheckProtocol"
            case thresholdCount = "ThresholdCount"
            case trafficDialPercentage = "TrafficDialPercentage"
        }
    }

    public enum HealthCheckProtocol: String, CustomStringConvertible, Codable {
        case tcp = "TCP"
        case http = "HTTP"
        case https = "HTTPS"
        public var description: String { return self.rawValue }
    }

    public enum HealthState: String, CustomStringConvertible, Codable {
        case initial = "INITIAL"
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum IpAddressType: String, CustomStringConvertible, Codable {
        case ipv4 = "IPV4"
        public var description: String { return self.rawValue }
    }

    public struct IpSet: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "IpAddresses", required: false, type: .list), 
            AWSShapeMember(label: "IpFamily", required: false, type: .string)
        ]

        /// The array of IP addresses in the IP address set. An IP address set can have a maximum of two IP addresses.
        public let ipAddresses: [String]?
        /// The types of IP addresses included in this IP set.
        public let ipFamily: String?

        public init(ipAddresses: [String]? = nil, ipFamily: String? = nil) {
            self.ipAddresses = ipAddresses
            self.ipFamily = ipFamily
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddresses = "IpAddresses"
            case ipFamily = "IpFamily"
        }
    }

    public struct ListAcceleratorsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The number of Global Accelerator objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAcceleratorsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Accelerators", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The list of accelerators for a customer account.
        public let accelerators: [Accelerator]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(accelerators: [Accelerator]? = nil, nextToken: String? = nil) {
            self.accelerators = accelerators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accelerators = "Accelerators"
            case nextToken = "NextToken"
        }
    }

    public struct ListEndpointGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ListenerArn", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String
        /// The number of endpoint group objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(listenerArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.listenerArn = listenerArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.listenerArn, name:"listenerArn", parent: name, max: 255)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case listenerArn = "ListenerArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListEndpointGroupsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointGroups", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The list of the endpoint groups associated with a listener.
        public let endpointGroups: [EndpointGroup]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(endpointGroups: [EndpointGroup]? = nil, nextToken: String? = nil) {
            self.endpointGroups = endpointGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroups = "EndpointGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListListenersRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: true, type: .string), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the accelerator for which you want to list listener objects.
        public let acceleratorArn: String
        /// The number of listener objects that you want to return with this call. The default value is 10.
        public let maxResults: Int?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(acceleratorArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.acceleratorArn, name:"acceleratorArn", parent: name, max: 255)
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListListenersResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Listeners", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The list of listeners for an accelerator.
        public let listeners: [Listener]?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(listeners: [Listener]? = nil, nextToken: String? = nil) {
            self.listeners = listeners
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "Listeners"
            case nextToken = "NextToken"
        }
    }

    public struct Listener: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientAffinity", required: false, type: .enum), 
            AWSShapeMember(label: "ListenerArn", required: false, type: .string), 
            AWSShapeMember(label: "PortRanges", required: false, type: .list), 
            AWSShapeMember(label: "Protocol", required: false, type: .enum)
        ]

        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Clienty affinity gives you control over whether to always route each client to the same specific endpoint. AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes.  If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
        public let clientAffinity: ClientAffinity?
        /// The Amazon Resource Name (ARN) of the listener.
        public let listenerArn: String?
        /// The list of port ranges for the connections from clients to the accelerator.
        public let portRanges: [PortRange]?
        /// The protocol for the connections from clients to the accelerator.
        public let `protocol`: Protocol?

        public init(clientAffinity: ClientAffinity? = nil, listenerArn: String? = nil, portRanges: [PortRange]? = nil, protocol: Protocol? = nil) {
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case clientAffinity = "ClientAffinity"
            case listenerArn = "ListenerArn"
            case portRanges = "PortRanges"
            case `protocol` = "Protocol"
        }
    }

    public struct PortRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FromPort", required: false, type: .integer), 
            AWSShapeMember(label: "ToPort", required: false, type: .integer)
        ]

        /// The first port in the range of ports, inclusive.
        public let fromPort: Int?
        /// The last port in the range of ports, inclusive.
        public let toPort: Int?

        public init(fromPort: Int? = nil, toPort: Int? = nil) {
            self.fromPort = fromPort
            self.toPort = toPort
        }

        public func validate(name: String) throws {
            try validate(self.fromPort, name:"fromPort", parent: name, max: 65535)
            try validate(self.fromPort, name:"fromPort", parent: name, min: 1)
            try validate(self.toPort, name:"toPort", parent: name, max: 65535)
            try validate(self.toPort, name:"toPort", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fromPort = "FromPort"
            case toPort = "ToPort"
        }
    }

    public enum `Protocol`: String, CustomStringConvertible, Codable {
        case tcp = "TCP"
        case udp = "UDP"
        public var description: String { return self.rawValue }
    }

    public struct UpdateAcceleratorAttributesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: true, type: .string), 
            AWSShapeMember(label: "FlowLogsEnabled", required: false, type: .boolean), 
            AWSShapeMember(label: "FlowLogsS3Bucket", required: false, type: .string), 
            AWSShapeMember(label: "FlowLogsS3Prefix", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the accelerator that you want to update.
        public let acceleratorArn: String
        /// Update whether flow logs are enabled. The default value is false. If the value is true, FlowLogsS3Bucket and FlowLogsS3Prefix must be specified. For more information, see Flow Logs in the AWS Global Accelerator Developer Guide.
        public let flowLogsEnabled: Bool?
        /// The name of the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. The bucket must exist and have a bucket policy that grants AWS Global Accelerator permission to write to the bucket.
        public let flowLogsS3Bucket: String?
        /// Update the prefix for the location in the Amazon S3 bucket for the flow logs. Attribute is required if FlowLogsEnabled is true. If you don’t specify a prefix, the flow logs are stored in the root of the bucket.
        public let flowLogsS3Prefix: String?

        public init(acceleratorArn: String, flowLogsEnabled: Bool? = nil, flowLogsS3Bucket: String? = nil, flowLogsS3Prefix: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.flowLogsEnabled = flowLogsEnabled
            self.flowLogsS3Bucket = flowLogsS3Bucket
            self.flowLogsS3Prefix = flowLogsS3Prefix
        }

        public func validate(name: String) throws {
            try validate(self.acceleratorArn, name:"acceleratorArn", parent: name, max: 255)
            try validate(self.flowLogsS3Bucket, name:"flowLogsS3Bucket", parent: name, max: 255)
            try validate(self.flowLogsS3Prefix, name:"flowLogsS3Prefix", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case flowLogsEnabled = "FlowLogsEnabled"
            case flowLogsS3Bucket = "FlowLogsS3Bucket"
            case flowLogsS3Prefix = "FlowLogsS3Prefix"
        }
    }

    public struct UpdateAcceleratorAttributesResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorAttributes", required: false, type: .structure)
        ]

        /// Updated attributes for the accelerator.
        public let acceleratorAttributes: AcceleratorAttributes?

        public init(acceleratorAttributes: AcceleratorAttributes? = nil) {
            self.acceleratorAttributes = acceleratorAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorAttributes = "AcceleratorAttributes"
        }
    }

    public struct UpdateAcceleratorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AcceleratorArn", required: true, type: .string), 
            AWSShapeMember(label: "Enabled", required: false, type: .boolean), 
            AWSShapeMember(label: "IpAddressType", required: false, type: .enum), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the accelerator to update.
        public let acceleratorArn: String
        /// Indicates whether an accelerator is enabled. The value is true or false. The default value is true.  If the value is set to true, the accelerator cannot be deleted. If set to false, the accelerator can be deleted.
        public let enabled: Bool?
        /// The value for the address type must be IPv4. 
        public let ipAddressType: IpAddressType?
        /// The name of the accelerator. The name can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens (-), and must not begin or end with a hyphen.
        public let name: String?

        public init(acceleratorArn: String, enabled: Bool? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil) {
            self.acceleratorArn = acceleratorArn
            self.enabled = enabled
            self.ipAddressType = ipAddressType
            self.name = name
        }

        public func validate(name: String) throws {
            try validate(self.acceleratorArn, name:"acceleratorArn", parent: name, max: 255)
            try validate(self.name, name:"name", parent: name, max: 255)
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorArn = "AcceleratorArn"
            case enabled = "Enabled"
            case ipAddressType = "IpAddressType"
            case name = "Name"
        }
    }

    public struct UpdateAcceleratorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Accelerator", required: false, type: .structure)
        ]

        /// Information about the updated accelerator.
        public let accelerator: Accelerator?

        public init(accelerator: Accelerator? = nil) {
            self.accelerator = accelerator
        }

        private enum CodingKeys: String, CodingKey {
            case accelerator = "Accelerator"
        }
    }

    public struct UpdateEndpointGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointConfigurations", required: false, type: .list), 
            AWSShapeMember(label: "EndpointGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "HealthCheckIntervalSeconds", required: false, type: .integer), 
            AWSShapeMember(label: "HealthCheckPath", required: false, type: .string), 
            AWSShapeMember(label: "HealthCheckPort", required: false, type: .integer), 
            AWSShapeMember(label: "HealthCheckProtocol", required: false, type: .enum), 
            AWSShapeMember(label: "ThresholdCount", required: false, type: .integer), 
            AWSShapeMember(label: "TrafficDialPercentage", required: false, type: .float)
        ]

        /// The list of endpoint objects.
        public let endpointConfigurations: [EndpointConfiguration]?
        /// The Amazon Resource Name (ARN) of the endpoint group.
        public let endpointGroupArn: String
        /// The time—10 seconds or 30 seconds—between each health check for an endpoint. The default value is 30.
        public let healthCheckIntervalSeconds: Int?
        /// If the protocol is HTTP/S, then this specifies the path that is the destination for health check targets. The default value is slash (/).
        public let healthCheckPath: String?
        /// The port that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default port is the listener port that this endpoint group is associated with. If the listener port is a list of ports, Global Accelerator uses the first port in the list.
        public let healthCheckPort: Int?
        /// The protocol that AWS Global Accelerator uses to check the health of endpoints that are part of this endpoint group. The default value is TCP.
        public let healthCheckProtocol: HealthCheckProtocol?
        /// The number of consecutive health checks required to set the state of a healthy endpoint to unhealthy, or to set an unhealthy endpoint to healthy. The default value is 3.
        public let thresholdCount: Int?
        /// The percentage of traffic to send to an AWS Region. Additional traffic is distributed to other endpoint groups for this listener.  Use this action to increase (dial up) or decrease (dial down) traffic to a specific Region. The percentage is applied to the traffic that would otherwise have been routed to the Region based on optimal routing. The default value is 100.
        public let trafficDialPercentage: Float?

        public init(endpointConfigurations: [EndpointConfiguration]? = nil, endpointGroupArn: String, healthCheckIntervalSeconds: Int? = nil, healthCheckPath: String? = nil, healthCheckPort: Int? = nil, healthCheckProtocol: HealthCheckProtocol? = nil, thresholdCount: Int? = nil, trafficDialPercentage: Float? = nil) {
            self.endpointConfigurations = endpointConfigurations
            self.endpointGroupArn = endpointGroupArn
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.thresholdCount = thresholdCount
            self.trafficDialPercentage = trafficDialPercentage
        }

        public func validate(name: String) throws {
            try self.endpointConfigurations?.forEach {
                try $0.validate(name: "\(name).endpointConfigurations[]")
            }
            try validate(self.endpointConfigurations, name:"endpointConfigurations", parent: name, max: 10)
            try validate(self.endpointConfigurations, name:"endpointConfigurations", parent: name, min: 0)
            try validate(self.endpointGroupArn, name:"endpointGroupArn", parent: name, max: 255)
            try validate(self.healthCheckIntervalSeconds, name:"healthCheckIntervalSeconds", parent: name, max: 30)
            try validate(self.healthCheckIntervalSeconds, name:"healthCheckIntervalSeconds", parent: name, min: 10)
            try validate(self.healthCheckPath, name:"healthCheckPath", parent: name, max: 255)
            try validate(self.healthCheckPort, name:"healthCheckPort", parent: name, max: 65535)
            try validate(self.healthCheckPort, name:"healthCheckPort", parent: name, min: 1)
            try validate(self.thresholdCount, name:"thresholdCount", parent: name, max: 10)
            try validate(self.thresholdCount, name:"thresholdCount", parent: name, min: 1)
            try validate(self.trafficDialPercentage, name:"trafficDialPercentage", parent: name, max: 100)
            try validate(self.trafficDialPercentage, name:"trafficDialPercentage", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointConfigurations = "EndpointConfigurations"
            case endpointGroupArn = "EndpointGroupArn"
            case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
            case healthCheckPath = "HealthCheckPath"
            case healthCheckPort = "HealthCheckPort"
            case healthCheckProtocol = "HealthCheckProtocol"
            case thresholdCount = "ThresholdCount"
            case trafficDialPercentage = "TrafficDialPercentage"
        }
    }

    public struct UpdateEndpointGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndpointGroup", required: false, type: .structure)
        ]

        /// The information about the endpoint group that was updated.
        public let endpointGroup: EndpointGroup?

        public init(endpointGroup: EndpointGroup? = nil) {
            self.endpointGroup = endpointGroup
        }

        private enum CodingKeys: String, CodingKey {
            case endpointGroup = "EndpointGroup"
        }
    }

    public struct UpdateListenerRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientAffinity", required: false, type: .enum), 
            AWSShapeMember(label: "ListenerArn", required: true, type: .string), 
            AWSShapeMember(label: "PortRanges", required: false, type: .list), 
            AWSShapeMember(label: "Protocol", required: false, type: .enum)
        ]

        /// Client affinity lets you direct all requests from a user to the same endpoint, if you have stateful applications, regardless of the port and protocol of the client request. Clienty affinity gives you control over whether to always route each client to the same specific endpoint. AWS Global Accelerator uses a consistent-flow hashing algorithm to choose the optimal endpoint for a connection. If client affinity is NONE, Global Accelerator uses the "five-tuple" (5-tuple) properties—source IP address, source port, destination IP address, destination port, and protocol—to select the hash value, and then chooses the best endpoint. However, with this setting, if someone uses different ports to connect to Global Accelerator, their connections might not be always routed to the same endpoint because the hash value changes.  If you want a given client to always be routed to the same endpoint, set client affinity to SOURCE_IP instead. When you use the SOURCE_IP setting, Global Accelerator uses the "two-tuple" (2-tuple) properties— source (client) IP address and destination IP address—to select the hash value. The default value is NONE.
        public let clientAffinity: ClientAffinity?
        /// The Amazon Resource Name (ARN) of the listener to update.
        public let listenerArn: String
        /// The updated list of port ranges for the connections from clients to the accelerator.
        public let portRanges: [PortRange]?
        /// The updated protocol for the connections from clients to the accelerator.
        public let `protocol`: Protocol?

        public init(clientAffinity: ClientAffinity? = nil, listenerArn: String, portRanges: [PortRange]? = nil, protocol: Protocol? = nil) {
            self.clientAffinity = clientAffinity
            self.listenerArn = listenerArn
            self.portRanges = portRanges
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.listenerArn, name:"listenerArn", parent: name, max: 255)
            try self.portRanges?.forEach {
                try $0.validate(name: "\(name).portRanges[]")
            }
            try validate(self.portRanges, name:"portRanges", parent: name, max: 10)
            try validate(self.portRanges, name:"portRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientAffinity = "ClientAffinity"
            case listenerArn = "ListenerArn"
            case portRanges = "PortRanges"
            case `protocol` = "Protocol"
        }
    }

    public struct UpdateListenerResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Listener", required: false, type: .structure)
        ]

        /// Information for the updated listener.
        public let listener: Listener?

        public init(listener: Listener? = nil) {
            self.listener = listener
        }

        private enum CodingKeys: String, CodingKey {
            case listener = "Listener"
        }
    }
}

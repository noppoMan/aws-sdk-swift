// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension ForecastService {

    public enum AttributeType: String, CustomStringConvertible, Codable {
        case string = "string"
        case integer = "integer"
        case float = "float"
        case timestamp = "timestamp"
        public var description: String { return self.rawValue }
    }

    public struct CategoricalParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Values", required: true, type: .list)
        ]

        /// The name of the categorical hyperparameter to tune.
        public let name: String
        /// A list of the tunable categories for the hyperparameter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
            }
            try validate(self.values, name:"values", parent: name, max: 20)
            try validate(self.values, name:"values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ContinuousParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxValue", required: true, type: .double), 
            AWSShapeMember(label: "MinValue", required: true, type: .double), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "ScalingType", required: false, type: .enum)
        ]

        /// The maximum tunable value of the hyperparameter.
        public let maxValue: Double
        /// The minimum tunable value of the hyperparameter.
        public let minValue: Double
        /// The name of the hyperparameter to tune.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:  Auto  Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have only values greater than 0.  ReverseLogarithmic  Hyperparemeter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.  
        public let scalingType: ScalingType?

        public init(maxValue: Double, minValue: Double, name: String, scalingType: ScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct CreateDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetArns", required: false, type: .list), 
            AWSShapeMember(label: "DatasetGroupName", required: true, type: .string), 
            AWSShapeMember(label: "Domain", required: true, type: .enum)
        ]

        /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset group.
        public let datasetArns: [String]?
        /// A name for the dataset group.
        public let datasetGroupName: String
        /// The domain associated with the dataset group. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see howitworks-datasets-groups.
        public let domain: Domain

        public init(datasetArns: [String]? = nil, datasetGroupName: String, domain: Domain) {
            self.datasetArns = datasetArns
            self.datasetGroupName = datasetGroupName
            self.domain = domain
        }

        public func validate(name: String) throws {
            try self.datasetArns?.forEach {
                try validate($0, name: "datasetArns[]", parent: name, max: 256)
                try validate($0, name: "datasetArns[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            }
            try validate(self.datasetGroupName, name:"datasetGroupName", parent: name, max: 63)
            try validate(self.datasetGroupName, name:"datasetGroupName", parent: name, min: 1)
            try validate(self.datasetGroupName, name:"datasetGroupName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArns = "DatasetArns"
            case datasetGroupName = "DatasetGroupName"
            case domain = "Domain"
        }
    }

    public struct CreateDatasetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetGroupArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?

        public init(datasetGroupArn: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct CreateDatasetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetArn", required: true, type: .string), 
            AWSShapeMember(label: "DatasetImportJobName", required: true, type: .string), 
            AWSShapeMember(label: "DataSource", required: true, type: .structure), 
            AWSShapeMember(label: "TimestampFormat", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data to.
        public let datasetArn: String
        /// The name for the dataset import job. It is recommended to include the current timestamp in the name to guard against getting a ResourceAlreadyExistsException exception, for example, 20190721DatasetImport.
        public let datasetImportJobName: String
        /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data.
        public let dataSource: DataSource
        /// The format of timestamps in the dataset. Two formats are supported, dependent on the DataFrequency specified when the dataset was created.   "yyyy-MM-dd" For data frequencies: Y, M, W, and D   "yyyy-MM-dd HH:mm:ss" For data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D  
        public let timestampFormat: String?

        public init(datasetArn: String, datasetImportJobName: String, dataSource: DataSource, timestampFormat: String? = nil) {
            self.datasetArn = datasetArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSource = dataSource
            self.timestampFormat = timestampFormat
        }

        public func validate(name: String) throws {
            try validate(self.datasetArn, name:"datasetArn", parent: name, max: 256)
            try validate(self.datasetArn, name:"datasetArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try validate(self.datasetImportJobName, name:"datasetImportJobName", parent: name, max: 63)
            try validate(self.datasetImportJobName, name:"datasetImportJobName", parent: name, min: 1)
            try validate(self.datasetImportJobName, name:"datasetImportJobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            try self.dataSource.validate(name: "\(name).dataSource")
            try validate(self.timestampFormat, name:"timestampFormat", parent: name, max: 256)
            try validate(self.timestampFormat, name:"timestampFormat", parent: name, pattern: "^[a-zA-Z0-9\\-\\:\\.\\,\\'\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSource = "DataSource"
            case timestampFormat = "TimestampFormat"
        }
    }

    public struct CreateDatasetImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetImportJobArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?

        public init(datasetImportJobArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct CreateDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DataFrequency", required: false, type: .string), 
            AWSShapeMember(label: "DatasetName", required: true, type: .string), 
            AWSShapeMember(label: "DatasetType", required: true, type: .enum), 
            AWSShapeMember(label: "Domain", required: true, type: .enum), 
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "Schema", required: true, type: .structure)
        ]

        /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "D" indicates every day and "15min" indicates every 15 minutes.
        public let dataFrequency: String?
        /// A name for the dataset.
        public let datasetName: String
        /// The dataset type. Valid values depend on the chosen Domain.
        public let datasetType: DatasetType
        /// The domain associated with the dataset. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see howitworks-datasets-groups.
        public let domain: Domain
        /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// The schema for the dataset. The schema attributes and their order must match the fields in your data. The dataset Domain and DatasetType that you choose determine the minimum required fields in your training data. For information about the required fields for a specific dataset domain and type, see howitworks-domains-ds-types.
        public let schema: Schema

        public init(dataFrequency: String? = nil, datasetName: String, datasetType: DatasetType, domain: Domain, encryptionConfig: EncryptionConfig? = nil, schema: Schema) {
            self.dataFrequency = dataFrequency
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.encryptionConfig = encryptionConfig
            self.schema = schema
        }

        public func validate(name: String) throws {
            try validate(self.dataFrequency, name:"dataFrequency", parent: name, pattern: "^Y|M|W|D|H|30min|15min|10min|5min|1min$")
            try validate(self.datasetName, name:"datasetName", parent: name, max: 63)
            try validate(self.datasetName, name:"datasetName", parent: name, min: 1)
            try validate(self.datasetName, name:"datasetName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
            try self.schema.validate(name: "\(name).schema")
        }

        private enum CodingKeys: String, CodingKey {
            case dataFrequency = "DataFrequency"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case encryptionConfig = "EncryptionConfig"
            case schema = "Schema"
        }
    }

    public struct CreateDatasetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct CreateForecastExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Destination", required: true, type: .structure), 
            AWSShapeMember(label: "ForecastArn", required: true, type: .string), 
            AWSShapeMember(label: "ForecastExportJobName", required: true, type: .string)
        ]

        /// The path to the Amazon S3 bucket where you want to save the forecast and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the bucket.
        public let destination: DataDestination
        /// The Amazon Resource Name (ARN) of the forecast that you want to export.
        public let forecastArn: String
        /// The name for the forecast export job.
        public let forecastExportJobName: String

        public init(destination: DataDestination, forecastArn: String, forecastExportJobName: String) {
            self.destination = destination
            self.forecastArn = forecastArn
            self.forecastExportJobName = forecastExportJobName
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try validate(self.forecastArn, name:"forecastArn", parent: name, max: 256)
            try validate(self.forecastArn, name:"forecastArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try validate(self.forecastExportJobName, name:"forecastExportJobName", parent: name, max: 63)
            try validate(self.forecastExportJobName, name:"forecastExportJobName", parent: name, min: 1)
            try validate(self.forecastExportJobName, name:"forecastExportJobName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case forecastArn = "ForecastArn"
            case forecastExportJobName = "ForecastExportJobName"
        }
    }

    public struct CreateForecastExportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastExportJobArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the export job.
        public let forecastExportJobArn: String?

        public init(forecastExportJobArn: String? = nil) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct CreateForecastRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastName", required: true, type: .string), 
            AWSShapeMember(label: "PredictorArn", required: true, type: .string)
        ]

        /// The name for the forecast.
        public let forecastName: String
        /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
        public let predictorArn: String

        public init(forecastName: String, predictorArn: String) {
            self.forecastName = forecastName
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try validate(self.forecastName, name:"forecastName", parent: name, max: 63)
            try validate(self.forecastName, name:"forecastName", parent: name, min: 1)
            try validate(self.forecastName, name:"forecastName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            try validate(self.predictorArn, name:"predictorArn", parent: name, max: 256)
            try validate(self.predictorArn, name:"predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastName = "ForecastName"
            case predictorArn = "PredictorArn"
        }
    }

    public struct CreateForecastResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the forecast.
        public let forecastArn: String?

        public init(forecastArn: String? = nil) {
            self.forecastArn = forecastArn
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct CreatePredictorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmArn", required: false, type: .string), 
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "EvaluationParameters", required: false, type: .structure), 
            AWSShapeMember(label: "FeaturizationConfig", required: true, type: .structure), 
            AWSShapeMember(label: "ForecastHorizon", required: true, type: .integer), 
            AWSShapeMember(label: "HPOConfig", required: false, type: .structure), 
            AWSShapeMember(label: "InputDataConfig", required: true, type: .structure), 
            AWSShapeMember(label: "PerformAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "PerformHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "PredictorName", required: true, type: .string), 
            AWSShapeMember(label: "TrainingParameters", required: false, type: .map)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if PerformAutoML is not set to true.  Supported algorithms     arn:aws:forecast:::algorithm/ARIMA     arn:aws:forecast:::algorithm/Deep_AR_Plus   - supports hyperparameter optimization (HPO)     arn:aws:forecast:::algorithm/ETS     arn:aws:forecast:::algorithm/NPTS     arn:aws:forecast:::algorithm/Prophet   
        public let algorithmArn: String?
        /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
        public let evaluationParameters: EvaluationParameters?
        /// The featurization configuration.
        public let featurizationConfig: FeaturizationConfig
        /// Specifies the number of time-steps that the model is trained to predict. The forecast horizon is also called the prediction length. For example, if you configure a dataset for daily data collection (using the DataFrequency parameter of the CreateDataset operation) and set the forecast horizon to 10, the model returns predictions for 10 days.
        public let forecastHorizon: Int
        /// Provides hyperparameter override values for the algorithm. If you don't provide this parameter, Amazon Forecast uses default values. The individual algorithms specify which hyperparameters support hyperparameter optimization (HPO). For more information, see aws-forecast-choosing-recipes.
        public let hPOConfig: HyperParameterTuningJobConfig?
        /// Describes the dataset group that contains the data to use to train the predictor.
        public let inputDataConfig: InputDataConfig
        /// Whether to perform AutoML. The default value is false. In this case, you are required to specify an algorithm. If you want Amazon Forecast to evaluate the algorithms it provides and choose the best algorithm and configuration for your training dataset, set PerformAutoML to true. This is a good option if you aren't sure which algorithm is suitable for your application.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter values for your training data. The process of performing HPO is known as a hyperparameter tuning job. The default value is false. In this case, Amazon Forecast uses default hyperparameter values from the chosen algorithm. To override the default values, set PerformHPO to true and supply the HyperParameterTuningJobConfig object. The tuning job specifies an objective metric, the hyperparameters to optimize, and the valid range for each hyperparameter. The following algorithms support HPO:   DeepAR+  
        public let performHPO: Bool?
        /// A name for the predictor.
        public let predictorName: String
        /// The training parameters to override for model training. The parameters that you can override are listed in the individual algorithms in aws-forecast-choosing-recipes.
        public let trainingParameters: [String: String]?

        public init(algorithmArn: String? = nil, encryptionConfig: EncryptionConfig? = nil, evaluationParameters: EvaluationParameters? = nil, featurizationConfig: FeaturizationConfig, forecastHorizon: Int, hPOConfig: HyperParameterTuningJobConfig? = nil, inputDataConfig: InputDataConfig, performAutoML: Bool? = nil, performHPO: Bool? = nil, predictorName: String, trainingParameters: [String: String]? = nil) {
            self.algorithmArn = algorithmArn
            self.encryptionConfig = encryptionConfig
            self.evaluationParameters = evaluationParameters
            self.featurizationConfig = featurizationConfig
            self.forecastHorizon = forecastHorizon
            self.hPOConfig = hPOConfig
            self.inputDataConfig = inputDataConfig
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.predictorName = predictorName
            self.trainingParameters = trainingParameters
        }

        public func validate(name: String) throws {
            try validate(self.algorithmArn, name:"algorithmArn", parent: name, max: 256)
            try validate(self.algorithmArn, name:"algorithmArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
            try self.featurizationConfig.validate(name: "\(name).featurizationConfig")
            try self.hPOConfig?.validate(name: "\(name).hPOConfig")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try validate(self.predictorName, name:"predictorName", parent: name, max: 63)
            try validate(self.predictorName, name:"predictorName", parent: name, min: 1)
            try validate(self.predictorName, name:"predictorName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            try self.trainingParameters?.forEach {
                try validate($0.key, name:"trainingParameters.key", parent: name, max: 256)
                try validate($0.key, name:"trainingParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\\]+$")
                try validate($0.value, name:"trainingParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name:"trainingParameters[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\"\\\\\\s]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case encryptionConfig = "EncryptionConfig"
            case evaluationParameters = "EvaluationParameters"
            case featurizationConfig = "FeaturizationConfig"
            case forecastHorizon = "ForecastHorizon"
            case hPOConfig = "HPOConfig"
            case inputDataConfig = "InputDataConfig"
            case performAutoML = "PerformAutoML"
            case performHPO = "PerformHPO"
            case predictorName = "PredictorName"
            case trainingParameters = "TrainingParameters"
        }
    }

    public struct CreatePredictorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PredictorArn", required: false, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the predictor.
        public let predictorArn: String?

        public init(predictorArn: String? = nil) {
            self.predictorArn = predictorArn
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DataDestination: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3Config", required: true, type: .structure)
        ]

        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.
        public let s3Config: S3Config

        public init(s3Config: S3Config) {
            self.s3Config = s3Config
        }

        public func validate(name: String) throws {
            try self.s3Config.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct DataSource: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "S3Config", required: true, type: .structure)
        ]

        /// The path to the training data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.
        public let s3Config: S3Config

        public init(s3Config: S3Config) {
            self.s3Config = s3Config
        }

        public func validate(name: String) throws {
            try self.s3Config.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct DatasetGroupSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "DatasetGroupName", required: false, type: .string), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp)
        ]

        /// When the datase group was created.
        public let creationTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The name of the dataset group.
        public let datasetGroupName: String?
        /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated, LastModificationTime is the current query time.
        public let lastModificationTime: TimeStamp?

        public init(creationTime: TimeStamp? = nil, datasetGroupArn: String? = nil, datasetGroupName: String? = nil, lastModificationTime: TimeStamp? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case datasetGroupName = "DatasetGroupName"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public struct DatasetImportJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetImportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "DatasetImportJobName", required: false, type: .string), 
            AWSShapeMember(label: "DataSource", required: false, type: .structure), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the dataset import job was created.
        public let creationTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?
        /// The name of the dataset import job.
        public let datasetImportJobName: String?
        /// The location of the Amazon S3 bucket that contains the training data.
        public let dataSource: DataSource?
        /// Dependent on the status as follows:    CREATE_PENDING - same as CreationTime     CREATE_IN_PROGRESS - the current timestamp    ACTIVE or CREATE_FAILED - when the job finished or failed  
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the dataset import job. The status is reflected in the status of the dataset. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED   
        public let status: String?

        public init(creationTime: TimeStamp? = nil, datasetImportJobArn: String? = nil, datasetImportJobName: String? = nil, dataSource: DataSource? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSource = dataSource
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetImportJobArn = "DatasetImportJobArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSource = "DataSource"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct DatasetSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetArn", required: false, type: .string), 
            AWSShapeMember(label: "DatasetName", required: false, type: .string), 
            AWSShapeMember(label: "DatasetType", required: false, type: .enum), 
            AWSShapeMember(label: "Domain", required: false, type: .enum), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp)
        ]

        /// When the dataset was created.
        public let creationTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The dataset type.
        public let datasetType: DatasetType?
        /// The domain associated with the dataset.
        public let domain: Domain?
        /// When the dataset is created, LastModificationTime is the same as CreationTime. After a CreateDatasetImportJob operation is called, LastModificationTime is when the import job finished or failed. While data is being imported to the dataset, LastModificationTime is the current query time.
        public let lastModificationTime: TimeStamp?

        public init(creationTime: TimeStamp? = nil, datasetArn: String? = nil, datasetName: String? = nil, datasetType: DatasetType? = nil, domain: Domain? = nil, lastModificationTime: TimeStamp? = nil) {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArn = "DatasetArn"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public enum DatasetType: String, CustomStringConvertible, Codable {
        case targetTimeSeries = "TARGET_TIME_SERIES"
        case relatedTimeSeries = "RELATED_TIME_SERIES"
        case itemMetadata = "ITEM_METADATA"
        public var description: String { return self.rawValue }
    }

    public struct DeleteDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetGroupArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group to delete.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct DeleteDatasetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetImportJobArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset import job to delete.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetImportJobArn, name:"datasetImportJobArn", parent: name, max: 256)
            try validate(self.datasetImportJobArn, name:"datasetImportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct DeleteDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset to delete.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetArn, name:"datasetArn", parent: name, max: 256)
            try validate(self.datasetArn, name:"datasetArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct DeleteForecastExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastExportJobArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the forecast export job to delete.
        public let forecastExportJobArn: String

        public init(forecastExportJobArn: String) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        public func validate(name: String) throws {
            try validate(self.forecastExportJobArn, name:"forecastExportJobArn", parent: name, max: 256)
            try validate(self.forecastExportJobArn, name:"forecastExportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct DeleteForecastRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the forecast to delete.
        public let forecastArn: String

        public init(forecastArn: String) {
            self.forecastArn = forecastArn
        }

        public func validate(name: String) throws {
            try validate(self.forecastArn, name:"forecastArn", parent: name, max: 256)
            try validate(self.forecastArn, name:"forecastArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct DeletePredictorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PredictorArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the predictor to delete.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try validate(self.predictorArn, name:"predictorArn", parent: name, max: 256)
            try validate(self.predictorArn, name:"predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DescribeDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetGroupArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct DescribeDatasetGroupResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetArns", required: false, type: .list), 
            AWSShapeMember(label: "DatasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "DatasetGroupName", required: false, type: .string), 
            AWSShapeMember(label: "Domain", required: false, type: .enum), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the dataset group was created.
        public let creationTime: TimeStamp?
        /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset group.
        public let datasetArns: [String]?
        /// The ARN of the dataset group.
        public let datasetGroupArn: String?
        /// The name of the dataset group.
        public let datasetGroupName: String?
        /// The domain associated with the dataset group. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see howitworks-datasets-groups.
        public let domain: Domain?
        /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated, LastModificationTime is the current query time.
        public let lastModificationTime: TimeStamp?
        /// The status of the dataset group. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED    The UPDATE states apply when the UpdateDatasetGroup operation is called.  The Status of the dataset group must be ACTIVE before creating a predictor using the dataset group. 
        public let status: String?

        public init(creationTime: TimeStamp? = nil, datasetArns: [String]? = nil, datasetGroupArn: String? = nil, datasetGroupName: String? = nil, domain: Domain? = nil, lastModificationTime: TimeStamp? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetArns = datasetArns
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.domain = domain
            self.lastModificationTime = lastModificationTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArns = "DatasetArns"
            case datasetGroupArn = "DatasetGroupArn"
            case datasetGroupName = "DatasetGroupName"
            case domain = "Domain"
            case lastModificationTime = "LastModificationTime"
            case status = "Status"
        }
    }

    public struct DescribeDatasetImportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetImportJobArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetImportJobArn, name:"datasetImportJobArn", parent: name, max: 256)
            try validate(self.datasetImportJobArn, name:"datasetImportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct DescribeDatasetImportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetArn", required: false, type: .string), 
            AWSShapeMember(label: "DatasetImportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "DatasetImportJobName", required: false, type: .string), 
            AWSShapeMember(label: "DataSize", required: false, type: .double), 
            AWSShapeMember(label: "DataSource", required: false, type: .structure), 
            AWSShapeMember(label: "FieldStatistics", required: false, type: .map), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "TimestampFormat", required: false, type: .string)
        ]

        /// When the dataset import job was created.
        public let creationTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset that the training data was imported to.
        public let datasetArn: String?
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?
        /// The name of the dataset import job.
        public let datasetImportJobName: String?
        /// The size of the dataset in gigabytes (GB) after completion of the import job.
        public let dataSize: Double?
        /// The location of the training data to import. The training data must be stored in an Amazon S3 bucket.
        public let dataSource: DataSource?
        /// Statistical information about each field in the input data.
        public let fieldStatistics: [String: Statistics]?
        /// Dependent on the status as follows:    CREATE_PENDING - same as CreationTime     CREATE_IN_PROGRESS - the current timestamp    ACTIVE or CREATE_FAILED - when the job finished or failed  
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the dataset import job. The status is reflected in the status of the dataset. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED   
        public let status: String?
        /// The format of timestamps in the dataset. Two formats are supported dependent on the DataFrequency specified when the dataset was created.   "yyyy-MM-dd" For data frequencies: Y, M, W, and D   "yyyy-MM-dd HH:mm:ss" For data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D  
        public let timestampFormat: String?

        public init(creationTime: TimeStamp? = nil, datasetArn: String? = nil, datasetImportJobArn: String? = nil, datasetImportJobName: String? = nil, dataSize: Double? = nil, dataSource: DataSource? = nil, fieldStatistics: [String: Statistics]? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, status: String? = nil, timestampFormat: String? = nil) {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSize = dataSize
            self.dataSource = dataSource
            self.fieldStatistics = fieldStatistics
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.timestampFormat = timestampFormat
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArn = "DatasetArn"
            case datasetImportJobArn = "DatasetImportJobArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSize = "DataSize"
            case dataSource = "DataSource"
            case fieldStatistics = "FieldStatistics"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case timestampFormat = "TimestampFormat"
        }
    }

    public struct DescribeDatasetRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try validate(self.datasetArn, name:"datasetArn", parent: name, max: 256)
            try validate(self.datasetArn, name:"datasetArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct DescribeDatasetResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DataFrequency", required: false, type: .string), 
            AWSShapeMember(label: "DatasetArn", required: false, type: .string), 
            AWSShapeMember(label: "DatasetName", required: false, type: .string), 
            AWSShapeMember(label: "DatasetType", required: false, type: .enum), 
            AWSShapeMember(label: "Domain", required: false, type: .enum), 
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Schema", required: false, type: .structure), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the dataset was created.
        public let creationTime: TimeStamp?
        /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "M" indicates every month and "30min" indicates every 30 minutes.
        public let dataFrequency: String?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The dataset type.
        public let datasetType: DatasetType?
        /// The dataset domain.
        public let domain: Domain?
        /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// When the dataset is created, LastModificationTime is the same as CreationTime. After a CreateDatasetImportJob operation is called, LastModificationTime is when the import job finished or failed. While data is being imported to the dataset, LastModificationTime is the current query time.
        public let lastModificationTime: TimeStamp?
        /// An array of SchemaAttribute objects that specify the dataset fields. Each SchemaAttribute specifies the name and data type of a field.
        public let schema: Schema?
        /// The status of the dataset. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED    The UPDATE states apply while data is imported to the dataset from a call to the CreateDatasetImportJob operation. During this time, the status reflects the status of the dataset import job. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS.  The Status of the dataset must be ACTIVE before you can import training data. 
        public let status: String?

        public init(creationTime: TimeStamp? = nil, dataFrequency: String? = nil, datasetArn: String? = nil, datasetName: String? = nil, datasetType: DatasetType? = nil, domain: Domain? = nil, encryptionConfig: EncryptionConfig? = nil, lastModificationTime: TimeStamp? = nil, schema: Schema? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.dataFrequency = dataFrequency
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.encryptionConfig = encryptionConfig
            self.lastModificationTime = lastModificationTime
            self.schema = schema
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataFrequency = "DataFrequency"
            case datasetArn = "DatasetArn"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case encryptionConfig = "EncryptionConfig"
            case lastModificationTime = "LastModificationTime"
            case schema = "Schema"
            case status = "Status"
        }
    }

    public struct DescribeForecastExportJobRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastExportJobArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the forecast export job.
        public let forecastExportJobArn: String

        public init(forecastExportJobArn: String) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        public func validate(name: String) throws {
            try validate(self.forecastExportJobArn, name:"forecastExportJobArn", parent: name, max: 256)
            try validate(self.forecastExportJobArn, name:"forecastExportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct DescribeForecastExportJobResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Destination", required: false, type: .structure), 
            AWSShapeMember(label: "ForecastArn", required: false, type: .string), 
            AWSShapeMember(label: "ForecastExportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "ForecastExportJobName", required: false, type: .string), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the forecast export job was created.
        public let creationTime: TimeStamp?
        /// The path to the AWS S3 bucket where the forecast is exported.
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the exported forecast.
        public let forecastArn: String?
        /// The ARN of the forecast export job.
        public let forecastExportJobArn: String?
        /// The name of the forecast export job.
        public let forecastExportJobName: String?
        /// When the last successful export job finished.
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the forecast export job. One of the following states:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast export job must be ACTIVE before you can access the forecast in your Amazon S3 bucket. 
        public let status: String?

        public init(creationTime: TimeStamp? = nil, destination: DataDestination? = nil, forecastArn: String? = nil, forecastExportJobArn: String? = nil, forecastExportJobName: String? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastArn = forecastArn
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case forecastArn = "ForecastArn"
            case forecastExportJobArn = "ForecastExportJobArn"
            case forecastExportJobName = "ForecastExportJobName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct DescribeForecastRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the forecast.
        public let forecastArn: String

        public init(forecastArn: String) {
            self.forecastArn = forecastArn
        }

        public func validate(name: String) throws {
            try validate(self.forecastArn, name:"forecastArn", parent: name, max: 256)
            try validate(self.forecastArn, name:"forecastArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct DescribeForecastResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "ForecastArn", required: false, type: .string), 
            AWSShapeMember(label: "ForecastName", required: false, type: .string), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "PredictorArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the forecast creation task was created.
        public let creationTime: TimeStamp?
        /// The ARN of the dataset group that provided the data used to train the predictor.
        public let datasetGroupArn: String?
        /// The same forecast ARN as given in the request.
        public let forecastArn: String?
        /// The name of the forecast.
        public let forecastName: String?
        /// Initially, the same as CreationTime (status is CREATE_PENDING). Updated when inference (creating the forecast) starts (status changed to CREATE_IN_PROGRESS), and when inference is complete (status changed to ACTIVE) or fails (status changed to CREATE_FAILED).
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor used to generate the forecast.
        public let predictorArn: String?
        /// The status of the forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast must be ACTIVE before you can query or export the forecast. 
        public let status: String?

        public init(creationTime: TimeStamp? = nil, datasetGroupArn: String? = nil, forecastArn: String? = nil, forecastName: String? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, predictorArn: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case forecastArn = "ForecastArn"
            case forecastName = "ForecastName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case status = "Status"
        }
    }

    public struct DescribePredictorRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PredictorArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the predictor that you want information about.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try validate(self.predictorArn, name:"predictorArn", parent: name, max: 256)
            try validate(self.predictorArn, name:"predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DescribePredictorResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmArn", required: false, type: .string), 
            AWSShapeMember(label: "AutoMLAlgorithmArns", required: false, type: .list), 
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetImportJobArns", required: false, type: .list), 
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure), 
            AWSShapeMember(label: "EvaluationParameters", required: false, type: .structure), 
            AWSShapeMember(label: "FeaturizationConfig", required: false, type: .structure), 
            AWSShapeMember(label: "ForecastHorizon", required: false, type: .integer), 
            AWSShapeMember(label: "HPOConfig", required: false, type: .structure), 
            AWSShapeMember(label: "InputDataConfig", required: false, type: .structure), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "PerformAutoML", required: false, type: .boolean), 
            AWSShapeMember(label: "PerformHPO", required: false, type: .boolean), 
            AWSShapeMember(label: "PredictorArn", required: false, type: .string), 
            AWSShapeMember(label: "PredictorName", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string), 
            AWSShapeMember(label: "TrainingParameters", required: false, type: .map)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm used for model training.
        public let algorithmArn: String?
        /// When PerformAutoML is specified, the ARN of the chosen algorithm.
        public let autoMLAlgorithmArns: [String]?
        /// When the model training task was created.
        public let creationTime: TimeStamp?
        /// An array of ARNs of the dataset import jobs used to import training data for the predictor.
        public let datasetImportJobArns: [String]?
        /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
        public let evaluationParameters: EvaluationParameters?
        /// The featurization configuration.
        public let featurizationConfig: FeaturizationConfig?
        /// The number of time-steps of the forecast. The forecast horizon is also called the prediction length.
        public let forecastHorizon: Int?
        /// The hyperparameter override values for the algorithm.
        public let hPOConfig: HyperParameterTuningJobConfig?
        /// Describes the dataset group that contains the data to use to train the predictor.
        public let inputDataConfig: InputDataConfig?
        /// Initially, the same as CreationTime (status is CREATE_PENDING). Updated when training starts (status changed to CREATE_IN_PROGRESS), and when training is complete (status changed to ACTIVE) or fails (status changed to CREATE_FAILED).
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// Whether the predictor is set to perform AutoML.
        public let performAutoML: Bool?
        /// Whether the predictor is set to perform HPO.
        public let performHPO: Bool?
        /// The ARN of the predictor.
        public let predictorArn: String?
        /// The name of the predictor.
        public let predictorName: String?
        /// The status of the predictor. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED     The Status of the predictor must be ACTIVE before using the predictor to create a forecast. 
        public let status: String?
        /// The training parameters to override for model training. The parameters that you can override are listed in the individual algorithms in aws-forecast-choosing-recipes.
        public let trainingParameters: [String: String]?

        public init(algorithmArn: String? = nil, autoMLAlgorithmArns: [String]? = nil, creationTime: TimeStamp? = nil, datasetImportJobArns: [String]? = nil, encryptionConfig: EncryptionConfig? = nil, evaluationParameters: EvaluationParameters? = nil, featurizationConfig: FeaturizationConfig? = nil, forecastHorizon: Int? = nil, hPOConfig: HyperParameterTuningJobConfig? = nil, inputDataConfig: InputDataConfig? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, predictorArn: String? = nil, predictorName: String? = nil, status: String? = nil, trainingParameters: [String: String]? = nil) {
            self.algorithmArn = algorithmArn
            self.autoMLAlgorithmArns = autoMLAlgorithmArns
            self.creationTime = creationTime
            self.datasetImportJobArns = datasetImportJobArns
            self.encryptionConfig = encryptionConfig
            self.evaluationParameters = evaluationParameters
            self.featurizationConfig = featurizationConfig
            self.forecastHorizon = forecastHorizon
            self.hPOConfig = hPOConfig
            self.inputDataConfig = inputDataConfig
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.status = status
            self.trainingParameters = trainingParameters
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
            case creationTime = "CreationTime"
            case datasetImportJobArns = "DatasetImportJobArns"
            case encryptionConfig = "EncryptionConfig"
            case evaluationParameters = "EvaluationParameters"
            case featurizationConfig = "FeaturizationConfig"
            case forecastHorizon = "ForecastHorizon"
            case hPOConfig = "HPOConfig"
            case inputDataConfig = "InputDataConfig"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case performAutoML = "PerformAutoML"
            case performHPO = "PerformHPO"
            case predictorArn = "PredictorArn"
            case predictorName = "PredictorName"
            case status = "Status"
            case trainingParameters = "TrainingParameters"
        }
    }

    public enum Domain: String, CustomStringConvertible, Codable {
        case retail = "RETAIL"
        case custom = "CUSTOM"
        case inventoryPlanning = "INVENTORY_PLANNING"
        case ec2Capacity = "EC2_CAPACITY"
        case workForce = "WORK_FORCE"
        case webTraffic = "WEB_TRAFFIC"
        case metrics = "METRICS"
        public var description: String { return self.rawValue }
    }

    public struct EncryptionConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KMSKeyArn", required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.
        public let kMSKeyArn: String
        /// The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the AWS KMS key. Cross-account pass role is not allowed. If you pass a role that doesn't belong to your account, an InvalidInputException is thrown.
        public let roleArn: String

        public init(kMSKeyArn: String, roleArn: String) {
            self.kMSKeyArn = kMSKeyArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try validate(self.kMSKeyArn, name:"kMSKeyArn", parent: name, max: 256)
            try validate(self.kMSKeyArn, name:"kMSKeyArn", parent: name, pattern: "arn:aws:kms:.*:key/.*")
            try validate(self.roleArn, name:"roleArn", parent: name, max: 256)
            try validate(self.roleArn, name:"roleArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kMSKeyArn = "KMSKeyArn"
            case roleArn = "RoleArn"
        }
    }

    public struct EvaluationParameters: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BackTestWindowOffset", required: false, type: .integer), 
            AWSShapeMember(label: "NumberOfBacktestWindows", required: false, type: .integer)
        ]

        /// The point from the end of the dataset where you want to split the data for model training and evaluation. The value is specified as the number of data points.
        public let backTestWindowOffset: Int?
        /// The number of times to split the input data. The default is 1. The range is 1 through 5.
        public let numberOfBacktestWindows: Int?

        public init(backTestWindowOffset: Int? = nil, numberOfBacktestWindows: Int? = nil) {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }

        private enum CodingKeys: String, CodingKey {
            case backTestWindowOffset = "BackTestWindowOffset"
            case numberOfBacktestWindows = "NumberOfBacktestWindows"
        }
    }

    public struct EvaluationResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AlgorithmArn", required: false, type: .string), 
            AWSShapeMember(label: "TestWindows", required: false, type: .list)
        ]

        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public let algorithmArn: String?
        /// The array of test windows used for evaluating the algorithm. The NumberOfBacktestWindows from the EvaluationParameters object determines the number of windows in the array.
        public let testWindows: [WindowSummary]?

        public init(algorithmArn: String? = nil, testWindows: [WindowSummary]? = nil) {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case testWindows = "TestWindows"
        }
    }

    public enum EvaluationType: String, CustomStringConvertible, Codable {
        case summary = "SUMMARY"
        case computed = "COMPUTED"
        public var description: String { return self.rawValue }
    }

    public struct Featurization: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributeName", required: true, type: .string), 
            AWSShapeMember(label: "FeaturizationPipeline", required: false, type: .list)
        ]

        /// The name of the schema attribute specifying the data field to be featurized. In this release, only the target field of the TARGET_TIME_SERIES dataset type is supported. For example, for the RETAIL domain, the target is demand, and for the CUSTOM domain, the target is target_value.
        public let attributeName: String
        /// An array FeaturizationMethod objects that specifies the feature transformation methods. For this release, the number of methods is limited to one.
        public let featurizationPipeline: [FeaturizationMethod]?

        public init(attributeName: String, featurizationPipeline: [FeaturizationMethod]? = nil) {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }

        public func validate(name: String) throws {
            try validate(self.attributeName, name:"attributeName", parent: name, max: 63)
            try validate(self.attributeName, name:"attributeName", parent: name, min: 1)
            try validate(self.attributeName, name:"attributeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            try self.featurizationPipeline?.forEach {
                try $0.validate(name: "\(name).featurizationPipeline[]")
            }
            try validate(self.featurizationPipeline, name:"featurizationPipeline", parent: name, max: 1)
            try validate(self.featurizationPipeline, name:"featurizationPipeline", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case featurizationPipeline = "FeaturizationPipeline"
        }
    }

    public struct FeaturizationConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Featurizations", required: false, type: .list), 
            AWSShapeMember(label: "ForecastDimensions", required: false, type: .list), 
            AWSShapeMember(label: "ForecastFrequency", required: true, type: .string)
        ]

        /// An array of featurization (transformation) information for the fields of a dataset. In this release, only a single featurization is supported.
        public let featurizations: [Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a store_id field. If you want the sales forecast for each item by store, you would specify store_id as the dimension.
        public let forecastDimensions: [String]?
        /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.
        public let forecastFrequency: String

        public init(featurizations: [Featurization]? = nil, forecastDimensions: [String]? = nil, forecastFrequency: String) {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }

        public func validate(name: String) throws {
            try self.featurizations?.forEach {
                try $0.validate(name: "\(name).featurizations[]")
            }
            try validate(self.featurizations, name:"featurizations", parent: name, max: 1)
            try validate(self.featurizations, name:"featurizations", parent: name, min: 1)
            try self.forecastDimensions?.forEach {
                try validate($0, name: "forecastDimensions[]", parent: name, max: 63)
                try validate($0, name: "forecastDimensions[]", parent: name, min: 1)
                try validate($0, name: "forecastDimensions[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            }
            try validate(self.forecastDimensions, name:"forecastDimensions", parent: name, max: 5)
            try validate(self.forecastDimensions, name:"forecastDimensions", parent: name, min: 1)
            try validate(self.forecastFrequency, name:"forecastFrequency", parent: name, pattern: "^Y|M|W|D|H|30min|15min|10min|5min|1min$")
        }

        private enum CodingKeys: String, CodingKey {
            case featurizations = "Featurizations"
            case forecastDimensions = "ForecastDimensions"
            case forecastFrequency = "ForecastFrequency"
        }
    }

    public struct FeaturizationMethod: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FeaturizationMethodName", required: true, type: .enum), 
            AWSShapeMember(label: "FeaturizationMethodParameters", required: false, type: .map)
        ]

        /// The name of the method. In this release, "filling" is the only supported method.
        public let featurizationMethodName: FeaturizationMethodName
        /// The method parameters (key-value pairs). Specify these to override the default values. The following list shows the parameters and their valid values. Bold signifies the default value.    aggregation: sum, avg, first, min, max     frontfill: none     middlefill: zero, nan (not a number)    backfill: zero, nan   
        public let featurizationMethodParameters: [String: String]?

        public init(featurizationMethodName: FeaturizationMethodName, featurizationMethodParameters: [String: String]? = nil) {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }

        public func validate(name: String) throws {
            try self.featurizationMethodParameters?.forEach {
                try validate($0.key, name:"featurizationMethodParameters.key", parent: name, max: 256)
                try validate($0.key, name:"featurizationMethodParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\\]+$")
                try validate($0.value, name:"featurizationMethodParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name:"featurizationMethodParameters[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\"\\\\\\s]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case featurizationMethodName = "FeaturizationMethodName"
            case featurizationMethodParameters = "FeaturizationMethodParameters"
        }
    }

    public enum FeaturizationMethodName: String, CustomStringConvertible, Codable {
        case filling = "filling"
        public var description: String { return self.rawValue }
    }

    public struct Filter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Condition", required: true, type: .enum), 
            AWSShapeMember(label: "Key", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: true, type: .string)
        ]

        /// The condition to apply.
        public let condition: FilterConditionString
        /// The name of the parameter to filter on.
        public let key: String
        /// A valid value for Key.
        public let value: String

        public init(condition: FilterConditionString, key: String, value: String) {
            self.condition = condition
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 256)
            try validate(self.key, name:"key", parent: name, pattern: "^[a-zA-Z0-9\\_]+$")
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case key = "Key"
            case value = "Value"
        }
    }

    public enum FilterConditionString: String, CustomStringConvertible, Codable {
        case `is` = "IS"
        case isNot = "IS_NOT"
        public var description: String { return self.rawValue }
    }

    public struct ForecastExportJobSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Destination", required: false, type: .structure), 
            AWSShapeMember(label: "ForecastExportJobArn", required: false, type: .string), 
            AWSShapeMember(label: "ForecastExportJobName", required: false, type: .string), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the forecast export job was created.
        public let creationTime: TimeStamp?
        /// The path to the S3 bucket where the forecast is stored.
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public let forecastExportJobArn: String?
        /// The name of the forecast export job.
        public let forecastExportJobName: String?
        /// When the last successful export job finished.
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the forecast export job. One of the following states:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast export job must be ACTIVE before you can access the forecast in your Amazon S3 bucket. 
        public let status: String?

        public init(creationTime: TimeStamp? = nil, destination: DataDestination? = nil, forecastExportJobArn: String? = nil, forecastExportJobName: String? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case forecastExportJobArn = "ForecastExportJobArn"
            case forecastExportJobName = "ForecastExportJobName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct ForecastSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "ForecastArn", required: false, type: .string), 
            AWSShapeMember(label: "ForecastName", required: false, type: .string), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "PredictorArn", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the forecast creation task was created.
        public let creationTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.
        public let datasetGroupArn: String?
        /// The ARN of the forecast.
        public let forecastArn: String?
        /// The name of the forecast.
        public let forecastName: String?
        /// Initially, the same as CreationTime (status is CREATE_PENDING). Updated when inference (creating the forecast) starts (status changed to CREATE_IN_PROGRESS), and when inference is complete (status changed to ACTIVE) or fails (status changed to CREATE_FAILED).
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor used to generate the forecast.
        public let predictorArn: String?
        /// The status of the forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast must be ACTIVE before you can query or export the forecast. 
        public let status: String?

        public init(creationTime: TimeStamp? = nil, datasetGroupArn: String? = nil, forecastArn: String? = nil, forecastName: String? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, predictorArn: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case forecastArn = "ForecastArn"
            case forecastName = "ForecastName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case status = "Status"
        }
    }

    public struct GetAccuracyMetricsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PredictorArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try validate(self.predictorArn, name:"predictorArn", parent: name, max: 256)
            try validate(self.predictorArn, name:"predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct GetAccuracyMetricsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "PredictorEvaluationResults", required: false, type: .list)
        ]

        /// An array of results from evaluating the predictor.
        public let predictorEvaluationResults: [EvaluationResult]?

        public init(predictorEvaluationResults: [EvaluationResult]? = nil) {
            self.predictorEvaluationResults = predictorEvaluationResults
        }

        private enum CodingKeys: String, CodingKey {
            case predictorEvaluationResults = "PredictorEvaluationResults"
        }
    }

    public struct HyperParameterTuningJobConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ParameterRanges", required: false, type: .structure)
        ]

        /// Specifies the ranges of valid values for the hyperparameters.
        public let parameterRanges: ParameterRanges?

        public init(parameterRanges: ParameterRanges? = nil) {
            self.parameterRanges = parameterRanges
        }

        public func validate(name: String) throws {
            try self.parameterRanges?.validate(name: "\(name).parameterRanges")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterRanges = "ParameterRanges"
        }
    }

    public struct InputDataConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetGroupArn", required: true, type: .string), 
            AWSShapeMember(label: "SupplementaryFeatures", required: false, type: .list)
        ]

        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String
        /// An array of supplementary features. For this release, the only supported feature is a holiday calendar.
        public let supplementaryFeatures: [SupplementaryFeature]?

        public init(datasetGroupArn: String, supplementaryFeatures: [SupplementaryFeature]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }

        public func validate(name: String) throws {
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.supplementaryFeatures?.forEach {
                try $0.validate(name: "\(name).supplementaryFeatures[]")
            }
            try validate(self.supplementaryFeatures, name:"supplementaryFeatures", parent: name, max: 1)
            try validate(self.supplementaryFeatures, name:"supplementaryFeatures", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
            case supplementaryFeatures = "SupplementaryFeatures"
        }
    }

    public struct IntegerParameterRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxValue", required: true, type: .integer), 
            AWSShapeMember(label: "MinValue", required: true, type: .integer), 
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "ScalingType", required: false, type: .enum)
        ]

        /// The maximum tunable value of the hyperparameter.
        public let maxValue: Int
        /// The minimum tunable value of the hyperparameter.
        public let minValue: Int
        /// The name of the hyperparameter to tune.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:  Auto  Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have only values greater than 0.  ReverseLogarithmic  Not supported for IntegerParameterRange. Reverse logarithmic scaling works only for ranges that are entirely within the range 0 &lt;= x &lt; 1.0.  
        public let scalingType: ScalingType?

        public init(maxValue: Int, minValue: Int, name: String, scalingType: ScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct ListDatasetGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetGroupsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetGroups", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of objects that summarize each dataset group's properties.
        public let datasetGroups: [DatasetGroupSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasetGroups: [DatasetGroupSummary]? = nil, nextToken: String? = nil) {
            self.datasetGroups = datasetGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroups = "DatasetGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetImportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude, respectively, from the list, the predictors that match the statement. The match statement consists of a key and a value. In this release, Name is the only valid key, which filters on the DatasetImportJobName property.    Condition - IS or IS_NOT     Key - Name     Value - the value to match   For example, to list all dataset import jobs named my_dataset_import_job, you would specify:  "Filters": [ { "Condition": "IS", "Key": "Name", "Value": "my_dataset_import_job" } ] 
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetImportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetImportJobs", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of objects that summarize each dataset import job's properties.
        public let datasetImportJobs: [DatasetImportJobSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasetImportJobs: [DatasetImportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetImportJobs = datasetImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobs = "DatasetImportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Datasets", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of objects that summarize each dataset's properties.
        public let datasets: [DatasetSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasets: [DatasetSummary]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "Datasets"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastExportJobsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude, respectively, from the list, the predictors that match the statement. The match statement consists of a key and a value. In this release, Name is the only valid key, which filters on the ForecastExportJobName property.    Condition - IS or IS_NOT     Key - Name     Value - the value to match   For example, to list all forecast export jobs named my_forecast_export_job, you would specify:  "Filters": [ { "Condition": "IS", "Key": "Name", "Value": "my_forecast_export_job" } ] 
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastExportJobsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ForecastExportJobs", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of objects that summarize each export job's properties.
        public let forecastExportJobs: [ForecastExportJobSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(forecastExportJobs: [ForecastExportJobSummary]? = nil, nextToken: String? = nil) {
            self.forecastExportJobs = forecastExportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobs = "ForecastExportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude, respectively, from the list, the predictors that match the statement. The match statement consists of a key and a value. In this release, Name is the only valid key, which filters on the ForecastName property.    Condition - IS or IS_NOT     Key - Name     Value - the value to match   For example, to list all forecasts named my_forecast, you would specify:  "Filters": [ { "Condition": "IS", "Key": "Name", "Value": "my_forecast" } ] 
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Forecasts", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of objects that summarize each forecast's properties.
        public let forecasts: [ForecastSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(forecasts: [ForecastSummary]? = nil, nextToken: String? = nil) {
            self.forecasts = forecasts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case forecasts = "Forecasts"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Filters", required: false, type: .list), 
            AWSShapeMember(label: "MaxResults", required: false, type: .integer), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude, respectively, from the list, the predictors that match the statement. The match statement consists of a key and a value. In this release, Name is the only valid key, which filters on the PredictorName property.    Condition - IS or IS_NOT     Key - Name     Value - the value to match   For example, to list all predictors named my_predictor, you would specify:  "Filters": [ { "Condition": "IS", "Key": "Name", "Value": "my_predictor" } ] 
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try validate(self.maxResults, name:"maxResults", parent: name, max: 100)
            try validate(self.maxResults, name:"maxResults", parent: name, min: 1)
            try validate(self.nextToken, name:"nextToken", parent: name, max: 3000)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorsResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Predictors", required: false, type: .list)
        ]

        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// An array of objects that summarize each predictor's properties.
        public let predictors: [PredictorSummary]?

        public init(nextToken: String? = nil, predictors: [PredictorSummary]? = nil) {
            self.nextToken = nextToken
            self.predictors = predictors
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case predictors = "Predictors"
        }
    }

    public struct Metrics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RMSE", required: false, type: .double), 
            AWSShapeMember(label: "WeightedQuantileLosses", required: false, type: .list)
        ]

        /// The root mean square error (RMSE).
        public let rmse: Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.
        public let weightedQuantileLosses: [WeightedQuantileLoss]?

        public init(rmse: Double? = nil, weightedQuantileLosses: [WeightedQuantileLoss]? = nil) {
            self.rmse = rmse
            self.weightedQuantileLosses = weightedQuantileLosses
        }

        private enum CodingKeys: String, CodingKey {
            case rmse = "RMSE"
            case weightedQuantileLosses = "WeightedQuantileLosses"
        }
    }

    public struct ParameterRanges: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CategoricalParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "ContinuousParameterRanges", required: false, type: .list), 
            AWSShapeMember(label: "IntegerParameterRanges", required: false, type: .list)
        ]

        /// Specifies the tunable range for each categorical hyperparameter.
        public let categoricalParameterRanges: [CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public let continuousParameterRanges: [ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public let integerParameterRanges: [IntegerParameterRange]?

        public init(categoricalParameterRanges: [CategoricalParameterRange]? = nil, continuousParameterRanges: [ContinuousParameterRange]? = nil, integerParameterRanges: [IntegerParameterRange]? = nil) {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalParameterRanges[]")
            }
            try validate(self.categoricalParameterRanges, name:"categoricalParameterRanges", parent: name, max: 20)
            try validate(self.categoricalParameterRanges, name:"categoricalParameterRanges", parent: name, min: 1)
            try self.continuousParameterRanges?.forEach {
                try $0.validate(name: "\(name).continuousParameterRanges[]")
            }
            try validate(self.continuousParameterRanges, name:"continuousParameterRanges", parent: name, max: 20)
            try validate(self.continuousParameterRanges, name:"continuousParameterRanges", parent: name, min: 1)
            try self.integerParameterRanges?.forEach {
                try $0.validate(name: "\(name).integerParameterRanges[]")
            }
            try validate(self.integerParameterRanges, name:"integerParameterRanges", parent: name, max: 20)
            try validate(self.integerParameterRanges, name:"integerParameterRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalParameterRanges = "CategoricalParameterRanges"
            case continuousParameterRanges = "ContinuousParameterRanges"
            case integerParameterRanges = "IntegerParameterRanges"
        }
    }

    public struct PredictorSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "DatasetGroupArn", required: false, type: .string), 
            AWSShapeMember(label: "LastModificationTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "PredictorArn", required: false, type: .string), 
            AWSShapeMember(label: "PredictorName", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .string)
        ]

        /// When the model training task was created.
        public let creationTime: TimeStamp?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.
        public let datasetGroupArn: String?
        /// Initially, the same as CreationTime (status is CREATE_PENDING). Updated when training starts (status changed to CREATE_IN_PROGRESS), and when training is complete (status changed to ACTIVE) or fails (status changed to CREATE_FAILED).
        public let lastModificationTime: TimeStamp?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor.
        public let predictorArn: String?
        /// The name of the predictor.
        public let predictorName: String?
        /// The status of the predictor. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED     The Status of the predictor must be ACTIVE before using the predictor to create a forecast. 
        public let status: String?

        public init(creationTime: TimeStamp? = nil, datasetGroupArn: String? = nil, lastModificationTime: TimeStamp? = nil, message: String? = nil, predictorArn: String? = nil, predictorName: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case predictorName = "PredictorName"
            case status = "Status"
        }
    }

    public struct S3Config: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KMSKeyArn", required: false, type: .string), 
            AWSShapeMember(label: "Path", required: true, type: .string), 
            AWSShapeMember(label: "RoleArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.
        public let kMSKeyArn: String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        public let path: String
        /// The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or file(s). Cross-account pass role is not allowed. If you pass a role that doesn't belong to your account, an InvalidInputException is thrown.
        public let roleArn: String

        public init(kMSKeyArn: String? = nil, path: String, roleArn: String) {
            self.kMSKeyArn = kMSKeyArn
            self.path = path
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try validate(self.kMSKeyArn, name:"kMSKeyArn", parent: name, max: 256)
            try validate(self.kMSKeyArn, name:"kMSKeyArn", parent: name, pattern: "arn:aws:kms:.*:key/.*")
            try validate(self.path, name:"path", parent: name, pattern: "^s3://.+$")
            try validate(self.roleArn, name:"roleArn", parent: name, max: 256)
            try validate(self.roleArn, name:"roleArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kMSKeyArn = "KMSKeyArn"
            case path = "Path"
            case roleArn = "RoleArn"
        }
    }

    public enum ScalingType: String, CustomStringConvertible, Codable {
        case auto = "Auto"
        case linear = "Linear"
        case logarithmic = "Logarithmic"
        case reverselogarithmic = "ReverseLogarithmic"
        public var description: String { return self.rawValue }
    }

    public struct Schema: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .list)
        ]

        /// An array of attributes specifying the name and type of each field in a dataset.
        public let attributes: [SchemaAttribute]?

        public init(attributes: [SchemaAttribute]? = nil) {
            self.attributes = attributes
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
        }
    }

    public struct SchemaAttribute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AttributeName", required: false, type: .string), 
            AWSShapeMember(label: "AttributeType", required: false, type: .enum)
        ]

        /// The name of the dataset field.
        public let attributeName: String?
        /// The data type of the field.
        public let attributeType: AttributeType?

        public init(attributeName: String? = nil, attributeType: AttributeType? = nil) {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }

        public func validate(name: String) throws {
            try validate(self.attributeName, name:"attributeName", parent: name, max: 63)
            try validate(self.attributeName, name:"attributeName", parent: name, min: 1)
            try validate(self.attributeName, name:"attributeName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeType = "AttributeType"
        }
    }

    public struct Statistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Avg", required: false, type: .double), 
            AWSShapeMember(label: "Count", required: false, type: .integer), 
            AWSShapeMember(label: "CountDistinct", required: false, type: .integer), 
            AWSShapeMember(label: "CountNan", required: false, type: .integer), 
            AWSShapeMember(label: "CountNull", required: false, type: .integer), 
            AWSShapeMember(label: "Max", required: false, type: .string), 
            AWSShapeMember(label: "Min", required: false, type: .string), 
            AWSShapeMember(label: "Stddev", required: false, type: .double)
        ]

        /// For a numeric field, the average value in the field.
        public let avg: Double?
        /// The number of values in the field.
        public let count: Int?
        /// The number of distinct values in the field.
        public let countDistinct: Int?
        /// The number of NAN (not a number) values in the field.
        public let countNan: Int?
        /// The number of null values in the field.
        public let countNull: Int?
        /// For a numeric field, the maximum value in the field.
        public let max: String?
        /// For a numeric field, the minimum value in the field.
        public let min: String?
        /// For a numeric field, the standard deviation.
        public let stddev: Double?

        public init(avg: Double? = nil, count: Int? = nil, countDistinct: Int? = nil, countNan: Int? = nil, countNull: Int? = nil, max: String? = nil, min: String? = nil, stddev: Double? = nil) {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countNan = countNan
            self.countNull = countNull
            self.max = max
            self.min = min
            self.stddev = stddev
        }

        private enum CodingKeys: String, CodingKey {
            case avg = "Avg"
            case count = "Count"
            case countDistinct = "CountDistinct"
            case countNan = "CountNan"
            case countNull = "CountNull"
            case max = "Max"
            case min = "Min"
            case stddev = "Stddev"
        }
    }

    public struct SupplementaryFeature: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: true, type: .string)
        ]

        /// The name of the feature. This must be "holiday".
        public let name: String
        /// One of the following 2 letter country codes:   "AU" - AUSTRALIA   "DE" - GERMANY   "JP" - JAPAN   "US" - UNITED_STATES   "UK" - UNITED_KINGDOM  
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.name, name:"name", parent: name, max: 63)
            try validate(self.name, name:"name", parent: name, min: 1)
            try validate(self.name, name:"name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_]*")
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct UpdateDatasetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "DatasetArns", required: true, type: .list), 
            AWSShapeMember(label: "DatasetGroupArn", required: true, type: .string)
        ]

        /// An array of Amazon Resource Names (ARNs) of the datasets to add to the dataset group.
        public let datasetArns: [String]
        /// The ARN of the dataset group.
        public let datasetGroupArn: String

        public init(datasetArns: [String], datasetGroupArn: String) {
            self.datasetArns = datasetArns
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.datasetArns.forEach {
                try validate($0, name: "datasetArns[]", parent: name, max: 256)
                try validate($0, name: "datasetArns[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            }
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, max: 256)
            try validate(self.datasetGroupArn, name:"datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArns = "DatasetArns"
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct UpdateDatasetGroupResponse: AWSShape {


        public init() {
        }

    }

    public struct WeightedQuantileLoss: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LossValue", required: false, type: .double), 
            AWSShapeMember(label: "Quantile", required: false, type: .double)
        ]

        /// The difference between the predicted value and actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.
        public let lossValue: Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public let quantile: Double?

        public init(lossValue: Double? = nil, quantile: Double? = nil) {
            self.lossValue = lossValue
            self.quantile = quantile
        }

        private enum CodingKeys: String, CodingKey {
            case lossValue = "LossValue"
            case quantile = "Quantile"
        }
    }

    public struct WindowSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EvaluationType", required: false, type: .enum), 
            AWSShapeMember(label: "ItemCount", required: false, type: .integer), 
            AWSShapeMember(label: "Metrics", required: false, type: .structure), 
            AWSShapeMember(label: "TestWindowEnd", required: false, type: .timestamp), 
            AWSShapeMember(label: "TestWindowStart", required: false, type: .timestamp)
        ]

        /// The type of evaluation.    SUMMARY - The average metrics across all windows.    COMPUTED - The metrics for the specified window.  
        public let evaluationType: EvaluationType?
        /// The number of data points within the window.
        public let itemCount: Int?
        public let metrics: Metrics?
        /// The timestamp that defines the end of the window.
        public let testWindowEnd: TimeStamp?
        /// The timestamp that defines the start of the window.
        public let testWindowStart: TimeStamp?

        public init(evaluationType: EvaluationType? = nil, itemCount: Int? = nil, metrics: Metrics? = nil, testWindowEnd: TimeStamp? = nil, testWindowStart: TimeStamp? = nil) {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationType = "EvaluationType"
            case itemCount = "ItemCount"
            case metrics = "Metrics"
            case testWindowEnd = "TestWindowEnd"
            case testWindowStart = "TestWindowStart"
        }
    }
}

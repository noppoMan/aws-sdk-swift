// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension XRay {
    //MARK: Enums

    public enum EncryptionStatus: String, CustomStringConvertible, Codable {
        case updating = "UPDATING"
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum SamplingStrategyName: String, CustomStringConvertible, Codable {
        case partialscan = "PartialScan"
        case fixedrate = "FixedRate"
        public var description: String { return self.rawValue }
    }

    public enum TimeRangeType: String, CustomStringConvertible, Codable {
        case traceid = "TraceId"
        case event = "Event"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct Alias: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]

        /// The canonical name of the alias.
        public let name: String?
        /// A list of names for the alias, including the canonical name.
        public let names: [String]?
        /// The type of the alias.
        public let `type`: String?

        public init(name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.name = name
            self.names = names
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case names = "Names"
            case `type` = "Type"
        }
    }

    public struct AnnotationValue: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BooleanValue", required: false, type: .boolean), 
            AWSShapeMember(label: "NumberValue", required: false, type: .double), 
            AWSShapeMember(label: "StringValue", required: false, type: .string)
        ]

        /// Value for a Boolean annotation.
        public let booleanValue: Bool?
        /// Value for a Number annotation.
        public let numberValue: Double?
        /// Value for a String annotation.
        public let stringValue: String?

        public init(booleanValue: Bool? = nil, numberValue: Double? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.numberValue = numberValue
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "BooleanValue"
            case numberValue = "NumberValue"
            case stringValue = "StringValue"
        }
    }

    public struct AvailabilityZoneDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The name of a corresponding availability zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct BackendConnectionErrors: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ConnectionRefusedCount", required: false, type: .integer), 
            AWSShapeMember(label: "HTTPCode4XXCount", required: false, type: .integer), 
            AWSShapeMember(label: "HTTPCode5XXCount", required: false, type: .integer), 
            AWSShapeMember(label: "OtherCount", required: false, type: .integer), 
            AWSShapeMember(label: "TimeoutCount", required: false, type: .integer), 
            AWSShapeMember(label: "UnknownHostCount", required: false, type: .integer)
        ]

        public let connectionRefusedCount: Int?
        public let hTTPCode4XXCount: Int?
        public let hTTPCode5XXCount: Int?
        public let otherCount: Int?
        public let timeoutCount: Int?
        public let unknownHostCount: Int?

        public init(connectionRefusedCount: Int? = nil, hTTPCode4XXCount: Int? = nil, hTTPCode5XXCount: Int? = nil, otherCount: Int? = nil, timeoutCount: Int? = nil, unknownHostCount: Int? = nil) {
            self.connectionRefusedCount = connectionRefusedCount
            self.hTTPCode4XXCount = hTTPCode4XXCount
            self.hTTPCode5XXCount = hTTPCode5XXCount
            self.otherCount = otherCount
            self.timeoutCount = timeoutCount
            self.unknownHostCount = unknownHostCount
        }

        private enum CodingKeys: String, CodingKey {
            case connectionRefusedCount = "ConnectionRefusedCount"
            case hTTPCode4XXCount = "HTTPCode4XXCount"
            case hTTPCode5XXCount = "HTTPCode5XXCount"
            case otherCount = "OtherCount"
            case timeoutCount = "TimeoutCount"
            case unknownHostCount = "UnknownHostCount"
        }
    }

    public struct BatchGetTracesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TraceIds", required: true, type: .list)
        ]

        /// Pagination token.
        public let nextToken: String?
        /// Specify the trace IDs of requests for which to retrieve segments.
        public let traceIds: [String]

        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        public func validate(name: String) throws {
            try self.traceIds.forEach {
                try validate($0, name: "traceIds[]", parent: name, max: 35)
                try validate($0, name: "traceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct BatchGetTracesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Traces", required: false, type: .list), 
            AWSShapeMember(label: "UnprocessedTraceIds", required: false, type: .list)
        ]

        /// Pagination token.
        public let nextToken: String?
        /// Full traces for the specified requests.
        public let traces: [Trace]?
        /// Trace IDs of requests that haven't been processed.
        public let unprocessedTraceIds: [String]?

        public init(nextToken: String? = nil, traces: [Trace]? = nil, unprocessedTraceIds: [String]? = nil) {
            self.nextToken = nextToken
            self.traces = traces
            self.unprocessedTraceIds = unprocessedTraceIds
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traces = "Traces"
            case unprocessedTraceIds = "UnprocessedTraceIds"
        }
    }

    public struct CreateGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: true, type: .string), 
            AWSShapeMember(label: "InsightsConfiguration", required: false, type: .structure), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// The filter expression defining criteria by which to group traces.
        public let filterExpression: String?
        /// The case-sensitive name of the new group. Default is a reserved name and names must be unique.
        public let groupName: String
        /// The structure containing configurations related to insights. The InsightsEnabled boolean can be set to true to enable insights for the new group or false to disable insights for the new group.
        public let insightsConfiguration: InsightsConfiguration?
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray group. For more information about ways to use tags, see Tagging AWS resources in the AWS General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for AWS use.  
        public let tags: [Tag]?

        public init(filterExpression: String? = nil, groupName: String, insightsConfiguration: InsightsConfiguration? = nil, tags: [Tag]? = nil) {
            self.filterExpression = filterExpression
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.groupName, name:"groupName", parent: name, max: 32)
            try validate(self.groupName, name:"groupName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 200)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateGroupResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Group", required: false, type: .structure)
        ]

        /// The group that was created. Contains the name of the group that was created, the ARN of the group that was generated based on the group name, the filter expression, and the insight configuration that was assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct CreateSamplingRuleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRule", required: true, type: .structure), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// The rule definition.
        public let samplingRule: SamplingRule
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray sampling rule. For more information about ways to use tags, see Tagging AWS resources in the AWS General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for AWS use.  
        public let tags: [Tag]?

        public init(samplingRule: SamplingRule, tags: [Tag]? = nil) {
            self.samplingRule = samplingRule
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.samplingRule.validate(name: "\(name).samplingRule")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 200)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRule = "SamplingRule"
            case tags = "Tags"
        }
    }

    public struct CreateSamplingRuleResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleRecord", required: false, type: .structure)
        ]

        /// The saved rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct DeleteGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string)
        ]

        /// The ARN of the group that was generated on creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?

        public init(groupARN: String? = nil, groupName: String? = nil) {
            self.groupARN = groupARN
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try validate(self.groupARN, name:"groupARN", parent: name, max: 400)
            try validate(self.groupARN, name:"groupARN", parent: name, min: 1)
            try validate(self.groupName, name:"groupName", parent: name, max: 32)
            try validate(self.groupName, name:"groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct DeleteGroupResult: AWSShape {


        public init() {
        }

    }

    public struct DeleteSamplingRuleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "RuleARN", required: false, type: .string), 
            AWSShapeMember(label: "RuleName", required: false, type: .string)
        ]

        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?

        public init(ruleARN: String? = nil, ruleName: String? = nil) {
            self.ruleARN = ruleARN
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
        }
    }

    public struct DeleteSamplingRuleResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleRecord", required: false, type: .structure)
        ]

        /// The deleted rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct Edge: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Aliases", required: false, type: .list), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure)
        ]

        /// Aliases for the edge.
        public let aliases: [Alias]?
        /// The end time of the last segment on the edge.
        public let endTime: TimeStamp?
        /// Identifier of the edge. Unique within a service map.
        public let referenceId: Int?
        /// A histogram that maps the spread of client response times on an edge.
        public let responseTimeHistogram: [HistogramEntry]?
        /// The start time of the first segment on the edge.
        public let startTime: TimeStamp?
        /// Response statistics for segments on the edge.
        public let summaryStatistics: EdgeStatistics?

        public init(aliases: [Alias]? = nil, endTime: TimeStamp? = nil, referenceId: Int? = nil, responseTimeHistogram: [HistogramEntry]? = nil, startTime: TimeStamp? = nil, summaryStatistics: EdgeStatistics? = nil) {
            self.aliases = aliases
            self.endTime = endTime
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.startTime = startTime
            self.summaryStatistics = summaryStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case aliases = "Aliases"
            case endTime = "EndTime"
            case referenceId = "ReferenceId"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case startTime = "StartTime"
            case summaryStatistics = "SummaryStatistics"
        }
    }

    public struct EdgeStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "OkCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double)
        ]

        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?

        public init(errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, totalCount: Int64? = nil, totalResponseTime: Double? = nil) {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
            case totalResponseTime = "TotalResponseTime"
        }
    }

    public struct EncryptionConfig: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KeyId", required: false, type: .string), 
            AWSShapeMember(label: "Status", required: false, type: .enum), 
            AWSShapeMember(label: "Type", required: false, type: .enum)
        ]

        /// The ID of the customer master key (CMK) used for encryption, if applicable.
        public let keyId: String?
        /// The encryption status. While the status is UPDATING, X-Ray may encrypt data with a combination of the new and old settings.
        public let status: EncryptionStatus?
        /// The type of encryption. Set to KMS for encryption with CMKs. Set to NONE for default encryption.
        public let `type`: EncryptionType?

        public init(keyId: String? = nil, status: EncryptionStatus? = nil, type: EncryptionType? = nil) {
            self.keyId = keyId
            self.status = status
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case status = "Status"
            case `type` = "Type"
        }
    }

    public struct ErrorRootCause: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientImpacting", required: false, type: .boolean), 
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]

        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of services corresponding to an error. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [ErrorRootCauseService]?

        public init(clientImpacting: Bool? = nil, services: [ErrorRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct ErrorRootCauseEntity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Exceptions", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Remote", required: false, type: .boolean)
        ]

        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        public init(exceptions: [RootCauseException]? = nil, name: String? = nil, remote: Bool? = nil) {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct ErrorRootCauseService: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "EntityPath", required: false, type: .list), 
            AWSShapeMember(label: "Inferred", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]

        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service. 
        public let entityPath: [ErrorRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let `type`: String?

        public init(accountId: String? = nil, entityPath: [ErrorRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case `type` = "Type"
        }
    }

    public struct ErrorStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OtherCount", required: false, type: .long), 
            AWSShapeMember(label: "ThrottleCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]

        /// The number of requests that failed with untracked 4xx Client Error status codes.
        public let otherCount: Int64?
        /// The number of requests that failed with a 419 throttling status code.
        public let throttleCount: Int64?
        /// The total number of requests that failed with a 4xx Client Error status code.
        public let totalCount: Int64?

        public init(otherCount: Int64? = nil, throttleCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.throttleCount = throttleCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case throttleCount = "ThrottleCount"
            case totalCount = "TotalCount"
        }
    }

    public struct FaultRootCause: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientImpacting", required: false, type: .boolean), 
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]

        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of corresponding services. A service identifies a segment and it contains a name, account ID, type, and inferred flag.
        public let services: [FaultRootCauseService]?

        public init(clientImpacting: Bool? = nil, services: [FaultRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct FaultRootCauseEntity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Exceptions", required: false, type: .list), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Remote", required: false, type: .boolean)
        ]

        /// The types and messages of the exceptions.
        public let exceptions: [RootCauseException]?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        public init(exceptions: [RootCauseException]? = nil, name: String? = nil, remote: Bool? = nil) {
            self.exceptions = exceptions
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case exceptions = "Exceptions"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct FaultRootCauseService: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "EntityPath", required: false, type: .list), 
            AWSShapeMember(label: "Inferred", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]

        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service. 
        public let entityPath: [FaultRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let `type`: String?

        public init(accountId: String? = nil, entityPath: [FaultRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case `type` = "Type"
        }
    }

    public struct FaultStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "OtherCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long)
        ]

        /// The number of requests that failed with untracked 5xx Server Error status codes.
        public let otherCount: Int64?
        /// The total number of requests that failed with a 5xx Server Error status code.
        public let totalCount: Int64?

        public init(otherCount: Int64? = nil, totalCount: Int64? = nil) {
            self.otherCount = otherCount
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case otherCount = "OtherCount"
            case totalCount = "TotalCount"
        }
    }

    public struct GetEncryptionConfigRequest: AWSShape {


        public init() {
        }

    }

    public struct GetEncryptionConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure)
        ]

        /// The encryption configuration document.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct GetGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string)
        ]

        /// The ARN of the group that was generated on creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?

        public init(groupARN: String? = nil, groupName: String? = nil) {
            self.groupARN = groupARN
            self.groupName = groupName
        }

        public func validate(name: String) throws {
            try validate(self.groupARN, name:"groupARN", parent: name, max: 400)
            try validate(self.groupARN, name:"groupARN", parent: name, min: 1)
            try validate(self.groupName, name:"groupName", parent: name, max: 32)
            try validate(self.groupName, name:"groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupARN = "GroupARN"
            case groupName = "GroupName"
        }
    }

    public struct GetGroupResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Group", required: false, type: .structure)
        ]

        /// The group that was requested. Contains the name of the group, the ARN of the group, and the filter expression that assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct GetGroupsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Pagination token.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.nextToken, name:"nextToken", parent: name, max: 100)
            try validate(self.nextToken, name:"nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetGroupsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Groups", required: false, type: .list), 
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// The collection of all active groups.
        public let groups: [GroupSummary]?
        /// Pagination token.
        public let nextToken: String?

        public init(groups: [GroupSummary]? = nil, nextToken: String? = nil) {
            self.groups = groups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groups = "Groups"
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingRulesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Pagination token.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingRulesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SamplingRuleRecords", required: false, type: .list)
        ]

        /// Pagination token.
        public let nextToken: String?
        /// Rule definitions and metadata.
        public let samplingRuleRecords: [SamplingRuleRecord]?

        public init(nextToken: String? = nil, samplingRuleRecords: [SamplingRuleRecord]? = nil) {
            self.nextToken = nextToken
            self.samplingRuleRecords = samplingRuleRecords
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case samplingRuleRecords = "SamplingRuleRecords"
        }
    }

    public struct GetSamplingStatisticSummariesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string)
        ]

        /// Pagination token.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
        }
    }

    public struct GetSamplingStatisticSummariesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "SamplingStatisticSummaries", required: false, type: .list)
        ]

        /// Pagination token.
        public let nextToken: String?
        /// Information about the number of requests instrumented for each sampling rule.
        public let samplingStatisticSummaries: [SamplingStatisticSummary]?

        public init(nextToken: String? = nil, samplingStatisticSummaries: [SamplingStatisticSummary]? = nil) {
            self.nextToken = nextToken
            self.samplingStatisticSummaries = samplingStatisticSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case samplingStatisticSummaries = "SamplingStatisticSummaries"
        }
    }

    public struct GetSamplingTargetsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingStatisticsDocuments", required: true, type: .list)
        ]

        /// Information about rules that the service is using to sample requests.
        public let samplingStatisticsDocuments: [SamplingStatisticsDocument]

        public init(samplingStatisticsDocuments: [SamplingStatisticsDocument]) {
            self.samplingStatisticsDocuments = samplingStatisticsDocuments
        }

        public func validate(name: String) throws {
            try self.samplingStatisticsDocuments.forEach {
                try $0.validate(name: "\(name).samplingStatisticsDocuments[]")
            }
            try validate(self.samplingStatisticsDocuments, name:"samplingStatisticsDocuments", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
        }
    }

    public struct GetSamplingTargetsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "LastRuleModification", required: false, type: .timestamp), 
            AWSShapeMember(label: "SamplingTargetDocuments", required: false, type: .list), 
            AWSShapeMember(label: "UnprocessedStatistics", required: false, type: .list)
        ]

        /// The last time a user changed the sampling rule configuration. If the sampling rule configuration changed since the service last retrieved it, the service should call GetSamplingRules to get the latest version.
        public let lastRuleModification: TimeStamp?
        /// Updated rules that the service should use to sample requests.
        public let samplingTargetDocuments: [SamplingTargetDocument]?
        /// Information about SamplingStatisticsDocument that X-Ray could not process.
        public let unprocessedStatistics: [UnprocessedStatistics]?

        public init(lastRuleModification: TimeStamp? = nil, samplingTargetDocuments: [SamplingTargetDocument]? = nil, unprocessedStatistics: [UnprocessedStatistics]? = nil) {
            self.lastRuleModification = lastRuleModification
            self.samplingTargetDocuments = samplingTargetDocuments
            self.unprocessedStatistics = unprocessedStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case lastRuleModification = "LastRuleModification"
            case samplingTargetDocuments = "SamplingTargetDocuments"
            case unprocessedStatistics = "UnprocessedStatistics"
        }
    }

    public struct GetServiceGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp)
        ]

        /// The end of the timeframe for which to generate a graph.
        public let endTime: TimeStamp
        /// The ARN of a group to generate a graph based on.
        public let groupARN: String?
        /// The name of a group to generate a graph based on.
        public let groupName: String?
        /// Pagination token.
        public let nextToken: String?
        /// The start of the time frame for which to generate a graph.
        public let startTime: TimeStamp

        public init(endTime: TimeStamp, groupARN: String? = nil, groupName: String? = nil, nextToken: String? = nil, startTime: TimeStamp) {
            self.endTime = endTime
            self.groupARN = groupARN
            self.groupName = groupName
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try validate(self.groupARN, name:"groupARN", parent: name, max: 400)
            try validate(self.groupARN, name:"groupARN", parent: name, min: 1)
            try validate(self.groupName, name:"groupName", parent: name, max: 32)
            try validate(self.groupName, name:"groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetServiceGraphResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainsOldGroupVersions", required: false, type: .boolean), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Services", required: false, type: .list), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp)
        ]

        /// A flag indicating whether the group's filter expression has been consistent, or if the returned service graph may show traces from an older version of the group's filter expression.
        public let containsOldGroupVersions: Bool?
        /// The end of the time frame for which the graph was generated.
        public let endTime: TimeStamp?
        /// Pagination token.
        public let nextToken: String?
        /// The services that have processed a traced request during the specified time frame.
        public let services: [Service]?
        /// The start of the time frame for which the graph was generated.
        public let startTime: TimeStamp?

        public init(containsOldGroupVersions: Bool? = nil, endTime: TimeStamp? = nil, nextToken: String? = nil, services: [Service]? = nil, startTime: TimeStamp? = nil) {
            self.containsOldGroupVersions = containsOldGroupVersions
            self.endTime = endTime
            self.nextToken = nextToken
            self.services = services
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case containsOldGroupVersions = "ContainsOldGroupVersions"
            case endTime = "EndTime"
            case nextToken = "NextToken"
            case services = "Services"
            case startTime = "StartTime"
        }
    }

    public struct GetTimeSeriesServiceStatisticsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "EntitySelectorExpression", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Period", required: false, type: .integer), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp)
        ]

        /// The end of the time frame for which to aggregate statistics.
        public let endTime: TimeStamp
        /// A filter expression defining entities that will be aggregated for statistics. Supports ID, service, and edge functions. If no selector expression is specified, edge statistics are returned. 
        public let entitySelectorExpression: String?
        /// The ARN of the group for which to pull statistics from.
        public let groupARN: String?
        /// The case-sensitive name of the group for which to pull statistics from.
        public let groupName: String?
        /// Pagination token.
        public let nextToken: String?
        /// Aggregation period in seconds.
        public let period: Int?
        /// The start of the time frame for which to aggregate statistics.
        public let startTime: TimeStamp

        public init(endTime: TimeStamp, entitySelectorExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, nextToken: String? = nil, period: Int? = nil, startTime: TimeStamp) {
            self.endTime = endTime
            self.entitySelectorExpression = entitySelectorExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.nextToken = nextToken
            self.period = period
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try validate(self.entitySelectorExpression, name:"entitySelectorExpression", parent: name, max: 500)
            try validate(self.entitySelectorExpression, name:"entitySelectorExpression", parent: name, min: 1)
            try validate(self.groupARN, name:"groupARN", parent: name, max: 400)
            try validate(self.groupARN, name:"groupARN", parent: name, min: 1)
            try validate(self.groupName, name:"groupName", parent: name, max: 32)
            try validate(self.groupName, name:"groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case entitySelectorExpression = "EntitySelectorExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case nextToken = "NextToken"
            case period = "Period"
            case startTime = "StartTime"
        }
    }

    public struct GetTimeSeriesServiceStatisticsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ContainsOldGroupVersions", required: false, type: .boolean), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TimeSeriesServiceStatistics", required: false, type: .list)
        ]

        /// A flag indicating whether or not a group's filter expression has been consistent, or if a returned aggregation may show statistics from an older version of the group's filter expression.
        public let containsOldGroupVersions: Bool?
        /// Pagination token.
        public let nextToken: String?
        /// The collection of statistics.
        public let timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]?

        public init(containsOldGroupVersions: Bool? = nil, nextToken: String? = nil, timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]? = nil) {
            self.containsOldGroupVersions = containsOldGroupVersions
            self.nextToken = nextToken
            self.timeSeriesServiceStatistics = timeSeriesServiceStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case containsOldGroupVersions = "ContainsOldGroupVersions"
            case nextToken = "NextToken"
            case timeSeriesServiceStatistics = "TimeSeriesServiceStatistics"
        }
    }

    public struct GetTraceGraphRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TraceIds", required: true, type: .list)
        ]

        /// Pagination token.
        public let nextToken: String?
        /// Trace IDs of requests for which to generate a service graph.
        public let traceIds: [String]

        public init(nextToken: String? = nil, traceIds: [String]) {
            self.nextToken = nextToken
            self.traceIds = traceIds
        }

        public func validate(name: String) throws {
            try self.traceIds.forEach {
                try validate($0, name: "traceIds[]", parent: name, max: 35)
                try validate($0, name: "traceIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case traceIds = "TraceIds"
        }
    }

    public struct GetTraceGraphResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]

        /// Pagination token.
        public let nextToken: String?
        /// The services that have processed one of the specified requests.
        public let services: [Service]?

        public init(nextToken: String? = nil, services: [Service]? = nil) {
            self.nextToken = nextToken
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case services = "Services"
        }
    }

    public struct GetTraceSummariesRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EndTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Sampling", required: false, type: .boolean), 
            AWSShapeMember(label: "SamplingStrategy", required: false, type: .structure), 
            AWSShapeMember(label: "StartTime", required: true, type: .timestamp), 
            AWSShapeMember(label: "TimeRangeType", required: false, type: .enum)
        ]

        /// The end of the time frame for which to retrieve traces.
        public let endTime: TimeStamp
        /// Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.
        public let filterExpression: String?
        /// Specify the pagination token returned by a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// Set to true to get summaries for only a subset of available traces.
        public let sampling: Bool?
        /// A paramater to indicate whether to enable sampling on trace summaries. Input parameters are Name and Value.
        public let samplingStrategy: SamplingStrategy?
        /// The start of the time frame for which to retrieve traces.
        public let startTime: TimeStamp
        /// A parameter to indicate whether to query trace summaries by TraceId or Event time.
        public let timeRangeType: TimeRangeType?

        public init(endTime: TimeStamp, filterExpression: String? = nil, nextToken: String? = nil, sampling: Bool? = nil, samplingStrategy: SamplingStrategy? = nil, startTime: TimeStamp, timeRangeType: TimeRangeType? = nil) {
            self.endTime = endTime
            self.filterExpression = filterExpression
            self.nextToken = nextToken
            self.sampling = sampling
            self.samplingStrategy = samplingStrategy
            self.startTime = startTime
            self.timeRangeType = timeRangeType
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filterExpression = "FilterExpression"
            case nextToken = "NextToken"
            case sampling = "Sampling"
            case samplingStrategy = "SamplingStrategy"
            case startTime = "StartTime"
            case timeRangeType = "TimeRangeType"
        }
    }

    public struct GetTraceSummariesResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ApproximateTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "TracesProcessedCount", required: false, type: .long), 
            AWSShapeMember(label: "TraceSummaries", required: false, type: .list)
        ]

        /// The start time of this page of results.
        public let approximateTime: TimeStamp?
        /// If the requested time frame contained more than one page of results, you can use this token to retrieve the next page. The first page contains the most most recent results, closest to the end of the time frame.
        public let nextToken: String?
        /// The total number of traces processed, including traces that did not match the specified filter expression.
        public let tracesProcessedCount: Int64?
        /// Trace IDs and annotations for traces that were found in the specified time frame.
        public let traceSummaries: [TraceSummary]?

        public init(approximateTime: TimeStamp? = nil, nextToken: String? = nil, tracesProcessedCount: Int64? = nil, traceSummaries: [TraceSummary]? = nil) {
            self.approximateTime = approximateTime
            self.nextToken = nextToken
            self.tracesProcessedCount = tracesProcessedCount
            self.traceSummaries = traceSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTime = "ApproximateTime"
            case nextToken = "NextToken"
            case tracesProcessedCount = "TracesProcessedCount"
            case traceSummaries = "TraceSummaries"
        }
    }

    public struct Group: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "InsightsConfiguration", required: false, type: .structure)
        ]

        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?
        /// The ARN of the group generated based on the GroupName.
        public let groupARN: String?
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights. The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
        public let insightsConfiguration: InsightsConfiguration?

        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct GroupSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "InsightsConfiguration", required: false, type: .structure)
        ]

        /// The filter expression defining the parameters to include traces.
        public let filterExpression: String?
        /// The ARN of the group generated based on the GroupName.
        public let groupARN: String?
        /// The unique case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights. The InsightsEnabled boolean can be set to true to enable insights for the groups or false to disable insights for the groups.
        public let insightsConfiguration: InsightsConfiguration?

        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct HistogramEntry: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Count", required: false, type: .integer), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]

        /// The prevalence of the entry.
        public let count: Int?
        /// The value of the entry.
        public let value: Double?

        public init(count: Int? = nil, value: Double? = nil) {
            self.count = count
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case value = "Value"
        }
    }

    public struct Http: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientIp", required: false, type: .string), 
            AWSShapeMember(label: "HttpMethod", required: false, type: .string), 
            AWSShapeMember(label: "HttpStatus", required: false, type: .integer), 
            AWSShapeMember(label: "HttpURL", required: false, type: .string), 
            AWSShapeMember(label: "UserAgent", required: false, type: .string)
        ]

        /// The IP address of the requestor.
        public let clientIp: String?
        /// The request method.
        public let httpMethod: String?
        /// The response status.
        public let httpStatus: Int?
        /// The request URL.
        public let httpURL: String?
        /// The request's user agent string.
        public let userAgent: String?

        public init(clientIp: String? = nil, httpMethod: String? = nil, httpStatus: Int? = nil, httpURL: String? = nil, userAgent: String? = nil) {
            self.clientIp = clientIp
            self.httpMethod = httpMethod
            self.httpStatus = httpStatus
            self.httpURL = httpURL
            self.userAgent = userAgent
        }

        private enum CodingKeys: String, CodingKey {
            case clientIp = "ClientIp"
            case httpMethod = "HttpMethod"
            case httpStatus = "HttpStatus"
            case httpURL = "HttpURL"
            case userAgent = "UserAgent"
        }
    }

    public struct InsightsConfiguration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "InsightsEnabled", required: false, type: .boolean)
        ]

        /// Set the InsightsEnabled value to true to enable insights or false to disable insights.
        public let insightsEnabled: Bool?

        public init(insightsEnabled: Bool? = nil) {
            self.insightsEnabled = insightsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case insightsEnabled = "InsightsEnabled"
        }
    }

    public struct InstanceIdDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]

        /// The ID of a corresponding EC2 instance.
        public let id: String?

        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct ListTagsForResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "ResourceARN", required: true, type: .string)
        ]

        /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results as the value of this parameter to get the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String

        public init(nextToken: String? = nil, resourceARN: String) {
            self.nextToken = nextToken
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try validate(self.resourceARN, name:"resourceARN", parent: name, max: 1011)
            try validate(self.resourceARN, name:"resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case resourceARN = "ResourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "NextToken", required: false, type: .string), 
            AWSShapeMember(label: "Tags", required: false, type: .list)
        ]

        /// A pagination token. If multiple pages of results are returned, use the NextToken value returned with the current page of results to get the next page of results.
        public let nextToken: String?
        /// A list of tags, as key and value pairs, that is associated with the specified X-Ray group or sampling rule.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct PutEncryptionConfigRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "KeyId", required: false, type: .string), 
            AWSShapeMember(label: "Type", required: true, type: .enum)
        ]

        /// An AWS KMS customer master key (CMK) in one of the following formats:    Alias - The name of the key. For example, alias/MyKey.    Key ID - The KMS key ID of the key. For example, ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. AWS X-Ray does not support asymmetric CMKs.    ARN - The full Amazon Resource Name of the key ID or alias. For example, arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456. Use this format to specify a key in a different account.   Omit this key if you set Type to NONE.
        public let keyId: String?
        /// The type of encryption. Set to KMS to use your own key for encryption. Set to NONE for default encryption.
        public let `type`: EncryptionType

        public init(keyId: String? = nil, type: EncryptionType) {
            self.keyId = keyId
            self.`type` = `type`
        }

        public func validate(name: String) throws {
            try validate(self.keyId, name:"keyId", parent: name, max: 3000)
            try validate(self.keyId, name:"keyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
            case `type` = "Type"
        }
    }

    public struct PutEncryptionConfigResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EncryptionConfig", required: false, type: .structure)
        ]

        /// The new encryption configuration.
        public let encryptionConfig: EncryptionConfig?

        public init(encryptionConfig: EncryptionConfig? = nil) {
            self.encryptionConfig = encryptionConfig
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct PutTelemetryRecordsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EC2InstanceId", required: false, type: .string), 
            AWSShapeMember(label: "Hostname", required: false, type: .string), 
            AWSShapeMember(label: "ResourceARN", required: false, type: .string), 
            AWSShapeMember(label: "TelemetryRecords", required: true, type: .list)
        ]

        public let eC2InstanceId: String?
        public let hostname: String?
        public let resourceARN: String?
        public let telemetryRecords: [TelemetryRecord]

        public init(eC2InstanceId: String? = nil, hostname: String? = nil, resourceARN: String? = nil, telemetryRecords: [TelemetryRecord]) {
            self.eC2InstanceId = eC2InstanceId
            self.hostname = hostname
            self.resourceARN = resourceARN
            self.telemetryRecords = telemetryRecords
        }

        public func validate(name: String) throws {
            try validate(self.eC2InstanceId, name:"eC2InstanceId", parent: name, max: 20)
            try validate(self.hostname, name:"hostname", parent: name, max: 255)
            try validate(self.resourceARN, name:"resourceARN", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case eC2InstanceId = "EC2InstanceId"
            case hostname = "Hostname"
            case resourceARN = "ResourceARN"
            case telemetryRecords = "TelemetryRecords"
        }
    }

    public struct PutTelemetryRecordsResult: AWSShape {


        public init() {
        }

    }

    public struct PutTraceSegmentsRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "TraceSegmentDocuments", required: true, type: .list)
        ]

        /// A string containing a JSON document defining one or more segments or subsegments.
        public let traceSegmentDocuments: [String]

        public init(traceSegmentDocuments: [String]) {
            self.traceSegmentDocuments = traceSegmentDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case traceSegmentDocuments = "TraceSegmentDocuments"
        }
    }

    public struct PutTraceSegmentsResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "UnprocessedTraceSegments", required: false, type: .list)
        ]

        /// Segments that failed processing.
        public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

        public init(unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil) {
            self.unprocessedTraceSegments = unprocessedTraceSegments
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedTraceSegments = "UnprocessedTraceSegments"
        }
    }

    public struct ResourceARNDetail: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ARN", required: false, type: .string)
        ]

        /// The ARN of a corresponding resource.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
        }
    }

    public struct ResponseTimeRootCause: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ClientImpacting", required: false, type: .boolean), 
            AWSShapeMember(label: "Services", required: false, type: .list)
        ]

        /// A flag that denotes that the root cause impacts the trace client.
        public let clientImpacting: Bool?
        /// A list of corresponding services. A service identifies a segment and contains a name, account ID, type, and inferred flag.
        public let services: [ResponseTimeRootCauseService]?

        public init(clientImpacting: Bool? = nil, services: [ResponseTimeRootCauseService]? = nil) {
            self.clientImpacting = clientImpacting
            self.services = services
        }

        private enum CodingKeys: String, CodingKey {
            case clientImpacting = "ClientImpacting"
            case services = "Services"
        }
    }

    public struct ResponseTimeRootCauseEntity: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Coverage", required: false, type: .double), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Remote", required: false, type: .boolean)
        ]

        /// The types and messages of the exceptions.
        public let coverage: Double?
        /// The name of the entity.
        public let name: String?
        /// A flag that denotes a remote subsegment.
        public let remote: Bool?

        public init(coverage: Double? = nil, name: String? = nil, remote: Bool? = nil) {
            self.coverage = coverage
            self.name = name
            self.remote = remote
        }

        private enum CodingKeys: String, CodingKey {
            case coverage = "Coverage"
            case name = "Name"
            case remote = "Remote"
        }
    }

    public struct ResponseTimeRootCauseService: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "EntityPath", required: false, type: .list), 
            AWSShapeMember(label: "Inferred", required: false, type: .boolean), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]

        /// The account ID associated to the service.
        public let accountId: String?
        /// The path of root cause entities found on the service. 
        public let entityPath: [ResponseTimeRootCauseEntity]?
        /// A Boolean value indicating if the service is inferred from the trace.
        public let inferred: Bool?
        /// The service name.
        public let name: String?
        /// A collection of associated service names.
        public let names: [String]?
        /// The type associated to the service.
        public let `type`: String?

        public init(accountId: String? = nil, entityPath: [ResponseTimeRootCauseEntity]? = nil, inferred: Bool? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.entityPath = entityPath
            self.inferred = inferred
            self.name = name
            self.names = names
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case entityPath = "EntityPath"
            case inferred = "Inferred"
            case name = "Name"
            case names = "Names"
            case `type` = "Type"
        }
    }

    public struct RootCauseException: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string)
        ]

        /// The message of the exception.
        public let message: String?
        /// The name of the exception.
        public let name: String?

        public init(message: String? = nil, name: String? = nil) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case name = "Name"
        }
    }

    public struct SamplingRule: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "FixedRate", required: true, type: .double), 
            AWSShapeMember(label: "Host", required: true, type: .string), 
            AWSShapeMember(label: "HTTPMethod", required: true, type: .string), 
            AWSShapeMember(label: "Priority", required: true, type: .integer), 
            AWSShapeMember(label: "ReservoirSize", required: true, type: .integer), 
            AWSShapeMember(label: "ResourceARN", required: true, type: .string), 
            AWSShapeMember(label: "RuleARN", required: false, type: .string), 
            AWSShapeMember(label: "RuleName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceName", required: true, type: .string), 
            AWSShapeMember(label: "ServiceType", required: true, type: .string), 
            AWSShapeMember(label: "URLPath", required: true, type: .string), 
            AWSShapeMember(label: "Version", required: true, type: .integer)
        ]

        /// Matches attributes derived from the request.
        public let attributes: [String: String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double
        /// Matches the hostname from a request URL.
        public let host: String
        /// Matches the HTTP method of a request.
        public let hTTPMethod: String
        /// The priority of the sampling rule.
        public let priority: Int
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int
        /// Matches the ARN of the AWS resource on which the service runs.
        public let resourceARN: String
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String
        /// Matches the path from a request URL.
        public let uRLPath: String
        /// The version of the sampling rule format (1).
        public let version: Int

        public init(attributes: [String: String]? = nil, fixedRate: Double, host: String, hTTPMethod: String, priority: Int, reservoirSize: Int, resourceARN: String, ruleARN: String? = nil, ruleName: String? = nil, serviceName: String, serviceType: String, uRLPath: String, version: Int) {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.hTTPMethod = hTTPMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.uRLPath = uRLPath
            self.version = version
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name:"attributes.key", parent: name, max: 32)
                try validate($0.key, name:"attributes.key", parent: name, min: 1)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, max: 32)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try validate(self.fixedRate, name:"fixedRate", parent: name, max: 1)
            try validate(self.fixedRate, name:"fixedRate", parent: name, min: 0)
            try validate(self.host, name:"host", parent: name, max: 64)
            try validate(self.hTTPMethod, name:"hTTPMethod", parent: name, max: 10)
            try validate(self.priority, name:"priority", parent: name, max: 9999)
            try validate(self.priority, name:"priority", parent: name, min: 1)
            try validate(self.reservoirSize, name:"reservoirSize", parent: name, min: 0)
            try validate(self.resourceARN, name:"resourceARN", parent: name, max: 500)
            try validate(self.ruleName, name:"ruleName", parent: name, max: 32)
            try validate(self.ruleName, name:"ruleName", parent: name, min: 1)
            try validate(self.serviceName, name:"serviceName", parent: name, max: 64)
            try validate(self.serviceType, name:"serviceType", parent: name, max: 64)
            try validate(self.uRLPath, name:"uRLPath", parent: name, max: 128)
            try validate(self.version, name:"version", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case fixedRate = "FixedRate"
            case host = "Host"
            case hTTPMethod = "HTTPMethod"
            case priority = "Priority"
            case reservoirSize = "ReservoirSize"
            case resourceARN = "ResourceARN"
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
            case serviceName = "ServiceName"
            case serviceType = "ServiceType"
            case uRLPath = "URLPath"
            case version = "Version"
        }
    }

    public struct SamplingRuleRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "CreatedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "ModifiedAt", required: false, type: .timestamp), 
            AWSShapeMember(label: "SamplingRule", required: false, type: .structure)
        ]

        /// When the rule was created.
        public let createdAt: TimeStamp?
        /// When the rule was last modified.
        public let modifiedAt: TimeStamp?
        /// The sampling rule.
        public let samplingRule: SamplingRule?

        public init(createdAt: TimeStamp? = nil, modifiedAt: TimeStamp? = nil, samplingRule: SamplingRule? = nil) {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.samplingRule = samplingRule
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case modifiedAt = "ModifiedAt"
            case samplingRule = "SamplingRule"
        }
    }

    public struct SamplingRuleUpdate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Attributes", required: false, type: .map), 
            AWSShapeMember(label: "FixedRate", required: false, type: .double), 
            AWSShapeMember(label: "Host", required: false, type: .string), 
            AWSShapeMember(label: "HTTPMethod", required: false, type: .string), 
            AWSShapeMember(label: "Priority", required: false, type: .integer), 
            AWSShapeMember(label: "ReservoirSize", required: false, type: .integer), 
            AWSShapeMember(label: "ResourceARN", required: false, type: .string), 
            AWSShapeMember(label: "RuleARN", required: false, type: .string), 
            AWSShapeMember(label: "RuleName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceName", required: false, type: .string), 
            AWSShapeMember(label: "ServiceType", required: false, type: .string), 
            AWSShapeMember(label: "URLPath", required: false, type: .string)
        ]

        /// Matches attributes derived from the request.
        public let attributes: [String: String]?
        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// Matches the hostname from a request URL.
        public let host: String?
        /// Matches the HTTP method of a request.
        public let hTTPMethod: String?
        /// The priority of the sampling rule.
        public let priority: Int?
        /// A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        public let reservoirSize: Int?
        /// Matches the ARN of the AWS resource on which the service runs.
        public let resourceARN: String?
        /// The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleARN: String?
        /// The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        public let ruleName: String?
        /// Matches the name that the service uses to identify itself in segments.
        public let serviceName: String?
        /// Matches the origin that the service uses to identify its type in segments.
        public let serviceType: String?
        /// Matches the path from a request URL.
        public let uRLPath: String?

        public init(attributes: [String: String]? = nil, fixedRate: Double? = nil, host: String? = nil, hTTPMethod: String? = nil, priority: Int? = nil, reservoirSize: Int? = nil, resourceARN: String? = nil, ruleARN: String? = nil, ruleName: String? = nil, serviceName: String? = nil, serviceType: String? = nil, uRLPath: String? = nil) {
            self.attributes = attributes
            self.fixedRate = fixedRate
            self.host = host
            self.hTTPMethod = hTTPMethod
            self.priority = priority
            self.reservoirSize = reservoirSize
            self.resourceARN = resourceARN
            self.ruleARN = ruleARN
            self.ruleName = ruleName
            self.serviceName = serviceName
            self.serviceType = serviceType
            self.uRLPath = uRLPath
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name:"attributes.key", parent: name, max: 32)
                try validate($0.key, name:"attributes.key", parent: name, min: 1)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, max: 32)
                try validate($0.value, name:"attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try validate(self.host, name:"host", parent: name, max: 64)
            try validate(self.hTTPMethod, name:"hTTPMethod", parent: name, max: 10)
            try validate(self.resourceARN, name:"resourceARN", parent: name, max: 500)
            try validate(self.ruleName, name:"ruleName", parent: name, max: 32)
            try validate(self.ruleName, name:"ruleName", parent: name, min: 1)
            try validate(self.serviceName, name:"serviceName", parent: name, max: 64)
            try validate(self.serviceType, name:"serviceType", parent: name, max: 64)
            try validate(self.uRLPath, name:"uRLPath", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case fixedRate = "FixedRate"
            case host = "Host"
            case hTTPMethod = "HTTPMethod"
            case priority = "Priority"
            case reservoirSize = "ReservoirSize"
            case resourceARN = "ResourceARN"
            case ruleARN = "RuleARN"
            case ruleName = "RuleName"
            case serviceName = "ServiceName"
            case serviceType = "ServiceType"
            case uRLPath = "URLPath"
        }
    }

    public struct SamplingStatisticSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BorrowCount", required: false, type: .integer), 
            AWSShapeMember(label: "RequestCount", required: false, type: .integer), 
            AWSShapeMember(label: "RuleName", required: false, type: .string), 
            AWSShapeMember(label: "SampledCount", required: false, type: .integer), 
            AWSShapeMember(label: "Timestamp", required: false, type: .timestamp)
        ]

        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int?
        /// The number of requests that matched the rule.
        public let requestCount: Int?
        /// The name of the sampling rule.
        public let ruleName: String?
        /// The number of requests recorded.
        public let sampledCount: Int?
        /// The start time of the reporting window.
        public let timestamp: TimeStamp?

        public init(borrowCount: Int? = nil, requestCount: Int? = nil, ruleName: String? = nil, sampledCount: Int? = nil, timestamp: TimeStamp? = nil) {
            self.borrowCount = borrowCount
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case borrowCount = "BorrowCount"
            case requestCount = "RequestCount"
            case ruleName = "RuleName"
            case sampledCount = "SampledCount"
            case timestamp = "Timestamp"
        }
    }

    public struct SamplingStatisticsDocument: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BorrowCount", required: false, type: .integer), 
            AWSShapeMember(label: "ClientID", required: true, type: .string), 
            AWSShapeMember(label: "RequestCount", required: true, type: .integer), 
            AWSShapeMember(label: "RuleName", required: true, type: .string), 
            AWSShapeMember(label: "SampledCount", required: true, type: .integer), 
            AWSShapeMember(label: "Timestamp", required: true, type: .timestamp)
        ]

        /// The number of requests recorded with borrowed reservoir quota.
        public let borrowCount: Int?
        /// A unique identifier for the service in hexadecimal.
        public let clientID: String
        /// The number of requests that matched the rule.
        public let requestCount: Int
        /// The name of the sampling rule.
        public let ruleName: String
        /// The number of requests recorded.
        public let sampledCount: Int
        /// The current time.
        public let timestamp: TimeStamp

        public init(borrowCount: Int? = nil, clientID: String, requestCount: Int, ruleName: String, sampledCount: Int, timestamp: TimeStamp) {
            self.borrowCount = borrowCount
            self.clientID = clientID
            self.requestCount = requestCount
            self.ruleName = ruleName
            self.sampledCount = sampledCount
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try validate(self.borrowCount, name:"borrowCount", parent: name, min: 0)
            try validate(self.clientID, name:"clientID", parent: name, max: 24)
            try validate(self.clientID, name:"clientID", parent: name, min: 24)
            try validate(self.requestCount, name:"requestCount", parent: name, min: 0)
            try validate(self.ruleName, name:"ruleName", parent: name, max: 32)
            try validate(self.ruleName, name:"ruleName", parent: name, min: 1)
            try validate(self.sampledCount, name:"sampledCount", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case borrowCount = "BorrowCount"
            case clientID = "ClientID"
            case requestCount = "RequestCount"
            case ruleName = "RuleName"
            case sampledCount = "SampledCount"
            case timestamp = "Timestamp"
        }
    }

    public struct SamplingStrategy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Name", required: false, type: .enum), 
            AWSShapeMember(label: "Value", required: false, type: .double)
        ]

        /// The name of a sampling rule.
        public let name: SamplingStrategyName?
        /// The value of a sampling rule.
        public let value: Double?

        public init(name: SamplingStrategyName? = nil, value: Double? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct SamplingTargetDocument: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FixedRate", required: false, type: .double), 
            AWSShapeMember(label: "Interval", required: false, type: .integer), 
            AWSShapeMember(label: "ReservoirQuota", required: false, type: .integer), 
            AWSShapeMember(label: "ReservoirQuotaTTL", required: false, type: .timestamp), 
            AWSShapeMember(label: "RuleName", required: false, type: .string)
        ]

        /// The percentage of matching requests to instrument, after the reservoir is exhausted.
        public let fixedRate: Double?
        /// The number of seconds for the service to wait before getting sampling targets again.
        public let interval: Int?
        /// The number of requests per second that X-Ray allocated this service.
        public let reservoirQuota: Int?
        /// When the reservoir quota expires.
        public let reservoirQuotaTTL: TimeStamp?
        /// The name of the sampling rule.
        public let ruleName: String?

        public init(fixedRate: Double? = nil, interval: Int? = nil, reservoirQuota: Int? = nil, reservoirQuotaTTL: TimeStamp? = nil, ruleName: String? = nil) {
            self.fixedRate = fixedRate
            self.interval = interval
            self.reservoirQuota = reservoirQuota
            self.reservoirQuotaTTL = reservoirQuotaTTL
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case fixedRate = "FixedRate"
            case interval = "Interval"
            case reservoirQuota = "ReservoirQuota"
            case reservoirQuotaTTL = "ReservoirQuotaTTL"
            case ruleName = "RuleName"
        }
    }

    public struct Segment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Document", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string)
        ]

        /// The segment document.
        public let document: String?
        /// The segment's ID.
        public let id: String?

        public init(document: String? = nil, id: String? = nil) {
            self.document = document
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case document = "Document"
            case id = "Id"
        }
    }

    public struct Service: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "DurationHistogram", required: false, type: .list), 
            AWSShapeMember(label: "Edges", required: false, type: .list), 
            AWSShapeMember(label: "EndTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "ReferenceId", required: false, type: .integer), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeMember(label: "Root", required: false, type: .boolean), 
            AWSShapeMember(label: "StartTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "State", required: false, type: .string), 
            AWSShapeMember(label: "SummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]

        /// Identifier of the AWS account in which the service runs.
        public let accountId: String?
        /// A histogram that maps the spread of service durations.
        public let durationHistogram: [HistogramEntry]?
        /// Connections to downstream services.
        public let edges: [Edge]?
        /// The end time of the last segment that the service generated.
        public let endTime: TimeStamp?
        /// The canonical name of the service.
        public let name: String?
        /// A list of names for the service, including the canonical name.
        public let names: [String]?
        /// Identifier for the service. Unique within the service map.
        public let referenceId: Int?
        /// A histogram that maps the spread of service response times.
        public let responseTimeHistogram: [HistogramEntry]?
        /// Indicates that the service was the first service to process a request.
        public let root: Bool?
        /// The start time of the first segment that the service generated.
        public let startTime: TimeStamp?
        /// The service's state.
        public let state: String?
        /// Aggregated statistics for the service.
        public let summaryStatistics: ServiceStatistics?
        /// The type of service.   AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for a application running on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used.   AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon DynamoDB that didn't target a specific table.    client - Represents the clients that sent requests to a root service.    remote - A downstream service of indeterminate type.  
        public let `type`: String?

        public init(accountId: String? = nil, durationHistogram: [HistogramEntry]? = nil, edges: [Edge]? = nil, endTime: TimeStamp? = nil, name: String? = nil, names: [String]? = nil, referenceId: Int? = nil, responseTimeHistogram: [HistogramEntry]? = nil, root: Bool? = nil, startTime: TimeStamp? = nil, state: String? = nil, summaryStatistics: ServiceStatistics? = nil, type: String? = nil) {
            self.accountId = accountId
            self.durationHistogram = durationHistogram
            self.edges = edges
            self.endTime = endTime
            self.name = name
            self.names = names
            self.referenceId = referenceId
            self.responseTimeHistogram = responseTimeHistogram
            self.root = root
            self.startTime = startTime
            self.state = state
            self.summaryStatistics = summaryStatistics
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case durationHistogram = "DurationHistogram"
            case edges = "Edges"
            case endTime = "EndTime"
            case name = "Name"
            case names = "Names"
            case referenceId = "ReferenceId"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case root = "Root"
            case startTime = "StartTime"
            case state = "State"
            case summaryStatistics = "SummaryStatistics"
            case `type` = "Type"
        }
    }

    public struct ServiceId: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AccountId", required: false, type: .string), 
            AWSShapeMember(label: "Name", required: false, type: .string), 
            AWSShapeMember(label: "Names", required: false, type: .list), 
            AWSShapeMember(label: "Type", required: false, type: .string)
        ]

        public let accountId: String?
        public let name: String?
        public let names: [String]?
        public let `type`: String?

        public init(accountId: String? = nil, name: String? = nil, names: [String]? = nil, type: String? = nil) {
            self.accountId = accountId
            self.name = name
            self.names = names
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case name = "Name"
            case names = "Names"
            case `type` = "Type"
        }
    }

    public struct ServiceStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "FaultStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "OkCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalCount", required: false, type: .long), 
            AWSShapeMember(label: "TotalResponseTime", required: false, type: .double)
        ]

        /// Information about requests that failed with a 4xx Client Error status code.
        public let errorStatistics: ErrorStatistics?
        /// Information about requests that failed with a 5xx Server Error status code.
        public let faultStatistics: FaultStatistics?
        /// The number of requests that completed with a 2xx Success status code.
        public let okCount: Int64?
        /// The total number of completed requests.
        public let totalCount: Int64?
        /// The aggregate response time of completed requests.
        public let totalResponseTime: Double?

        public init(errorStatistics: ErrorStatistics? = nil, faultStatistics: FaultStatistics? = nil, okCount: Int64? = nil, totalCount: Int64? = nil, totalResponseTime: Double? = nil) {
            self.errorStatistics = errorStatistics
            self.faultStatistics = faultStatistics
            self.okCount = okCount
            self.totalCount = totalCount
            self.totalResponseTime = totalResponseTime
        }

        private enum CodingKeys: String, CodingKey {
            case errorStatistics = "ErrorStatistics"
            case faultStatistics = "FaultStatistics"
            case okCount = "OkCount"
            case totalCount = "TotalCount"
            case totalResponseTime = "TotalResponseTime"
        }
    }

    public struct Tag: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Key", required: true, type: .string), 
            AWSShapeMember(label: "Value", required: true, type: .string)
        ]

        /// A tag key, such as Stage or Name. A tag key cannot be empty. The key can be a maximum of 128 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : / 
        public let key: String
        /// An optional tag value, such as Production or test-only. The value can be a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : / 
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 128)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceARN", required: true, type: .string), 
            AWSShapeMember(label: "Tags", required: true, type: .list)
        ]

        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String
        /// A map that contains one or more tag keys and tag values to attach to an X-Ray group or sampling rule. For more information about ways to use tags, see Tagging AWS resources in the AWS General Reference. The following restrictions apply to tags:   Maximum number of user-applied tags per resource: 50   Maximum tag key length: 128 Unicode characters   Maximum tag value length: 256 Unicode characters   Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @   Tag keys and values are case sensitive.   Don't use aws: as a prefix for keys; it's reserved for AWS use. You cannot edit or delete system tags.  
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.resourceARN, name:"resourceARN", parent: name, max: 1011)
            try validate(self.resourceARN, name:"resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 200)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct TelemetryRecord: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "BackendConnectionErrors", required: false, type: .structure), 
            AWSShapeMember(label: "SegmentsReceivedCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsRejectedCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsSentCount", required: false, type: .integer), 
            AWSShapeMember(label: "SegmentsSpilloverCount", required: false, type: .integer), 
            AWSShapeMember(label: "Timestamp", required: true, type: .timestamp)
        ]

        public let backendConnectionErrors: BackendConnectionErrors?
        public let segmentsReceivedCount: Int?
        public let segmentsRejectedCount: Int?
        public let segmentsSentCount: Int?
        public let segmentsSpilloverCount: Int?
        public let timestamp: TimeStamp

        public init(backendConnectionErrors: BackendConnectionErrors? = nil, segmentsReceivedCount: Int? = nil, segmentsRejectedCount: Int? = nil, segmentsSentCount: Int? = nil, segmentsSpilloverCount: Int? = nil, timestamp: TimeStamp) {
            self.backendConnectionErrors = backendConnectionErrors
            self.segmentsReceivedCount = segmentsReceivedCount
            self.segmentsRejectedCount = segmentsRejectedCount
            self.segmentsSentCount = segmentsSentCount
            self.segmentsSpilloverCount = segmentsSpilloverCount
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case backendConnectionErrors = "BackendConnectionErrors"
            case segmentsReceivedCount = "SegmentsReceivedCount"
            case segmentsRejectedCount = "SegmentsRejectedCount"
            case segmentsSentCount = "SegmentsSentCount"
            case segmentsSpilloverCount = "SegmentsSpilloverCount"
            case timestamp = "Timestamp"
        }
    }

    public struct TimeSeriesServiceStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "EdgeSummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "ResponseTimeHistogram", required: false, type: .list), 
            AWSShapeMember(label: "ServiceSummaryStatistics", required: false, type: .structure), 
            AWSShapeMember(label: "Timestamp", required: false, type: .timestamp)
        ]

        public let edgeSummaryStatistics: EdgeStatistics?
        /// The response time histogram for the selected entities.
        public let responseTimeHistogram: [HistogramEntry]?
        public let serviceSummaryStatistics: ServiceStatistics?
        /// Timestamp of the window for which statistics are aggregated.
        public let timestamp: TimeStamp?

        public init(edgeSummaryStatistics: EdgeStatistics? = nil, responseTimeHistogram: [HistogramEntry]? = nil, serviceSummaryStatistics: ServiceStatistics? = nil, timestamp: TimeStamp? = nil) {
            self.edgeSummaryStatistics = edgeSummaryStatistics
            self.responseTimeHistogram = responseTimeHistogram
            self.serviceSummaryStatistics = serviceSummaryStatistics
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case edgeSummaryStatistics = "EdgeSummaryStatistics"
            case responseTimeHistogram = "ResponseTimeHistogram"
            case serviceSummaryStatistics = "ServiceSummaryStatistics"
            case timestamp = "Timestamp"
        }
    }

    public struct Trace: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Duration", required: false, type: .double), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Segments", required: false, type: .list)
        ]

        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// Segment documents for the segments and subsegments that comprise the trace.
        public let segments: [Segment]?

        public init(duration: Double? = nil, id: String? = nil, segments: [Segment]? = nil) {
            self.duration = duration
            self.id = id
            self.segments = segments
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case id = "Id"
            case segments = "Segments"
        }
    }

    public struct TraceSummary: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Annotations", required: false, type: .map), 
            AWSShapeMember(label: "AvailabilityZones", required: false, type: .list), 
            AWSShapeMember(label: "Duration", required: false, type: .double), 
            AWSShapeMember(label: "EntryPoint", required: false, type: .structure), 
            AWSShapeMember(label: "ErrorRootCauses", required: false, type: .list), 
            AWSShapeMember(label: "FaultRootCauses", required: false, type: .list), 
            AWSShapeMember(label: "HasError", required: false, type: .boolean), 
            AWSShapeMember(label: "HasFault", required: false, type: .boolean), 
            AWSShapeMember(label: "HasThrottle", required: false, type: .boolean), 
            AWSShapeMember(label: "Http", required: false, type: .structure), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "InstanceIds", required: false, type: .list), 
            AWSShapeMember(label: "IsPartial", required: false, type: .boolean), 
            AWSShapeMember(label: "MatchedEventTime", required: false, type: .timestamp), 
            AWSShapeMember(label: "ResourceARNs", required: false, type: .list), 
            AWSShapeMember(label: "ResponseTime", required: false, type: .double), 
            AWSShapeMember(label: "ResponseTimeRootCauses", required: false, type: .list), 
            AWSShapeMember(label: "Revision", required: false, type: .integer), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "Users", required: false, type: .list)
        ]

        /// Annotations from the trace's segment documents.
        public let annotations: [String: [ValueWithServiceIds]]?
        /// A list of availability zones for any zone corresponding to the trace segments.
        public let availabilityZones: [AvailabilityZoneDetail]?
        /// The length of time in seconds between the start time of the root segment and the end time of the last segment that completed.
        public let duration: Double?
        /// The root of a trace.
        public let entryPoint: ServiceId?
        /// A collection of ErrorRootCause structures corresponding to the trace segments.
        public let errorRootCauses: [ErrorRootCause]?
        /// A collection of FaultRootCause structures corresponding to the the trace segments.
        public let faultRootCauses: [FaultRootCause]?
        /// The root segment document has a 400 series error.
        public let hasError: Bool?
        /// The root segment document has a 500 series error.
        public let hasFault: Bool?
        /// One or more of the segment documents has a 429 throttling error.
        public let hasThrottle: Bool?
        /// Information about the HTTP request served by the trace.
        public let http: Http?
        /// The unique identifier for the request that generated the trace's segments and subsegments.
        public let id: String?
        /// A list of EC2 instance IDs for any instance corresponding to the trace segments.
        public let instanceIds: [InstanceIdDetail]?
        /// One or more of the segment documents is in progress.
        public let isPartial: Bool?
        /// The matched time stamp of a defined event.
        public let matchedEventTime: TimeStamp?
        /// A list of resource ARNs for any resource corresponding to the trace segments.
        public let resourceARNs: [ResourceARNDetail]?
        /// The length of time in seconds between the start and end times of the root segment. If the service performs work asynchronously, the response time measures the time before the response is sent to the user, while the duration measures the amount of time before the last traced activity completes.
        public let responseTime: Double?
        /// A collection of ResponseTimeRootCause structures corresponding to the trace segments.
        public let responseTimeRootCauses: [ResponseTimeRootCause]?
        /// The revision number of a trace.
        public let revision: Int?
        /// Service IDs from the trace's segment documents.
        public let serviceIds: [ServiceId]?
        /// Users from the trace's segment documents.
        public let users: [TraceUser]?

        public init(annotations: [String: [ValueWithServiceIds]]? = nil, availabilityZones: [AvailabilityZoneDetail]? = nil, duration: Double? = nil, entryPoint: ServiceId? = nil, errorRootCauses: [ErrorRootCause]? = nil, faultRootCauses: [FaultRootCause]? = nil, hasError: Bool? = nil, hasFault: Bool? = nil, hasThrottle: Bool? = nil, http: Http? = nil, id: String? = nil, instanceIds: [InstanceIdDetail]? = nil, isPartial: Bool? = nil, matchedEventTime: TimeStamp? = nil, resourceARNs: [ResourceARNDetail]? = nil, responseTime: Double? = nil, responseTimeRootCauses: [ResponseTimeRootCause]? = nil, revision: Int? = nil, serviceIds: [ServiceId]? = nil, users: [TraceUser]? = nil) {
            self.annotations = annotations
            self.availabilityZones = availabilityZones
            self.duration = duration
            self.entryPoint = entryPoint
            self.errorRootCauses = errorRootCauses
            self.faultRootCauses = faultRootCauses
            self.hasError = hasError
            self.hasFault = hasFault
            self.hasThrottle = hasThrottle
            self.http = http
            self.id = id
            self.instanceIds = instanceIds
            self.isPartial = isPartial
            self.matchedEventTime = matchedEventTime
            self.resourceARNs = resourceARNs
            self.responseTime = responseTime
            self.responseTimeRootCauses = responseTimeRootCauses
            self.revision = revision
            self.serviceIds = serviceIds
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case annotations = "Annotations"
            case availabilityZones = "AvailabilityZones"
            case duration = "Duration"
            case entryPoint = "EntryPoint"
            case errorRootCauses = "ErrorRootCauses"
            case faultRootCauses = "FaultRootCauses"
            case hasError = "HasError"
            case hasFault = "HasFault"
            case hasThrottle = "HasThrottle"
            case http = "Http"
            case id = "Id"
            case instanceIds = "InstanceIds"
            case isPartial = "IsPartial"
            case matchedEventTime = "MatchedEventTime"
            case resourceARNs = "ResourceARNs"
            case responseTime = "ResponseTime"
            case responseTimeRootCauses = "ResponseTimeRootCauses"
            case revision = "Revision"
            case serviceIds = "ServiceIds"
            case users = "Users"
        }
    }

    public struct TraceUser: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ServiceIds", required: false, type: .list), 
            AWSShapeMember(label: "UserName", required: false, type: .string)
        ]

        /// Services that the user's request hit.
        public let serviceIds: [ServiceId]?
        /// The user's name.
        public let userName: String?

        public init(serviceIds: [ServiceId]? = nil, userName: String? = nil) {
            self.serviceIds = serviceIds
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceIds = "ServiceIds"
            case userName = "UserName"
        }
    }

    public struct UnprocessedStatistics: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string), 
            AWSShapeMember(label: "RuleName", required: false, type: .string)
        ]

        /// The error code.
        public let errorCode: String?
        /// The error message.
        public let message: String?
        /// The name of the sampling rule.
        public let ruleName: String?

        public init(errorCode: String? = nil, message: String? = nil, ruleName: String? = nil) {
            self.errorCode = errorCode
            self.message = message
            self.ruleName = ruleName
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case message = "Message"
            case ruleName = "RuleName"
        }
    }

    public struct UnprocessedTraceSegment: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ErrorCode", required: false, type: .string), 
            AWSShapeMember(label: "Id", required: false, type: .string), 
            AWSShapeMember(label: "Message", required: false, type: .string)
        ]

        /// The error that caused processing to fail.
        public let errorCode: String?
        /// The segment's ID.
        public let id: String?
        /// The error message.
        public let message: String?

        public init(errorCode: String? = nil, id: String? = nil, message: String? = nil) {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case id = "Id"
            case message = "Message"
        }
    }

    public struct UntagResourceRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "ResourceARN", required: true, type: .string), 
            AWSShapeMember(label: "TagKeys", required: true, type: .list)
        ]

        /// The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.
        public let resourceARN: String
        /// Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try validate(self.resourceARN, name:"resourceARN", parent: name, max: 1011)
            try validate(self.resourceARN, name:"resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 200)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSShape {


        public init() {
        }

    }

    public struct UpdateGroupRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "FilterExpression", required: false, type: .string), 
            AWSShapeMember(label: "GroupARN", required: false, type: .string), 
            AWSShapeMember(label: "GroupName", required: false, type: .string), 
            AWSShapeMember(label: "InsightsConfiguration", required: false, type: .structure)
        ]

        /// The updated filter expression defining criteria by which to group traces.
        public let filterExpression: String?
        /// The ARN that was generated upon creation.
        public let groupARN: String?
        /// The case-sensitive name of the group.
        public let groupName: String?
        /// The structure containing configurations related to insights. The InsightsEnabled boolean can be set to true to enable insights for the group or false to disable insights for the group.
        public let insightsConfiguration: InsightsConfiguration?

        public init(filterExpression: String? = nil, groupARN: String? = nil, groupName: String? = nil, insightsConfiguration: InsightsConfiguration? = nil) {
            self.filterExpression = filterExpression
            self.groupARN = groupARN
            self.groupName = groupName
            self.insightsConfiguration = insightsConfiguration
        }

        public func validate(name: String) throws {
            try validate(self.groupARN, name:"groupARN", parent: name, max: 400)
            try validate(self.groupARN, name:"groupARN", parent: name, min: 1)
            try validate(self.groupName, name:"groupName", parent: name, max: 32)
            try validate(self.groupName, name:"groupName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpression = "FilterExpression"
            case groupARN = "GroupARN"
            case groupName = "GroupName"
            case insightsConfiguration = "InsightsConfiguration"
        }
    }

    public struct UpdateGroupResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "Group", required: false, type: .structure)
        ]

        /// The group that was updated. Contains the name of the group that was updated, the ARN of the group that was updated, the updated filter expression, and the updated insight configuration assigned to the group.
        public let group: Group?

        public init(group: Group? = nil) {
            self.group = group
        }

        private enum CodingKeys: String, CodingKey {
            case group = "Group"
        }
    }

    public struct UpdateSamplingRuleRequest: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleUpdate", required: true, type: .structure)
        ]

        /// The rule and fields to change.
        public let samplingRuleUpdate: SamplingRuleUpdate

        public init(samplingRuleUpdate: SamplingRuleUpdate) {
            self.samplingRuleUpdate = samplingRuleUpdate
        }

        public func validate(name: String) throws {
            try self.samplingRuleUpdate.validate(name: "\(name).samplingRuleUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleUpdate = "SamplingRuleUpdate"
        }
    }

    public struct UpdateSamplingRuleResult: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "SamplingRuleRecord", required: false, type: .structure)
        ]

        /// The updated rule definition and metadata.
        public let samplingRuleRecord: SamplingRuleRecord?

        public init(samplingRuleRecord: SamplingRuleRecord? = nil) {
            self.samplingRuleRecord = samplingRuleRecord
        }

        private enum CodingKeys: String, CodingKey {
            case samplingRuleRecord = "SamplingRuleRecord"
        }
    }

    public struct ValueWithServiceIds: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "AnnotationValue", required: false, type: .structure), 
            AWSShapeMember(label: "ServiceIds", required: false, type: .list)
        ]

        /// Values of the annotation.
        public let annotationValue: AnnotationValue?
        /// Services to which the annotation applies.
        public let serviceIds: [ServiceId]?

        public init(annotationValue: AnnotationValue? = nil, serviceIds: [ServiceId]? = nil) {
            self.annotationValue = annotationValue
            self.serviceIds = serviceIds
        }

        private enum CodingKeys: String, CodingKey {
            case annotationValue = "AnnotationValue"
            case serviceIds = "ServiceIds"
        }
    }
}

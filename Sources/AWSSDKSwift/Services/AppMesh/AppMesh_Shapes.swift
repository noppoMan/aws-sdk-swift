// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension AppMesh {
    //MARK: Enums

    public enum DurationUnit: String, CustomStringConvertible, Codable {
        case ms = "ms"
        case s = "s"
        public var description: String { return self.rawValue }
    }

    public enum EgressFilterType: String, CustomStringConvertible, Codable {
        case allowAll = "ALLOW_ALL"
        case dropAll = "DROP_ALL"
        public var description: String { return self.rawValue }
    }

    public enum GatewayRouteStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum GrpcRetryPolicyEvent: String, CustomStringConvertible, Codable {
        case cancelled = "cancelled"
        case deadlineExceeded = "deadline-exceeded"
        case `internal` = "internal"
        case resourceExhausted = "resource-exhausted"
        case unavailable = "unavailable"
        public var description: String { return self.rawValue }
    }

    public enum HttpMethod: String, CustomStringConvertible, Codable {
        case connect = "CONNECT"
        case delete = "DELETE"
        case get = "GET"
        case head = "HEAD"
        case options = "OPTIONS"
        case patch = "PATCH"
        case post = "POST"
        case put = "PUT"
        case trace = "TRACE"
        public var description: String { return self.rawValue }
    }

    public enum HttpScheme: String, CustomStringConvertible, Codable {
        case http = "http"
        case https = "https"
        public var description: String { return self.rawValue }
    }

    public enum ListenerTlsMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case permissive = "PERMISSIVE"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum MeshStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum PortProtocol: String, CustomStringConvertible, Codable {
        case grpc = "grpc"
        case http = "http"
        case http2 = "http2"
        case tcp = "tcp"
        public var description: String { return self.rawValue }
    }

    public enum RouteStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TcpRetryPolicyEvent: String, CustomStringConvertible, Codable {
        case connectionError = "connection-error"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayListenerTlsMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case permissive = "PERMISSIVE"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayPortProtocol: String, CustomStringConvertible, Codable {
        case grpc = "grpc"
        case http = "http"
        case http2 = "http2"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualNodeStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualRouterStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualServiceStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    //MARK: Shapes

    public struct AccessLog: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "file", required: false, type: .structure)
        ]

        /// The file object to send virtual node access logs to.
        public let file: FileAccessLog?

        public init(file: FileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }

    public struct AwsCloudMapInstanceAttribute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: true, type: .string), 
            AWSShapeMember(label: "value", required: true, type: .string)
        ]

        /// The name of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service
        ///          instance that contains the specified key and value is returned.
        public let key: String
        /// The value of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service
        ///          instance that contains the specified key and value is returned.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 255)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.key, name:"key", parent: name, pattern: "^[a-zA-Z0-9!-~]+$")
            try validate(self.value, name:"value", parent: name, max: 1024)
            try validate(self.value, name:"value", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, pattern: "^([a-zA-Z0-9!-~][ ta-zA-Z0-9!-~]*){0,1}[a-zA-Z0-9!-~]{0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct AwsCloudMapServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "attributes", required: false, type: .list), 
            AWSShapeMember(label: "namespaceName", required: true, type: .string), 
            AWSShapeMember(label: "serviceName", required: true, type: .string)
        ]

        /// A string map that contains attributes with values that you can use to filter instances
        ///          by any custom attribute that you specified when you registered the instance. Only instances
        ///          that match all of the specified key/value pairs will be returned.
        public let attributes: [AwsCloudMapInstanceAttribute]?
        /// The name of the AWS Cloud Map namespace to use.
        public let namespaceName: String
        /// The name of the AWS Cloud Map service to use.
        public let serviceName: String

        public init(attributes: [AwsCloudMapInstanceAttribute]? = nil, namespaceName: String, serviceName: String) {
            self.attributes = attributes
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try validate(self.namespaceName, name:"namespaceName", parent: name, max: 1024)
            try validate(self.namespaceName, name:"namespaceName", parent: name, min: 1)
            try validate(self.namespaceName, name:"namespaceName", parent: name, pattern: "((?=^.{1,127}$)^([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9])(.([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9]))*$)|(^.$)")
            try validate(self.serviceName, name:"serviceName", parent: name, max: 1024)
            try validate(self.serviceName, name:"serviceName", parent: name, min: 1)
            try validate(self.serviceName, name:"serviceName", parent: name, pattern: "((?=^.{1,127}$)^([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9])(.([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9]))*$)|(^.$)")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case namespaceName = "namespaceName"
            case serviceName = "serviceName"
        }
    }

    public struct Backend: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: false, type: .structure)
        ]

        /// Specifies a virtual service to use as a backend for a virtual node. 
        public let virtualService: VirtualServiceBackend?

        public init(virtualService: VirtualServiceBackend? = nil) {
            self.virtualService = virtualService
        }

        public func validate(name: String) throws {
            try self.virtualService?.validate(name: "\(name).virtualService")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct BackendDefaults: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientPolicy", required: false, type: .structure)
        ]

        /// A reference to an object that represents a client policy.
        public let clientPolicy: ClientPolicy?

        public init(clientPolicy: ClientPolicy? = nil) {
            self.clientPolicy = clientPolicy
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
        }
    }

    public struct ClientPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tls", required: false, type: .structure)
        ]

        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public let tls: ClientPolicyTls?

        public init(tls: ClientPolicyTls? = nil) {
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case tls = "tls"
        }
    }

    public struct ClientPolicyTls: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "enforce", required: false, type: .boolean), 
            AWSShapeMember(label: "ports", required: false, type: .list), 
            AWSShapeMember(label: "validation", required: true, type: .structure)
        ]

        /// Whether the policy is enforced. The default is True, if a value isn't
        ///          specified.
        public let enforce: Bool?
        /// One or more ports that the policy is enforced for.
        public let ports: [Int]?
        /// A reference to an object that represents a TLS validation context.
        public let validation: TlsValidationContext

        public init(enforce: Bool? = nil, ports: [Int]? = nil, validation: TlsValidationContext) {
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.ports?.forEach {
                try validate($0, name: "ports[]", parent: name, max: 65535)
                try validate($0, name: "ports[]", parent: name, min: 1)
            }
            try self.validation.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case enforce = "enforce"
            case ports = "ports"
            case validation = "validation"
        }
    }

    public struct CreateGatewayRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "gatewayRouteName", required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the gateway route.
        public let gatewayRouteName: String
        /// The name of the service mesh to create the gateway route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The gateway route specification to apply.
        public let spec: GatewayRouteSpec
        /// Optional metadata that you can apply to the gateway route to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual gateway to associate the gateway route with. If the virtual
        ///          gateway is in a shared mesh, then you must be the owner of the virtual gateway
        ///          resource.
        public let virtualGatewayName: String

        public init(clientToken: String? = CreateGatewayRouteInput.idempotencyToken(), gatewayRouteName: String, meshName: String, meshOwner: String? = nil, spec: GatewayRouteSpec, tags: [TagRef]? = nil, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, max: 255)
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case gatewayRouteName = "gatewayRouteName"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case tags = "tags"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct CreateGatewayRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "gatewayRoute"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRoute", required: true, type: .structure)
        ]

        /// The full description of your gateway route following the create call.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute = "gatewayRoute"
        }
    }

    public struct CreateMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: false, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the service mesh.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?
        /// Optional metadata that you can apply to the service mesh to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?

        public init(clientToken: String? = CreateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil, tags: [TagRef]? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case tags = "tags"
        }
    }

    public struct CreateMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        /// The full description of your service mesh following the create call.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct CreateRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name to use for the route.
        public let routeName: String
        /// The route specification to apply.
        public let spec: RouteSpec
        /// Optional metadata that you can apply to the route to assist with categorization and
        ///          organization. Each tag consists of a key and an optional value, both of which you define.
        ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual router in which to create the route. If the virtual router is in
        ///          a shared mesh, then you must be the owner of the virtual router resource.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case routeName = "routeName"
            case spec = "spec"
            case tags = "tags"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct CreateRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// The full description of your mesh following the create call.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct CreateVirtualGatewayInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualGatewayName", required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual gateway in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual gateway specification to apply.
        public let spec: VirtualGatewaySpec
        /// Optional metadata that you can apply to the virtual gateway to assist with
        ///          categorization and organization. Each tag consists of a key and an optional value, both of
        ///          which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual gateway.
        public let virtualGatewayName: String

        public init(clientToken: String? = CreateVirtualGatewayInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualGatewaySpec, tags: [TagRef]? = nil, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case tags = "tags"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct CreateVirtualGatewayOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualGateway"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGateway", required: true, type: .structure)
        ]

        /// The full description of your virtual gateway following the create call.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway = "virtualGateway"
        }
    }

    public struct CreateVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual node in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual node specification to apply.
        public let spec: VirtualNodeSpec
        /// Optional metadata that you can apply to the virtual node to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual node.
        public let virtualNodeName: String

        public init(clientToken: String? = CreateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, tags: [TagRef]? = nil, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case tags = "tags"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct CreateVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// The full description of your virtual node following the create call.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct CreateVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual router in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual router specification to apply.
        public let spec: VirtualRouterSpec
        /// Optional metadata that you can apply to the virtual router to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual router.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case tags = "tags"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct CreateVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// The full description of your virtual router following the create call.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct CreateVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual service in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
        ///                the account that you specify must share the mesh with your account before you can create 
        ///              the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual service specification to apply.
        public let spec: VirtualServiceSpec
        /// Optional metadata that you can apply to the virtual service to assist with
        ///          categorization and organization. Each tag consists of a key and an optional value, both of
        ///          which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual service.
        public let virtualServiceName: String

        public init(clientToken: String? = CreateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, tags: [TagRef]? = nil, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case tags = "tags"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct CreateVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// The full description of your virtual service following the create call.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DeleteGatewayRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRouteName", location: .uri(locationName: "gatewayRouteName"), required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// The name of the gateway route to delete.
        public let gatewayRouteName: String
        /// The name of the service mesh to delete the gateway route from.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to delete the route from.
        public let virtualGatewayName: String

        public init(gatewayRouteName: String, meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, max: 255)
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRouteName = "gatewayRouteName"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct DeleteGatewayRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "gatewayRoute"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRoute", required: true, type: .structure)
        ]

        /// The gateway route that was deleted.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute = "gatewayRoute"
        }
    }

    public struct DeleteMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete.
        public let meshName: String

        public init(meshName: String) {
            self.meshName = meshName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
        }
    }

    public struct DeleteMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        /// The service mesh that was deleted.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct DeleteRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to delete.
        public let routeName: String
        /// The name of the virtual router to delete the route in.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DeleteRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// The route that was deleted.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct DeleteVirtualGatewayInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the virtual gateway from.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to delete.
        public let virtualGatewayName: String

        public init(meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct DeleteVirtualGatewayOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualGateway"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGateway", required: true, type: .structure)
        ]

        /// The virtual gateway that was deleted.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway = "virtualGateway"
        }
    }

    public struct DeleteVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the virtual node in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual node to delete.
        public let virtualNodeName: String

        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct DeleteVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// The virtual node that was deleted.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DeleteVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the virtual router in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual router to delete.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DeleteVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// The virtual router that was deleted.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DeleteVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the virtual service in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual service to delete.
        public let virtualServiceName: String

        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct DeleteVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// The virtual service that was deleted.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DescribeGatewayRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRouteName", location: .uri(locationName: "gatewayRouteName"), required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// The name of the gateway route to describe.
        public let gatewayRouteName: String
        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(gatewayRouteName: String, meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, max: 255)
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRouteName = "gatewayRouteName"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct DescribeGatewayRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "gatewayRoute"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRoute", required: true, type: .structure)
        ]

        /// The full description of your gateway route.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute = "gatewayRoute"
        }
    }

    public struct DescribeMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string)
        ]

        /// The name of the service mesh to describe.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?

        public init(meshName: String, meshOwner: String? = nil) {
            self.meshName = meshName
            self.meshOwner = meshOwner
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
        }
    }

    public struct DescribeMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        /// The full description of your service mesh.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct DescribeRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to describe.
        public let routeName: String
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DescribeRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// The full description of your route.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct DescribeVirtualGatewayInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to describe.
        public let virtualGatewayName: String

        public init(meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct DescribeVirtualGatewayOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualGateway"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGateway", required: true, type: .structure)
        ]

        /// The full description of your virtual gateway.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway = "virtualGateway"
        }
    }

    public struct DescribeVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual node to describe.
        public let virtualNodeName: String

        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct DescribeVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// The full description of your virtual node.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DescribeVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual router to describe.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DescribeVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// The full description of your virtual router.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DescribeVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual service to describe.
        public let virtualServiceName: String

        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct DescribeVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// The full description of your virtual service.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DnsServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "hostname", required: true, type: .string)
        ]

        /// Specifies the DNS service discovery hostname for the virtual node. 
        public let hostname: String

        public init(hostname: String) {
            self.hostname = hostname
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
        }
    }

    public struct Duration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "unit", required: false, type: .enum), 
            AWSShapeMember(label: "value", required: false, type: .long)
        ]

        /// A unit of time.
        public let unit: DurationUnit?
        /// A number of time units.
        public let value: Int64?

        public init(unit: DurationUnit? = nil, value: Int64? = nil) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct EgressFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]

        /// The egress filter type. By default, the type is DROP_ALL, which allows
        ///          egress only from virtual nodes to other defined resources in the service mesh (and any
        ///          traffic to *.amazonaws.com for AWS API calls). You can set the egress filter
        ///          type to ALLOW_ALL to allow egress to any endpoint inside or outside of the
        ///          service mesh.
        public let `type`: EgressFilterType

        public init(type: EgressFilterType) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public struct FileAccessLog: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "path", required: true, type: .string)
        ]

        /// The file path to write access logs to. You can use /dev/stdout to send
        ///          access logs to standard out and configure your Envoy container to use a log driver, such as
        ///             awslogs, to export the access logs to a log storage service such as Amazon
        ///          CloudWatch Logs. You can also specify a path in the Envoy container's file system to write
        ///          the files to disk.
        ///          
        ///             The Envoy process must have write permissions to the path that you specify here.
        ///             Otherwise, Envoy fails to bootstrap properly.
        ///          
        public let path: String

        public init(path: String) {
            self.path = path
        }

        public func validate(name: String) throws {
            try validate(self.path, name:"path", parent: name, max: 255)
            try validate(self.path, name:"path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
        }
    }

    public struct GatewayRouteData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRouteName", required: true, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualGatewayName", required: true, type: .string)
        ]

        /// The name of the gateway route.
        public let gatewayRouteName: String
        /// The name of the service mesh that the resource resides in. 
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the gateway route.
        public let spec: GatewayRouteSpec
        /// The status of the gateway route.
        public let status: GatewayRouteStatus
        /// The virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(gatewayRouteName: String, meshName: String, metadata: ResourceMetadata, spec: GatewayRouteSpec, status: GatewayRouteStatus, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRouteName = "gatewayRouteName"
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct GatewayRouteRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "gatewayRouteName", required: true, type: .string), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long), 
            AWSShapeMember(label: "virtualGatewayName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the gateway route.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The name of the gateway route.
        public let gatewayRouteName: String
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The name of the service mesh that the resource resides in. 
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(arn: String, createdAt: TimeStamp, gatewayRouteName: String, lastUpdatedAt: TimeStamp, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualGatewayName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.gatewayRouteName = gatewayRouteName
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case gatewayRouteName = "gatewayRouteName"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct GatewayRouteSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "grpcRoute", required: false, type: .structure), 
            AWSShapeMember(label: "http2Route", required: false, type: .structure), 
            AWSShapeMember(label: "httpRoute", required: false, type: .structure)
        ]

        /// An object that represents the specification of a gRPC gateway route.
        public let grpcRoute: GrpcGatewayRoute?
        /// An object that represents the specification of an HTTP/2 gateway route.
        public let http2Route: HttpGatewayRoute?
        /// An object that represents the specification of an HTTP gateway route.
        public let httpRoute: HttpGatewayRoute?

        public init(grpcRoute: GrpcGatewayRoute? = nil, http2Route: HttpGatewayRoute? = nil, httpRoute: HttpGatewayRoute? = nil) {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
        }

        public func validate(name: String) throws {
            try self.grpcRoute?.validate(name: "\(name).grpcRoute")
            try self.http2Route?.validate(name: "\(name).http2Route")
            try self.httpRoute?.validate(name: "\(name).httpRoute")
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRoute = "grpcRoute"
            case http2Route = "http2Route"
            case httpRoute = "httpRoute"
        }
    }

    public struct GatewayRouteStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status for the gateway route.
        public let status: GatewayRouteStatusCode

        public init(status: GatewayRouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct GatewayRouteTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// An object that represents a virtual service gateway route target.
        public let virtualService: GatewayRouteVirtualService

        public init(virtualService: GatewayRouteVirtualService) {
            self.virtualService = virtualService
        }

        public func validate(name: String) throws {
            try self.virtualService.validate(name: "\(name).virtualService")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct GatewayRouteVirtualService: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// The name of the virtual service that traffic is routed to.
        public let virtualServiceName: String

        public init(virtualServiceName: String) {
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.virtualServiceName, name:"virtualServiceName", parent: name, max: 255)
            try validate(self.virtualServiceName, name:"virtualServiceName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct GrpcGatewayRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "action", required: true, type: .structure), 
            AWSShapeMember(label: "match", required: true, type: .structure)
        ]

        /// An object that represents the action to take if a match is determined.
        public let action: GrpcGatewayRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: GrpcGatewayRouteMatch

        public init(action: GrpcGatewayRouteAction, match: GrpcGatewayRouteMatch) {
            self.action = action
            self.match = match
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
        }
    }

    public struct GrpcGatewayRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "target", required: true, type: .structure)
        ]

        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        public let target: GatewayRouteTarget

        public init(target: GatewayRouteTarget) {
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case target = "target"
        }
    }

    public struct GrpcGatewayRouteMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "serviceName", required: false, type: .string)
        ]

        /// The fully qualified domain name for the service to match from the request.
        public let serviceName: String?

        public init(serviceName: String? = nil) {
            self.serviceName = serviceName
        }

        private enum CodingKeys: String, CodingKey {
            case serviceName = "serviceName"
        }
    }

    public struct GrpcRetryPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "grpcRetryEvents", required: false, type: .list), 
            AWSShapeMember(label: "httpRetryEvents", required: false, type: .list), 
            AWSShapeMember(label: "maxRetries", required: true, type: .long), 
            AWSShapeMember(label: "perRetryTimeout", required: true, type: .structure), 
            AWSShapeMember(label: "tcpRetryEvents", required: false, type: .list)
        ]

        /// Specify at least one of the valid values.
        public let grpcRetryEvents: [GrpcRetryPolicyEvent]?
        /// Specify at least one of the following values. 
        ///          
        ///             
        ///                
        ///                   server-error – HTTP status codes 500, 501,
        ///                   502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///             
        ///             
        ///                
        ///                   gateway-error – HTTP status codes 502,
        ///                   503, and 504
        ///             
        ///             
        ///                
        ///                   client-error – HTTP status code 409
        ///             
        ///             
        ///                
        ///                   stream-error – Retry on refused
        ///                   stream
        ///             
        ///          
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// An object that represents a duration of time.
        public let perRetryTimeout: Duration
        /// Specify a valid value.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        public init(grpcRetryEvents: [GrpcRetryPolicyEvent]? = nil, httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.grpcRetryEvents = grpcRetryEvents
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try validate(self.grpcRetryEvents, name:"grpcRetryEvents", parent: name, max: 5)
            try validate(self.grpcRetryEvents, name:"grpcRetryEvents", parent: name, min: 1)
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, max: 25)
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, min: 1)
            try validate(self.maxRetries, name:"maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, max: 1)
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRetryEvents = "grpcRetryEvents"
            case httpRetryEvents = "httpRetryEvents"
            case maxRetries = "maxRetries"
            case perRetryTimeout = "perRetryTimeout"
            case tcpRetryEvents = "tcpRetryEvents"
        }
    }

    public struct GrpcRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "action", required: true, type: .structure), 
            AWSShapeMember(label: "match", required: true, type: .structure), 
            AWSShapeMember(label: "retryPolicy", required: false, type: .structure), 
            AWSShapeMember(label: "timeout", required: false, type: .structure)
        ]

        /// An object that represents the action to take if a match is determined.
        public let action: GrpcRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: GrpcRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: GrpcRetryPolicy?
        /// An object that represents types of timeouts. 
        public let timeout: GrpcTimeout?

        public init(action: GrpcRouteAction, match: GrpcRouteMatch, retryPolicy: GrpcRetryPolicy? = nil, timeout: GrpcTimeout? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case retryPolicy = "retryPolicy"
            case timeout = "timeout"
        }
    }

    public struct GrpcRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "weightedTargets", required: true, type: .list)
        ]

        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct GrpcRouteMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "metadata", required: false, type: .list), 
            AWSShapeMember(label: "methodName", required: false, type: .string), 
            AWSShapeMember(label: "serviceName", required: false, type: .string)
        ]

        /// An object that represents the data to match from the request.
        public let metadata: [GrpcRouteMetadata]?
        /// The method name to match from the request. If you specify a name, you must also specify
        ///          a serviceName.
        public let methodName: String?
        /// The fully qualified domain name for the service to match from the request.
        public let serviceName: String?

        public init(metadata: [GrpcRouteMetadata]? = nil, methodName: String? = nil, serviceName: String? = nil) {
            self.metadata = metadata
            self.methodName = methodName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try validate(self.metadata, name:"metadata", parent: name, max: 10)
            try validate(self.metadata, name:"metadata", parent: name, min: 1)
            try validate(self.methodName, name:"methodName", parent: name, max: 50)
            try validate(self.methodName, name:"methodName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case methodName = "methodName"
            case serviceName = "serviceName"
        }
    }

    public struct GrpcRouteMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "invert", required: false, type: .boolean), 
            AWSShapeMember(label: "match", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// An object that represents the data to match from the request.
        public let match: GrpcRouteMetadataMatchMethod?
        /// The name of the route.
        public let name: String

        public init(invert: Bool? = nil, match: GrpcRouteMetadataMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try validate(self.name, name:"name", parent: name, max: 50)
            try validate(self.name, name:"name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct GrpcRouteMetadataMatchMethod: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "exact", required: false, type: .string), 
            AWSShapeMember(label: "prefix", required: false, type: .string), 
            AWSShapeMember(label: "range", required: false, type: .structure), 
            AWSShapeMember(label: "regex", required: false, type: .string), 
            AWSShapeMember(label: "suffix", required: false, type: .string)
        ]

        /// The value sent by the client must match the specified value exactly.
        public let exact: String?
        /// The value sent by the client must begin with the specified characters.
        public let prefix: String?
        /// An object that represents the range of values to match on.
        public let range: MatchRange?
        /// The value sent by the client must include the specified characters.
        public let regex: String?
        /// The value sent by the client must end with the specified characters.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try validate(self.exact, name:"exact", parent: name, max: 255)
            try validate(self.exact, name:"exact", parent: name, min: 1)
            try validate(self.prefix, name:"prefix", parent: name, max: 255)
            try validate(self.prefix, name:"prefix", parent: name, min: 1)
            try validate(self.regex, name:"regex", parent: name, max: 255)
            try validate(self.regex, name:"regex", parent: name, min: 1)
            try validate(self.suffix, name:"suffix", parent: name, max: 255)
            try validate(self.suffix, name:"suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public struct GrpcTimeout: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "idle", required: false, type: .structure), 
            AWSShapeMember(label: "perRequest", required: false, type: .structure)
        ]

        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public let idle: Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public let perRequest: Duration?

        public init(idle: Duration? = nil, perRequest: Duration? = nil) {
            self.idle = idle
            self.perRequest = perRequest
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
            try self.perRequest?.validate(name: "\(name).perRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case idle = "idle"
            case perRequest = "perRequest"
        }
    }

    public struct HeaderMatchMethod: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "exact", required: false, type: .string), 
            AWSShapeMember(label: "prefix", required: false, type: .string), 
            AWSShapeMember(label: "range", required: false, type: .structure), 
            AWSShapeMember(label: "regex", required: false, type: .string), 
            AWSShapeMember(label: "suffix", required: false, type: .string)
        ]

        /// The value sent by the client must match the specified value exactly.
        public let exact: String?
        /// The value sent by the client must begin with the specified characters.
        public let prefix: String?
        /// An object that represents the range of values to match on.
        public let range: MatchRange?
        /// The value sent by the client must include the specified characters.
        public let regex: String?
        /// The value sent by the client must end with the specified characters.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try validate(self.exact, name:"exact", parent: name, max: 255)
            try validate(self.exact, name:"exact", parent: name, min: 1)
            try validate(self.prefix, name:"prefix", parent: name, max: 255)
            try validate(self.prefix, name:"prefix", parent: name, min: 1)
            try validate(self.regex, name:"regex", parent: name, max: 255)
            try validate(self.regex, name:"regex", parent: name, min: 1)
            try validate(self.suffix, name:"suffix", parent: name, max: 255)
            try validate(self.suffix, name:"suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public struct HealthCheckPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "healthyThreshold", required: true, type: .integer), 
            AWSShapeMember(label: "intervalMillis", required: true, type: .long), 
            AWSShapeMember(label: "path", required: false, type: .string), 
            AWSShapeMember(label: "port", required: false, type: .integer), 
            AWSShapeMember(label: "protocol", required: true, type: .enum), 
            AWSShapeMember(label: "timeoutMillis", required: true, type: .long), 
            AWSShapeMember(label: "unhealthyThreshold", required: true, type: .integer)
        ]

        /// The number of consecutive successful health checks that must occur before declaring
        ///          listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This value is only used if the
        ///          specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined
        ///          in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request. If you specify grpc, then your
        ///          service must conform to the GRPC Health
        ///             Checking Protocol.
        public let `protocol`: PortProtocol
        /// The amount of time to wait when receiving a response from the health check, in
        ///          milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a
        ///          virtual node unhealthy. 
        public let unhealthyThreshold: Int

        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: PortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, max: 10)
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, min: 2)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, max: 300000)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, min: 5000)
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, max: 60000)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, min: 2000)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, max: 10)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "healthyThreshold"
            case intervalMillis = "intervalMillis"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case timeoutMillis = "timeoutMillis"
            case unhealthyThreshold = "unhealthyThreshold"
        }
    }

    public struct HttpGatewayRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "action", required: true, type: .structure), 
            AWSShapeMember(label: "match", required: true, type: .structure)
        ]

        /// An object that represents the action to take if a match is determined.
        public let action: HttpGatewayRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: HttpGatewayRouteMatch

        public init(action: HttpGatewayRouteAction, match: HttpGatewayRouteMatch) {
            self.action = action
            self.match = match
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
        }
    }

    public struct HttpGatewayRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "target", required: true, type: .structure)
        ]

        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        public let target: GatewayRouteTarget

        public init(target: GatewayRouteTarget) {
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case target = "target"
        }
    }

    public struct HttpGatewayRouteMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "prefix", required: true, type: .string)
        ]

        /// Specifies the path to match requests with. This parameter must always start with
        ///             /, which by itself matches all requests to the virtual service name. You
        ///          can also match for path-based routing of requests. For example, if your virtual service
        ///          name is my-service.local and you want the route to match requests to
        ///             my-service.local/metrics, your prefix should be
        ///          /metrics.
        public let prefix: String

        public init(prefix: String) {
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "prefix"
        }
    }

    public struct HttpRetryPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "httpRetryEvents", required: false, type: .list), 
            AWSShapeMember(label: "maxRetries", required: true, type: .long), 
            AWSShapeMember(label: "perRetryTimeout", required: true, type: .structure), 
            AWSShapeMember(label: "tcpRetryEvents", required: false, type: .list)
        ]

        /// Specify at least one of the following values. 
        ///          
        ///             
        ///                
        ///                   server-error – HTTP status codes 500, 501,
        ///                   502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///             
        ///             
        ///                
        ///                   gateway-error – HTTP status codes 502,
        ///                   503, and 504
        ///             
        ///             
        ///                
        ///                   client-error – HTTP status code 409
        ///             
        ///             
        ///                
        ///                   stream-error – Retry on refused
        ///                   stream
        ///             
        ///          
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// An object that represents a duration of time.
        public let perRetryTimeout: Duration
        /// Specify a valid value.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        public init(httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, max: 25)
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, min: 1)
            try validate(self.maxRetries, name:"maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, max: 1)
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case httpRetryEvents = "httpRetryEvents"
            case maxRetries = "maxRetries"
            case perRetryTimeout = "perRetryTimeout"
            case tcpRetryEvents = "tcpRetryEvents"
        }
    }

    public struct HttpRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "action", required: true, type: .structure), 
            AWSShapeMember(label: "match", required: true, type: .structure), 
            AWSShapeMember(label: "retryPolicy", required: false, type: .structure), 
            AWSShapeMember(label: "timeout", required: false, type: .structure)
        ]

        /// An object that represents the action to take if a match is determined.
        public let action: HttpRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: HttpRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: HttpRetryPolicy?
        /// An object that represents types of timeouts. 
        public let timeout: HttpTimeout?

        public init(action: HttpRouteAction, match: HttpRouteMatch, retryPolicy: HttpRetryPolicy? = nil, timeout: HttpTimeout? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case retryPolicy = "retryPolicy"
            case timeout = "timeout"
        }
    }

    public struct HttpRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "weightedTargets", required: true, type: .list)
        ]

        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct HttpRouteHeader: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "invert", required: false, type: .boolean), 
            AWSShapeMember(label: "match", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// The HeaderMatchMethod object.
        public let match: HeaderMatchMethod?
        /// A name for the HTTP header in the client request that will be matched on.
        public let name: String

        public init(invert: Bool? = nil, match: HeaderMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try validate(self.name, name:"name", parent: name, max: 50)
            try validate(self.name, name:"name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct HttpRouteMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "headers", required: false, type: .list), 
            AWSShapeMember(label: "method", required: false, type: .enum), 
            AWSShapeMember(label: "prefix", required: true, type: .string), 
            AWSShapeMember(label: "scheme", required: false, type: .enum)
        ]

        /// An object that represents the client request headers to match on.
        public let headers: [HttpRouteHeader]?
        /// The client request method to match on. Specify only one.
        public let method: HttpMethod?
        /// Specifies the path to match requests with. This parameter must always start with
        ///             /, which by itself matches all requests to the virtual service name. You
        ///          can also match for path-based routing of requests. For example, if your virtual service
        ///          name is my-service.local and you want the route to match requests to
        ///             my-service.local/metrics, your prefix should be
        ///          /metrics.
        public let prefix: String
        /// The client request scheme to match on. Specify only one.
        public let scheme: HttpScheme?

        public init(headers: [HttpRouteHeader]? = nil, method: HttpMethod? = nil, prefix: String, scheme: HttpScheme? = nil) {
            self.headers = headers
            self.method = method
            self.prefix = prefix
            self.scheme = scheme
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try validate(self.headers, name:"headers", parent: name, max: 10)
            try validate(self.headers, name:"headers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers = "headers"
            case method = "method"
            case prefix = "prefix"
            case scheme = "scheme"
        }
    }

    public struct HttpTimeout: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "idle", required: false, type: .structure), 
            AWSShapeMember(label: "perRequest", required: false, type: .structure)
        ]

        public let idle: Duration?
        public let perRequest: Duration?

        public init(idle: Duration? = nil, perRequest: Duration? = nil) {
            self.idle = idle
            self.perRequest = perRequest
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
            try self.perRequest?.validate(name: "\(name).perRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case idle = "idle"
            case perRequest = "perRequest"
        }
    }

    public struct ListGatewayRoutesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// The maximum number of results returned by ListGatewayRoutes in paginated
        ///          output. When you use this parameter, ListGatewayRoutes returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListGatewayRoutes request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListGatewayRoutes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list gateway routes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListGatewayRoutes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual gateway to list gateway routes in.
        public let virtualGatewayName: String

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil, virtualGatewayName: String) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case nextToken = "nextToken"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct ListGatewayRoutesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRoutes", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of existing gateway routes for the specified service mesh and virtual
        ///          gateway.
        public let gatewayRoutes: [GatewayRouteRef]
        /// The nextToken value to include in a future ListGatewayRoutes
        ///          request. When the results of a ListGatewayRoutes request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?

        public init(gatewayRoutes: [GatewayRouteRef], nextToken: String? = nil) {
            self.gatewayRoutes = gatewayRoutes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoutes = "gatewayRoutes"
            case nextToken = "nextToken"
        }
    }

    public struct ListMeshesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListMeshes in paginated output.
        ///          When you use this parameter, ListMeshes returns only limit
        ///          results in a single page along with a nextToken response element. You can see
        ///          the remaining results of the initial request by sending another ListMeshes
        ///          request with the returned nextToken value. This value can be between
        ///          1 and 100. If you don't use this parameter,
        ///             ListMeshes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated
        ///             ListMeshes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value. 
        ///          
        ///             This token should be treated as an opaque identifier that is used only to
        ///                 retrieve the next items in a list and not for other programmatic purposes.
        ///         
        public let nextToken: String?

        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case nextToken = "nextToken"
        }
    }

    public struct ListMeshesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshes", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of existing service meshes.
        public let meshes: [MeshRef]
        /// The nextToken value to include in a future ListMeshes request.
        ///          When the results of a ListMeshes request exceed limit, you can
        ///          use this value to retrieve the next page of results. This value is null when
        ///          there are no more results to return.
        public let nextToken: String?

        public init(meshes: [MeshRef], nextToken: String? = nil) {
            self.meshes = meshes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshes = "meshes"
            case nextToken = "nextToken"
        }
    }

    public struct ListRoutesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The maximum number of results returned by ListRoutes in paginated output.
        ///          When you use this parameter, ListRoutes returns only limit
        ///          results in a single page along with a nextToken response element. You can see
        ///          the remaining results of the initial request by sending another ListRoutes
        ///          request with the returned nextToken value. This value can be between
        ///          1 and 100. If you don't use this parameter,
        ///             ListRoutes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list routes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListRoutes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual router to list routes in.
        public let virtualRouterName: String

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil, virtualRouterName: String) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case nextToken = "nextToken"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct ListRoutesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "routes", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListRoutes request.
        ///          When the results of a ListRoutes request exceed limit, you can
        ///          use this value to retrieve the next page of results. This value is null when
        ///          there are no more results to return.
        public let nextToken: String?
        /// The list of existing routes for the specified service mesh and virtual router.
        public let routes: [RouteRef]

        public init(nextToken: String? = nil, routes: [RouteRef]) {
            self.nextToken = nextToken
            self.routes = routes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case routes = "routes"
        }
    }

    public struct ListTagsForResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "resourceArn", location: .querystring(locationName: "resourceArn"), required: true, type: .string)
        ]

        /// The maximum number of tag results returned by ListTagsForResource in
        ///          paginated output. When this parameter is used, ListTagsForResource returns
        ///          only limit results in a single page along with a nextToken
        ///          response element. You can see the remaining results of the initial request by sending
        ///          another ListTagsForResource request with the returned nextToken
        ///          value. This value can be between 1 and 100. If you don't use
        ///          this parameter, ListTagsForResource returns up to 100
        ///          results and a nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated
        ///             ListTagsForResource request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
        public let resourceArn: String

        public init(limit: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 50)
            try validate(self.limit, name:"limit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case nextToken = "nextToken"
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListTagsForResource
        ///          request. When the results of a ListTagsForResource request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The tags for the resource.
        public let tags: [TagRef]

        public init(nextToken: String? = nil, tags: [TagRef]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct ListVirtualGatewaysInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListVirtualGateways in paginated
        ///          output. When you use this parameter, ListVirtualGateways returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualGateways request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualGateways returns up to 100 results and
        ///          a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual gateways in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualGateways request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualGatewaysOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualGateways", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListVirtualGateways
        ///          request. When the results of a ListVirtualGateways request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual gateways for the specified service mesh.
        public let virtualGateways: [VirtualGatewayRef]

        public init(nextToken: String? = nil, virtualGateways: [VirtualGatewayRef]) {
            self.nextToken = nextToken
            self.virtualGateways = virtualGateways
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualGateways = "virtualGateways"
        }
    }

    public struct ListVirtualNodesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListVirtualNodes in paginated
        ///          output. When you use this parameter, ListVirtualNodes returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualNodes request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualNodes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual nodes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualNodes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualNodesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualNodes", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListVirtualNodes
        ///          request. When the results of a ListVirtualNodes request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual nodes for the specified service mesh.
        public let virtualNodes: [VirtualNodeRef]

        public init(nextToken: String? = nil, virtualNodes: [VirtualNodeRef]) {
            self.nextToken = nextToken
            self.virtualNodes = virtualNodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualNodes = "virtualNodes"
        }
    }

    public struct ListVirtualRoutersInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListVirtualRouters in paginated
        ///          output. When you use this parameter, ListVirtualRouters returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualRouters request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualRouters returns up to 100 results and
        ///          a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual routers in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualRouters request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualRoutersOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualRouters", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListVirtualRouters
        ///          request. When the results of a ListVirtualRouters request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual routers for the specified service mesh.
        public let virtualRouters: [VirtualRouterRef]

        public init(nextToken: String? = nil, virtualRouters: [VirtualRouterRef]) {
            self.nextToken = nextToken
            self.virtualRouters = virtualRouters
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualRouters = "virtualRouters"
        }
    }

    public struct ListVirtualServicesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListVirtualServices in paginated
        ///          output. When you use this parameter, ListVirtualServices returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualServices request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualServices returns up to 100 results and
        ///          a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual services in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualServices request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualServicesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualServices", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListVirtualServices
        ///          request. When the results of a ListVirtualServices request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual services for the specified service mesh.
        public let virtualServices: [VirtualServiceRef]

        public init(nextToken: String? = nil, virtualServices: [VirtualServiceRef]) {
            self.nextToken = nextToken
            self.virtualServices = virtualServices
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualServices = "virtualServices"
        }
    }

    public struct Listener: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "healthCheck", required: false, type: .structure), 
            AWSShapeMember(label: "portMapping", required: true, type: .structure), 
            AWSShapeMember(label: "timeout", required: false, type: .structure), 
            AWSShapeMember(label: "tls", required: false, type: .structure)
        ]

        /// The health check information for the listener.
        public let healthCheck: HealthCheckPolicy?
        /// The port mapping information for the listener.
        public let portMapping: PortMapping
        /// An object that represents timeouts for different protocols.
        public let timeout: ListenerTimeout?
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.
        public let tls: ListenerTls?

        public init(healthCheck: HealthCheckPolicy? = nil, portMapping: PortMapping, timeout: ListenerTimeout? = nil, tls: ListenerTls? = nil) {
            self.healthCheck = healthCheck
            self.portMapping = portMapping
            self.timeout = timeout
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.portMapping.validate(name: "\(name).portMapping")
            try self.timeout?.validate(name: "\(name).timeout")
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
            case portMapping = "portMapping"
            case timeout = "timeout"
            case tls = "tls"
        }
    }

    public struct ListenerTimeout: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "grpc", required: false, type: .structure), 
            AWSShapeMember(label: "http", required: false, type: .structure), 
            AWSShapeMember(label: "http2", required: false, type: .structure), 
            AWSShapeMember(label: "tcp", required: false, type: .structure)
        ]

        public let grpc: GrpcTimeout?
        /// An object that represents types of timeouts. 
        public let http: HttpTimeout?
        /// An object that represents types of timeouts. 
        public let http2: HttpTimeout?
        /// An object that represents types of timeouts. 
        public let tcp: TcpTimeout?

        public init(grpc: GrpcTimeout? = nil, http: HttpTimeout? = nil, http2: HttpTimeout? = nil, tcp: TcpTimeout? = nil) {
            self.grpc = grpc
            self.http = http
            self.http2 = http2
            self.tcp = tcp
        }

        public func validate(name: String) throws {
            try self.grpc?.validate(name: "\(name).grpc")
            try self.http?.validate(name: "\(name).http")
            try self.http2?.validate(name: "\(name).http2")
            try self.tcp?.validate(name: "\(name).tcp")
        }

        private enum CodingKeys: String, CodingKey {
            case grpc = "grpc"
            case http = "http"
            case http2 = "http2"
            case tcp = "tcp"
        }
    }

    public struct ListenerTls: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificate", required: true, type: .structure), 
            AWSShapeMember(label: "mode", required: true, type: .enum)
        ]

        /// A reference to an object that represents a listener's TLS certificate.
        public let certificate: ListenerTlsCertificate
        /// Specify one of the following modes.
        ///          
        ///             
        ///                
        ///                   STRICT – Listener only accepts connections with TLS
        ///                enabled. 
        ///             
        ///             
        ///                
        ///                   PERMISSIVE – Listener accepts connections with or
        ///                without TLS enabled.
        ///             
        ///             
        ///                
        ///                   DISABLED – Listener only accepts connections without
        ///                TLS. 
        ///             
        ///          
        public let mode: ListenerTlsMode

        public init(certificate: ListenerTlsCertificate, mode: ListenerTlsMode) {
            self.certificate = certificate
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.certificate.validate(name: "\(name).certificate")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case mode = "mode"
        }
    }

    public struct ListenerTlsAcmCertificate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
        }
    }

    public struct ListenerTlsCertificate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "acm", required: false, type: .structure), 
            AWSShapeMember(label: "file", required: false, type: .structure)
        ]

        /// A reference to an object that represents an AWS Certicate Manager (ACM) certificate.
        public let acm: ListenerTlsAcmCertificate?
        /// A reference to an object that represents a local file certificate.
        public let file: ListenerTlsFileCertificate?

        public init(acm: ListenerTlsAcmCertificate? = nil, file: ListenerTlsFileCertificate? = nil) {
            self.acm = acm
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
        }
    }

    public struct ListenerTlsFileCertificate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateChain", required: true, type: .string), 
            AWSShapeMember(label: "privateKey", required: true, type: .string)
        ]

        /// The certificate chain for the certificate.
        public let certificateChain: String
        /// The private key for a certificate stored on the file system of the virtual node that the
        ///          proxy is running on.
        public let privateKey: String

        public init(certificateChain: String, privateKey: String) {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }

        public func validate(name: String) throws {
            try validate(self.certificateChain, name:"certificateChain", parent: name, max: 255)
            try validate(self.certificateChain, name:"certificateChain", parent: name, min: 1)
            try validate(self.privateKey, name:"privateKey", parent: name, max: 255)
            try validate(self.privateKey, name:"privateKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
            case privateKey = "privateKey"
        }
    }

    public struct Logging: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessLog", required: false, type: .structure)
        ]

        /// The access log configuration for a virtual node.
        public let accessLog: AccessLog?

        public init(accessLog: AccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "accessLog"
        }
    }

    public struct MatchRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "end", required: true, type: .long), 
            AWSShapeMember(label: "start", required: true, type: .long)
        ]

        /// The end of the range.
        public let end: Int64
        /// The start of the range.
        public let start: Int64

        public init(end: Int64, start: Int64) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct MeshData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure)
        ]

        /// The name of the service mesh.
        public let meshName: String
        /// The associated metadata for the service mesh.
        public let metadata: ResourceMetadata
        /// The associated specification for the service mesh.
        public let spec: MeshSpec
        /// The status of the service mesh.
        public let status: MeshStatus

        public init(meshName: String, metadata: ResourceMetadata, spec: MeshSpec, status: MeshStatus) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
        }
    }

    public struct MeshRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long)
        ]

        /// The full Amazon Resource Name (ARN) of the service mesh.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The name of the service mesh.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshName: String, meshOwner: String, resourceOwner: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
        }
    }

    public struct MeshSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "egressFilter", required: false, type: .structure)
        ]

        /// The egress filter rules for the service mesh.
        public let egressFilter: EgressFilter?

        public init(egressFilter: EgressFilter? = nil) {
            self.egressFilter = egressFilter
        }

        private enum CodingKeys: String, CodingKey {
            case egressFilter = "egressFilter"
        }
    }

    public struct MeshStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]

        /// The current mesh status.
        public let status: MeshStatusCode?

        public init(status: MeshStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct PortMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "port", required: true, type: .integer), 
            AWSShapeMember(label: "protocol", required: true, type: .enum)
        ]

        /// The port used for the port mapping.
        public let port: Int
        /// The protocol used for the port mapping. Specify one protocol.
        public let `protocol`: PortProtocol

        public init(port: Int, protocol: PortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct ResourceMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "uid", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long)
        ]

        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The unique identifier for the resource.
        public let uid: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshOwner: String, resourceOwner: String, uid: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.uid = uid
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case uid = "uid"
            case version = "version"
        }
    }

    public struct RouteData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The associated metadata for the route.
        public let metadata: ResourceMetadata
        /// The name of the route.
        public let routeName: String
        /// The specifications of the route.
        public let spec: RouteSpec
        /// The status of the route.
        public let status: RouteStatus
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, routeName: String, spec: RouteSpec, status: RouteStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.routeName = routeName
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case routeName = "routeName"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the route.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The name of the route.
        public let routeName: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshName: String, meshOwner: String, resourceOwner: String, routeName: String, version: Int64, virtualRouterName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.routeName = routeName
            self.version = version
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case routeName = "routeName"
            case version = "version"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "grpcRoute", required: false, type: .structure), 
            AWSShapeMember(label: "http2Route", required: false, type: .structure), 
            AWSShapeMember(label: "httpRoute", required: false, type: .structure), 
            AWSShapeMember(label: "priority", required: false, type: .integer), 
            AWSShapeMember(label: "tcpRoute", required: false, type: .structure)
        ]

        /// An object that represents the specification of a gRPC route.
        public let grpcRoute: GrpcRoute?
        /// An object that represents the specification of an HTTP/2 route.
        public let http2Route: HttpRoute?
        /// An object that represents the specification of an HTTP route.
        public let httpRoute: HttpRoute?
        /// The priority for the route. Routes are matched based on the specified value, where 0 is
        ///          the highest priority.
        public let priority: Int?
        /// An object that represents the specification of a TCP route.
        public let tcpRoute: TcpRoute?

        public init(grpcRoute: GrpcRoute? = nil, http2Route: HttpRoute? = nil, httpRoute: HttpRoute? = nil, priority: Int? = nil, tcpRoute: TcpRoute? = nil) {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
            self.tcpRoute = tcpRoute
        }

        public func validate(name: String) throws {
            try self.grpcRoute?.validate(name: "\(name).grpcRoute")
            try self.http2Route?.validate(name: "\(name).http2Route")
            try self.httpRoute?.validate(name: "\(name).httpRoute")
            try validate(self.priority, name:"priority", parent: name, max: 1000)
            try validate(self.priority, name:"priority", parent: name, min: 0)
            try self.tcpRoute?.validate(name: "\(name).tcpRoute")
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRoute = "grpcRoute"
            case http2Route = "http2Route"
            case httpRoute = "httpRoute"
            case priority = "priority"
            case tcpRoute = "tcpRoute"
        }
    }

    public struct RouteStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status for the route.
        public let status: RouteStatusCode

        public init(status: RouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct ServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "awsCloudMap", required: false, type: .structure), 
            AWSShapeMember(label: "dns", required: false, type: .structure)
        ]

        /// Specifies any AWS Cloud Map information for the virtual node.
        public let awsCloudMap: AwsCloudMapServiceDiscovery?
        /// Specifies the DNS information for the virtual node.
        public let dns: DnsServiceDiscovery?

        public init(awsCloudMap: AwsCloudMapServiceDiscovery? = nil, dns: DnsServiceDiscovery? = nil) {
            self.awsCloudMap = awsCloudMap
            self.dns = dns
        }

        public func validate(name: String) throws {
            try self.awsCloudMap?.validate(name: "\(name).awsCloudMap")
        }

        private enum CodingKeys: String, CodingKey {
            case awsCloudMap = "awsCloudMap"
            case dns = "dns"
        }
    }

    public struct TagRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: true, type: .string), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]

        /// One part of a key-value pair that make up a tag. A key is a general label
        ///          that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that make up a tag. A value acts as a
        ///          descriptor within a tag category (key).
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 128)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .querystring(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) of the resource to add tags to.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs.
        ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]

        public init(resourceArn: String, tags: [TagRef]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSShape {


        public init() {
        }

    }

    public struct TcpRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "action", required: true, type: .structure), 
            AWSShapeMember(label: "timeout", required: false, type: .structure)
        ]

        /// The action to take if a match is determined.
        public let action: TcpRouteAction
        /// An object that represents types of timeouts. 
        public let timeout: TcpTimeout?

        public init(action: TcpRouteAction, timeout: TcpTimeout? = nil) {
            self.action = action
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case timeout = "timeout"
        }
    }

    public struct TcpRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "weightedTargets", required: true, type: .list)
        ]

        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct TcpTimeout: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "idle", required: false, type: .structure)
        ]

        public let idle: Duration?

        public init(idle: Duration? = nil) {
            self.idle = idle
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
        }

        private enum CodingKeys: String, CodingKey {
            case idle = "idle"
        }
    }

    public struct TlsValidationContext: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "trust", required: true, type: .structure)
        ]

        /// A reference to an object that represents a TLS validation context trust.
        public let trust: TlsValidationContextTrust

        public init(trust: TlsValidationContextTrust) {
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case trust = "trust"
        }
    }

    public struct TlsValidationContextAcmTrust: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateAuthorityArns", required: true, type: .list)
        ]

        /// One or more ACM Amazon Resource Name (ARN)s.
        public let certificateAuthorityArns: [String]

        public init(certificateAuthorityArns: [String]) {
            self.certificateAuthorityArns = certificateAuthorityArns
        }

        public func validate(name: String) throws {
            try validate(self.certificateAuthorityArns, name:"certificateAuthorityArns", parent: name, max: 3)
            try validate(self.certificateAuthorityArns, name:"certificateAuthorityArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArns = "certificateAuthorityArns"
        }
    }

    public struct TlsValidationContextFileTrust: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateChain", required: true, type: .string)
        ]

        /// The certificate trust chain for a certificate stored on the file system of the virtual
        ///          node that the proxy is running on.
        public let certificateChain: String

        public init(certificateChain: String) {
            self.certificateChain = certificateChain
        }

        public func validate(name: String) throws {
            try validate(self.certificateChain, name:"certificateChain", parent: name, max: 255)
            try validate(self.certificateChain, name:"certificateChain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
        }
    }

    public struct TlsValidationContextTrust: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "acm", required: false, type: .structure), 
            AWSShapeMember(label: "file", required: false, type: .structure)
        ]

        /// A reference to an object that represents a TLS validation context trust for an AWS Certicate Manager (ACM)
        ///          certificate.
        public let acm: TlsValidationContextAcmTrust?
        /// An object that represents a TLS validation context trust for a local file.
        public let file: TlsValidationContextFileTrust?

        public init(acm: TlsValidationContextAcmTrust? = nil, file: TlsValidationContextFileTrust? = nil) {
            self.acm = acm
            self.file = file
        }

        public func validate(name: String) throws {
            try self.acm?.validate(name: "\(name).acm")
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
        }
    }

    public struct UntagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .querystring(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tagKeys", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) of the resource to delete tags from.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceOutput: AWSShape {


        public init() {
        }

    }

    public struct UpdateGatewayRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "gatewayRouteName", location: .uri(locationName: "gatewayRouteName"), required: true, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the gateway route to update.
        public let gatewayRouteName: String
        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new gateway route specification to apply. This overwrites the existing data.
        public let spec: GatewayRouteSpec
        /// The name of the virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(clientToken: String? = UpdateGatewayRouteInput.idempotencyToken(), gatewayRouteName: String, meshName: String, meshOwner: String? = nil, spec: GatewayRouteSpec, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, max: 255)
            try validate(self.gatewayRouteName, name:"gatewayRouteName", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case gatewayRouteName = "gatewayRouteName"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct UpdateGatewayRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "gatewayRoute"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "gatewayRoute", required: true, type: .structure)
        ]

        /// A full description of the gateway route that was updated.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute = "gatewayRoute"
        }
    }

    public struct UpdateMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: false, type: .structure)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to update.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?

        public init(clientToken: String? = UpdateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
        }
    }

    public struct UpdateMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct UpdateRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to update.
        public let routeName: String
        /// The new route specification to apply. This overwrites the existing data.
        public let spec: RouteSpec
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case routeName = "routeName"
            case spec = "spec"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct UpdateRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// A full description of the route that was updated.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct UpdateVirtualGatewayInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual gateway resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual gateway specification to apply. This overwrites the existing
        ///          data.
        public let spec: VirtualGatewaySpec
        /// The name of the virtual gateway to update.
        public let virtualGatewayName: String

        public init(clientToken: String? = UpdateVirtualGatewayInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualGatewaySpec, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, max: 255)
            try validate(self.virtualGatewayName, name:"virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct UpdateVirtualGatewayOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualGateway"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualGateway", required: true, type: .structure)
        ]

        /// A full description of the virtual gateway that was updated.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway = "virtualGateway"
        }
    }

    public struct UpdateVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual node specification to apply. This overwrites the existing data.
        public let spec: VirtualNodeSpec
        /// The name of the virtual node to update.
        public let virtualNodeName: String

        public init(clientToken: String? = UpdateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct UpdateVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// A full description of the virtual node that was updated.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct UpdateVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual router specification to apply. This overwrites the existing data.
        public let spec: VirtualRouterSpec
        /// The name of the virtual router to update.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct UpdateVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// A full description of the virtual router that was updated.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct UpdateVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", location: .querystring(locationName: "meshOwner"), required: false, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual service specification to apply. This overwrites the existing
        ///          data.
        public let spec: VirtualServiceSpec
        /// The name of the virtual service to update.
        public let virtualServiceName: String

        public init(clientToken: String? = UpdateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.meshOwner, name:"meshOwner", parent: name, max: 12)
            try validate(self.meshOwner, name:"meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case spec = "spec"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct UpdateVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// A full description of the virtual service that was updated.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct VirtualGatewayAccessLog: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "file", required: false, type: .structure)
        ]

        /// The file object to send virtual gateway access logs to.
        public let file: VirtualGatewayFileAccessLog?

        public init(file: VirtualGatewayFileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }

    public struct VirtualGatewayBackendDefaults: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientPolicy", required: false, type: .structure)
        ]

        /// A reference to an object that represents a client policy.
        public let clientPolicy: VirtualGatewayClientPolicy?

        public init(clientPolicy: VirtualGatewayClientPolicy? = nil) {
            self.clientPolicy = clientPolicy
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
        }
    }

    public struct VirtualGatewayClientPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "tls", required: false, type: .structure)
        ]

        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public let tls: VirtualGatewayClientPolicyTls?

        public init(tls: VirtualGatewayClientPolicyTls? = nil) {
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case tls = "tls"
        }
    }

    public struct VirtualGatewayClientPolicyTls: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "enforce", required: false, type: .boolean), 
            AWSShapeMember(label: "ports", required: false, type: .list), 
            AWSShapeMember(label: "validation", required: true, type: .structure)
        ]

        /// Whether the policy is enforced. The default is True, if a value isn't
        ///          specified.
        public let enforce: Bool?
        /// One or more ports that the policy is enforced for.
        public let ports: [Int]?
        /// A reference to an object that represents a TLS validation context.
        public let validation: VirtualGatewayTlsValidationContext

        public init(enforce: Bool? = nil, ports: [Int]? = nil, validation: VirtualGatewayTlsValidationContext) {
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.ports?.forEach {
                try validate($0, name: "ports[]", parent: name, max: 65535)
                try validate($0, name: "ports[]", parent: name, min: 1)
            }
            try self.validation.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case enforce = "enforce"
            case ports = "ports"
            case validation = "validation"
        }
    }

    public struct VirtualGatewayData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualGatewayName", required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual gateway resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual gateway.
        public let spec: VirtualGatewaySpec
        /// The current status of the virtual gateway.
        public let status: VirtualGatewayStatus
        /// The name of the virtual gateway.
        public let virtualGatewayName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualGatewaySpec, status: VirtualGatewayStatus, virtualGatewayName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct VirtualGatewayFileAccessLog: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "path", required: true, type: .string)
        ]

        /// The file path to write access logs to. You can use /dev/stdout to send
        ///          access logs to standard out and configure your Envoy container to use a log driver, such as
        ///             awslogs, to export the access logs to a log storage service such as Amazon
        ///          CloudWatch Logs. You can also specify a path in the Envoy container's file system to write
        ///          the files to disk.
        public let path: String

        public init(path: String) {
            self.path = path
        }

        public func validate(name: String) throws {
            try validate(self.path, name:"path", parent: name, max: 255)
            try validate(self.path, name:"path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
        }
    }

    public struct VirtualGatewayHealthCheckPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "healthyThreshold", required: true, type: .integer), 
            AWSShapeMember(label: "intervalMillis", required: true, type: .long), 
            AWSShapeMember(label: "path", required: false, type: .string), 
            AWSShapeMember(label: "port", required: false, type: .integer), 
            AWSShapeMember(label: "protocol", required: true, type: .enum), 
            AWSShapeMember(label: "timeoutMillis", required: true, type: .long), 
            AWSShapeMember(label: "unhealthyThreshold", required: true, type: .integer)
        ]

        /// The number of consecutive successful health checks that must occur before declaring the
        ///          listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This value is only used if the
        ///          specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined
        ///          in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request. If you specify grpc, then your
        ///          service must conform to the GRPC Health
        ///             Checking Protocol.
        public let `protocol`: VirtualGatewayPortProtocol
        /// The amount of time to wait when receiving a response from the health check, in
        ///          milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a
        ///          virtual gateway unhealthy.
        public let unhealthyThreshold: Int

        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: VirtualGatewayPortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, max: 10)
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, min: 2)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, max: 300000)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, min: 5000)
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, max: 60000)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, min: 2000)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, max: 10)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "healthyThreshold"
            case intervalMillis = "intervalMillis"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case timeoutMillis = "timeoutMillis"
            case unhealthyThreshold = "unhealthyThreshold"
        }
    }

    public struct VirtualGatewayListener: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "healthCheck", required: false, type: .structure), 
            AWSShapeMember(label: "portMapping", required: true, type: .structure), 
            AWSShapeMember(label: "tls", required: false, type: .structure)
        ]

        /// The health check information for the listener.
        public let healthCheck: VirtualGatewayHealthCheckPolicy?
        /// The port mapping information for the listener.
        public let portMapping: VirtualGatewayPortMapping
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for the listener.
        public let tls: VirtualGatewayListenerTls?

        public init(healthCheck: VirtualGatewayHealthCheckPolicy? = nil, portMapping: VirtualGatewayPortMapping, tls: VirtualGatewayListenerTls? = nil) {
            self.healthCheck = healthCheck
            self.portMapping = portMapping
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.portMapping.validate(name: "\(name).portMapping")
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
            case portMapping = "portMapping"
            case tls = "tls"
        }
    }

    public struct VirtualGatewayListenerTls: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificate", required: true, type: .structure), 
            AWSShapeMember(label: "mode", required: true, type: .enum)
        ]

        /// An object that represents a Transport Layer Security (TLS) certificate.
        public let certificate: VirtualGatewayListenerTlsCertificate
        /// Specify one of the following modes.
        ///          
        ///             
        ///                
        ///                   STRICT – Listener only accepts connections with TLS
        ///                enabled. 
        ///             
        ///             
        ///                
        ///                   PERMISSIVE – Listener accepts connections with or
        ///                without TLS enabled.
        ///             
        ///             
        ///                
        ///                   DISABLED – Listener only accepts connections without
        ///                TLS. 
        ///             
        ///          
        public let mode: VirtualGatewayListenerTlsMode

        public init(certificate: VirtualGatewayListenerTlsCertificate, mode: VirtualGatewayListenerTlsMode) {
            self.certificate = certificate
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.certificate.validate(name: "\(name).certificate")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case mode = "mode"
        }
    }

    public struct VirtualGatewayListenerTlsAcmCertificate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateArn", required: true, type: .string)
        ]

        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
        }
    }

    public struct VirtualGatewayListenerTlsCertificate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "acm", required: false, type: .structure), 
            AWSShapeMember(label: "file", required: false, type: .structure)
        ]

        /// A reference to an object that represents an AWS Certicate Manager (ACM) certificate.
        public let acm: VirtualGatewayListenerTlsAcmCertificate?
        /// A reference to an object that represents a local file certificate.
        public let file: VirtualGatewayListenerTlsFileCertificate?

        public init(acm: VirtualGatewayListenerTlsAcmCertificate? = nil, file: VirtualGatewayListenerTlsFileCertificate? = nil) {
            self.acm = acm
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
        }
    }

    public struct VirtualGatewayListenerTlsFileCertificate: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateChain", required: true, type: .string), 
            AWSShapeMember(label: "privateKey", required: true, type: .string)
        ]

        /// The certificate chain for the certificate.
        public let certificateChain: String
        /// The private key for a certificate stored on the file system of the mesh endpoint that
        ///          the proxy is running on.
        public let privateKey: String

        public init(certificateChain: String, privateKey: String) {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }

        public func validate(name: String) throws {
            try validate(self.certificateChain, name:"certificateChain", parent: name, max: 255)
            try validate(self.certificateChain, name:"certificateChain", parent: name, min: 1)
            try validate(self.privateKey, name:"privateKey", parent: name, max: 255)
            try validate(self.privateKey, name:"privateKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
            case privateKey = "privateKey"
        }
    }

    public struct VirtualGatewayLogging: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessLog", required: false, type: .structure)
        ]

        /// The access log configuration.
        public let accessLog: VirtualGatewayAccessLog?

        public init(accessLog: VirtualGatewayAccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "accessLog"
        }
    }

    public struct VirtualGatewayPortMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "port", required: true, type: .integer), 
            AWSShapeMember(label: "protocol", required: true, type: .enum)
        ]

        /// The port used for the port mapping. Specify one protocol.
        public let port: Int
        /// The protocol used for the port mapping.
        public let `protocol`: VirtualGatewayPortProtocol

        public init(port: Int, protocol: VirtualGatewayPortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct VirtualGatewayRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long), 
            AWSShapeMember(label: "virtualGatewayName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The name of the service mesh that the resource resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the resource.
        public let virtualGatewayName: String

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualGatewayName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct VirtualGatewaySpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "backendDefaults", required: false, type: .structure), 
            AWSShapeMember(label: "listeners", required: true, type: .list), 
            AWSShapeMember(label: "logging", required: false, type: .structure)
        ]

        /// A reference to an object that represents the defaults for backends.
        public let backendDefaults: VirtualGatewayBackendDefaults?
        /// The listeners that the mesh endpoint is expected to receive inbound traffic from. You
        ///          can specify one listener.
        public let listeners: [VirtualGatewayListener]
        public let logging: VirtualGatewayLogging?

        public init(backendDefaults: VirtualGatewayBackendDefaults? = nil, listeners: [VirtualGatewayListener], logging: VirtualGatewayLogging? = nil) {
            self.backendDefaults = backendDefaults
            self.listeners = listeners
            self.logging = logging
        }

        public func validate(name: String) throws {
            try self.backendDefaults?.validate(name: "\(name).backendDefaults")
            try self.listeners.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try validate(self.listeners, name:"listeners", parent: name, max: 1)
            try validate(self.listeners, name:"listeners", parent: name, min: 0)
            try self.logging?.validate(name: "\(name).logging")
        }

        private enum CodingKeys: String, CodingKey {
            case backendDefaults = "backendDefaults"
            case listeners = "listeners"
            case logging = "logging"
        }
    }

    public struct VirtualGatewayStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status.
        public let status: VirtualGatewayStatusCode

        public init(status: VirtualGatewayStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualGatewayTlsValidationContext: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "trust", required: true, type: .structure)
        ]

        /// A reference to an object that represents a TLS validation context trust.
        public let trust: VirtualGatewayTlsValidationContextTrust

        public init(trust: VirtualGatewayTlsValidationContextTrust) {
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case trust = "trust"
        }
    }

    public struct VirtualGatewayTlsValidationContextAcmTrust: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateAuthorityArns", required: true, type: .list)
        ]

        /// One or more ACM Amazon Resource Name (ARN)s.
        public let certificateAuthorityArns: [String]

        public init(certificateAuthorityArns: [String]) {
            self.certificateAuthorityArns = certificateAuthorityArns
        }

        public func validate(name: String) throws {
            try validate(self.certificateAuthorityArns, name:"certificateAuthorityArns", parent: name, max: 3)
            try validate(self.certificateAuthorityArns, name:"certificateAuthorityArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArns = "certificateAuthorityArns"
        }
    }

    public struct VirtualGatewayTlsValidationContextFileTrust: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "certificateChain", required: true, type: .string)
        ]

        /// The certificate trust chain for a certificate stored on the file system of the virtual
        ///          node that the proxy is running on.
        public let certificateChain: String

        public init(certificateChain: String) {
            self.certificateChain = certificateChain
        }

        public func validate(name: String) throws {
            try validate(self.certificateChain, name:"certificateChain", parent: name, max: 255)
            try validate(self.certificateChain, name:"certificateChain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
        }
    }

    public struct VirtualGatewayTlsValidationContextTrust: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "acm", required: false, type: .structure), 
            AWSShapeMember(label: "file", required: false, type: .structure)
        ]

        /// A reference to an object that represents a TLS validation context trust for an AWS Certicate Manager (ACM)
        ///          certificate.
        public let acm: VirtualGatewayTlsValidationContextAcmTrust?
        /// An object that represents a TLS validation context trust for a local file.
        public let file: VirtualGatewayTlsValidationContextFileTrust?

        public init(acm: VirtualGatewayTlsValidationContextAcmTrust? = nil, file: VirtualGatewayTlsValidationContextFileTrust? = nil) {
            self.acm = acm
            self.file = file
        }

        public func validate(name: String) throws {
            try self.acm?.validate(name: "\(name).acm")
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
        }
    }

    public struct VirtualNodeData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The associated metadata for the virtual node.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual node.
        public let spec: VirtualNodeSpec
        /// The current status for the virtual node.
        public let status: VirtualNodeStatus
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualNodeSpec, status: VirtualNodeStatus, virtualNodeName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long), 
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the virtual node.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualNodeName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeServiceProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// The name of the virtual node that is acting as a service provider.
        public let virtualNodeName: String

        public init(virtualNodeName: String) {
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "backendDefaults", required: false, type: .structure), 
            AWSShapeMember(label: "backends", required: false, type: .list), 
            AWSShapeMember(label: "listeners", required: false, type: .list), 
            AWSShapeMember(label: "logging", required: false, type: .structure), 
            AWSShapeMember(label: "serviceDiscovery", required: false, type: .structure)
        ]

        /// A reference to an object that represents the defaults for backends.
        public let backendDefaults: BackendDefaults?
        /// The backends that the virtual node is expected to send outbound traffic to.
        public let backends: [Backend]?
        /// The listener that the virtual node is expected to receive inbound traffic from. You can
        ///          specify one listener.
        public let listeners: [Listener]?
        /// The inbound and outbound access logging information for the virtual node.
        public let logging: Logging?
        /// The service discovery information for the virtual node. If your virtual node does not
        ///          expect ingress traffic, you can omit this parameter. If you specify a
        ///          listener, then you must specify service discovery information.
        public let serviceDiscovery: ServiceDiscovery?

        public init(backendDefaults: BackendDefaults? = nil, backends: [Backend]? = nil, listeners: [Listener]? = nil, logging: Logging? = nil, serviceDiscovery: ServiceDiscovery? = nil) {
            self.backendDefaults = backendDefaults
            self.backends = backends
            self.listeners = listeners
            self.logging = logging
            self.serviceDiscovery = serviceDiscovery
        }

        public func validate(name: String) throws {
            try self.backendDefaults?.validate(name: "\(name).backendDefaults")
            try self.backends?.forEach {
                try $0.validate(name: "\(name).backends[]")
            }
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try validate(self.listeners, name:"listeners", parent: name, max: 1)
            try validate(self.listeners, name:"listeners", parent: name, min: 0)
            try self.logging?.validate(name: "\(name).logging")
            try self.serviceDiscovery?.validate(name: "\(name).serviceDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case backendDefaults = "backendDefaults"
            case backends = "backends"
            case listeners = "listeners"
            case logging = "logging"
            case serviceDiscovery = "serviceDiscovery"
        }
    }

    public struct VirtualNodeStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status of the virtual node.
        public let status: VirtualNodeStatusCode

        public init(status: VirtualNodeStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualRouterData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The associated metadata for the virtual router.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual router.
        public let spec: VirtualRouterSpec
        /// The current status of the virtual router.
        public let status: VirtualRouterStatus
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualRouterSpec, status: VirtualRouterStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterListener: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "portMapping", required: true, type: .structure)
        ]

        public let portMapping: PortMapping

        public init(portMapping: PortMapping) {
            self.portMapping = portMapping
        }

        public func validate(name: String) throws {
            try self.portMapping.validate(name: "\(name).portMapping")
        }

        private enum CodingKeys: String, CodingKey {
            case portMapping = "portMapping"
        }
    }

    public struct VirtualRouterRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the virtual router.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualRouterName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterServiceProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The name of the virtual router that is acting as a service provider.
        public let virtualRouterName: String

        public init(virtualRouterName: String) {
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "listeners", required: false, type: .list)
        ]

        /// The listeners that the virtual router is expected to receive inbound traffic from. You
        ///          can specify one listener.
        public let listeners: [VirtualRouterListener]?

        public init(listeners: [VirtualRouterListener]? = nil) {
            self.listeners = listeners
        }

        public func validate(name: String) throws {
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try validate(self.listeners, name:"listeners", parent: name, max: 1)
            try validate(self.listeners, name:"listeners", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "listeners"
        }
    }

    public struct VirtualRouterStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status of the virtual router.
        public let status: VirtualRouterStatusCode

        public init(status: VirtualRouterStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualServiceBackend: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientPolicy", required: false, type: .structure), 
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// A reference to an object that represents the client policy for a backend.
        public let clientPolicy: ClientPolicy?
        /// The name of the virtual service that is acting as a virtual node backend.
        public let virtualServiceName: String

        public init(clientPolicy: ClientPolicy? = nil, virtualServiceName: String) {
            self.clientPolicy = clientPolicy
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual service.
        public let spec: VirtualServiceSpec
        /// The current status of the virtual service.
        public let status: VirtualServiceStatus
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualServiceSpec, status: VirtualServiceStatus, virtualServiceName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: false, type: .structure), 
            AWSShapeMember(label: "virtualRouter", required: false, type: .structure)
        ]

        /// The virtual node associated with a virtual service.
        public let virtualNode: VirtualNodeServiceProvider?
        /// The virtual router associated with a virtual service.
        public let virtualRouter: VirtualRouterServiceProvider?

        public init(virtualNode: VirtualNodeServiceProvider? = nil, virtualRouter: VirtualRouterServiceProvider? = nil) {
            self.virtualNode = virtualNode
            self.virtualRouter = virtualRouter
        }

        public func validate(name: String) throws {
            try self.virtualNode?.validate(name: "\(name).virtualNode")
            try self.virtualRouter?.validate(name: "\(name).virtualRouter")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case virtualRouter = "virtualRouter"
        }
    }

    public struct VirtualServiceRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "meshOwner", required: true, type: .string), 
            AWSShapeMember(label: "resourceOwner", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long), 
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the virtual service.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
        ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
        ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualServiceName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "provider", required: false, type: .structure)
        ]

        /// The App Mesh object that is acting as the provider for a virtual service. You can specify
        ///          a single virtual node or virtual router.
        public let provider: VirtualServiceProvider?

        public init(provider: VirtualServiceProvider? = nil) {
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.provider?.validate(name: "\(name).provider")
        }

        private enum CodingKeys: String, CodingKey {
            case provider = "provider"
        }
    }

    public struct VirtualServiceStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status of the virtual service.
        public let status: VirtualServiceStatusCode

        public init(status: VirtualServiceStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct WeightedTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .string), 
            AWSShapeMember(label: "weight", required: true, type: .integer)
        ]

        /// The virtual node to associate with the weighted target.
        public let virtualNode: String
        /// The relative weight of the weighted target.
        public let weight: Int

        public init(virtualNode: String, weight: Int) {
            self.virtualNode = virtualNode
            self.weight = weight
        }

        public func validate(name: String) throws {
            try validate(self.virtualNode, name:"virtualNode", parent: name, max: 255)
            try validate(self.virtualNode, name:"virtualNode", parent: name, min: 1)
            try validate(self.weight, name:"weight", parent: name, max: 100)
            try validate(self.weight, name:"weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case weight = "weight"
        }
    }
}

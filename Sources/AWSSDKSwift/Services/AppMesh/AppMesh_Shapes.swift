// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/master/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import Foundation
import AWSSDKSwiftCore

extension AppMesh {

    public struct AccessLog: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "file", required: false, type: .structure)
        ]

        /// The file object to send virtual node access logs to.
        public let file: FileAccessLog?

        public init(file: FileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }

    public struct AwsCloudMapInstanceAttribute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: true, type: .string), 
            AWSShapeMember(label: "value", required: true, type: .string)
        ]

        /// The name of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service instance
        ///          that contains the specified key and value is returned.
        public let key: String
        /// The value of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service
        ///          instance that contains the specified key and value is returned.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 255)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.key, name:"key", parent: name, pattern: "^[a-zA-Z0-9!-~]+$")
            try validate(self.value, name:"value", parent: name, max: 1024)
            try validate(self.value, name:"value", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, pattern: "^([a-zA-Z0-9!-~][ ta-zA-Z0-9!-~]*){0,1}[a-zA-Z0-9!-~]{0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct AwsCloudMapServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "attributes", required: false, type: .list), 
            AWSShapeMember(label: "namespaceName", required: true, type: .string), 
            AWSShapeMember(label: "serviceName", required: true, type: .string)
        ]

        /// A string map that contains attributes with values that you can use to filter instances
        ///          by any custom attribute that you specified when you registered the instance. Only instances
        ///          that match all of the specified key/value pairs will be returned.
        public let attributes: [AwsCloudMapInstanceAttribute]?
        /// The name of the AWS Cloud Map namespace to use.
        public let namespaceName: String
        /// The name of the AWS Cloud Map service to use.
        public let serviceName: String

        public init(attributes: [AwsCloudMapInstanceAttribute]? = nil, namespaceName: String, serviceName: String) {
            self.attributes = attributes
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try validate(self.namespaceName, name:"namespaceName", parent: name, max: 1024)
            try validate(self.namespaceName, name:"namespaceName", parent: name, min: 1)
            try validate(self.namespaceName, name:"namespaceName", parent: name, pattern: "((?=^.{1,127}$)^([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9])(.([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9]))*$)|(^.$)")
            try validate(self.serviceName, name:"serviceName", parent: name, max: 1024)
            try validate(self.serviceName, name:"serviceName", parent: name, min: 1)
            try validate(self.serviceName, name:"serviceName", parent: name, pattern: "((?=^.{1,127}$)^([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9])(.([a-zA-Z0-9_][a-zA-Z0-9-_]{0,61}[a-zA-Z0-9_]|[a-zA-Z0-9]))*$)|(^.$)")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case namespaceName = "namespaceName"
            case serviceName = "serviceName"
        }
    }

    public struct Backend: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: false, type: .structure)
        ]

        /// Specifies a virtual service to use as a backend for a virtual node. 
        public let virtualService: VirtualServiceBackend?

        public init(virtualService: VirtualServiceBackend? = nil) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct CreateMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: false, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the service mesh.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?
        /// Optional metadata that you can apply to the service mesh to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?

        public init(clientToken: String? = CreateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil, tags: [TagRef]? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case tags = "tags"
        }
    }

    public struct CreateMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        /// The full description of your service mesh following the create call.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct CreateRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the route in.
        public let meshName: String
        /// The name to use for the route.
        public let routeName: String
        /// The route specification to apply.
        public let spec: RouteSpec
        /// Optional metadata that you can apply to the route to assist with categorization and
        ///          organization. Each tag consists of a key and an optional value, both of which you define.
        ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual router in which to create the route.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateRouteInput.idempotencyToken(), meshName: String, routeName: String, spec: RouteSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.routeName = routeName
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case routeName = "routeName"
            case spec = "spec"
            case tags = "tags"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct CreateRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// The full description of your mesh following the create call.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct CreateVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual node in.
        public let meshName: String
        /// The virtual node specification to apply.
        public let spec: VirtualNodeSpec
        /// Optional metadata that you can apply to the virtual node to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual node.
        public let virtualNodeName: String

        public init(clientToken: String? = CreateVirtualNodeInput.idempotencyToken(), meshName: String, spec: VirtualNodeSpec, tags: [TagRef]? = nil, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case tags = "tags"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct CreateVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// The full description of your virtual node following the create call.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct CreateVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual router in.
        public let meshName: String
        /// The virtual router specification to apply.
        public let spec: VirtualRouterSpec
        /// Optional metadata that you can apply to the virtual router to assist with categorization
        ///          and organization. Each tag consists of a key and an optional value, both of which you
        ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual router.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateVirtualRouterInput.idempotencyToken(), meshName: String, spec: VirtualRouterSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case tags = "tags"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct CreateVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// The full description of your virtual router following the create call.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct CreateVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "tags", required: false, type: .list), 
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual service in.
        public let meshName: String
        /// The virtual service specification to apply.
        public let spec: VirtualServiceSpec
        /// Optional metadata that you can apply to the virtual service to assist with
        ///          categorization and organization. Each tag consists of a key and an optional value, both of
        ///          which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual service.
        public let virtualServiceName: String

        public init(clientToken: String? = CreateVirtualServiceInput.idempotencyToken(), meshName: String, spec: VirtualServiceSpec, tags: [TagRef]? = nil, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case tags = "tags"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct CreateVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// The full description of your virtual service following the create call.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DeleteMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete.
        public let meshName: String

        public init(meshName: String) {
            self.meshName = meshName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
        }
    }

    public struct DeleteMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        /// The service mesh that was deleted.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct DeleteRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the route in.
        public let meshName: String
        /// The name of the route to delete.
        public let routeName: String
        /// The name of the virtual router to delete the route in.
        public let virtualRouterName: String

        public init(meshName: String, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DeleteRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// The route that was deleted.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct DeleteVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the virtual node in.
        public let meshName: String
        /// The name of the virtual node to delete.
        public let virtualNodeName: String

        public init(meshName: String, virtualNodeName: String) {
            self.meshName = meshName
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct DeleteVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// The virtual node that was deleted.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DeleteVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the virtual router in.
        public let meshName: String
        /// The name of the virtual router to delete.
        public let virtualRouterName: String

        public init(meshName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DeleteVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// The virtual router that was deleted.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DeleteVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"), required: true, type: .string)
        ]

        /// The name of the service mesh to delete the virtual service in.
        public let meshName: String
        /// The name of the virtual service to delete.
        public let virtualServiceName: String

        public init(meshName: String, virtualServiceName: String) {
            self.meshName = meshName
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct DeleteVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// The virtual service that was deleted.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DescribeMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string)
        ]

        /// The name of the service mesh to describe.
        public let meshName: String

        public init(meshName: String) {
            self.meshName = meshName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
        }
    }

    public struct DescribeMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        /// The full description of your service mesh.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct DescribeRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The name of the route to describe.
        public let routeName: String
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DescribeRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// The full description of your route.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct DescribeVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The name of the virtual node to describe.
        public let virtualNodeName: String

        public init(meshName: String, virtualNodeName: String) {
            self.meshName = meshName
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct DescribeVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// The full description of your virtual node.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct DescribeVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The name of the virtual router to describe.
        public let virtualRouterName: String

        public init(meshName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct DescribeVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// The full description of your virtual router.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct DescribeVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"), required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The name of the virtual service to describe.
        public let virtualServiceName: String

        public init(meshName: String, virtualServiceName: String) {
            self.meshName = meshName
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct DescribeVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// The full description of your virtual service.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct DnsServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "hostname", required: true, type: .string)
        ]

        /// Specifies the DNS service discovery hostname for the virtual node. 
        public let hostname: String

        public init(hostname: String) {
            self.hostname = hostname
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
        }
    }

    public struct Duration: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "unit", required: false, type: .enum), 
            AWSShapeMember(label: "value", required: false, type: .long)
        ]

        /// The unit of time between retry attempts.
        public let unit: DurationUnit?
        /// The duration of time between retry attempts.
        public let value: Int64?

        public init(unit: DurationUnit? = nil, value: Int64? = nil) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public enum DurationUnit: String, CustomStringConvertible, Codable {
        case ms = "ms"
        case s = "s"
        public var description: String { return self.rawValue }
    }

    public struct EgressFilter: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "type", required: true, type: .enum)
        ]

        /// The egress filter type. By default, the type is DROP_ALL, which allows
        ///          egress only from virtual nodes to other defined resources in the service mesh (and any
        ///          traffic to *.amazonaws.com for AWS API calls). You can set the egress filter
        ///          type to ALLOW_ALL to allow egress to any endpoint inside or outside of the
        ///          service mesh.
        public let `type`: EgressFilterType

        public init(type: EgressFilterType) {
            self.`type` = `type`
        }

        private enum CodingKeys: String, CodingKey {
            case `type` = "type"
        }
    }

    public enum EgressFilterType: String, CustomStringConvertible, Codable {
        case allowAll = "ALLOW_ALL"
        case dropAll = "DROP_ALL"
        public var description: String { return self.rawValue }
    }

    public struct FileAccessLog: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "path", required: true, type: .string)
        ]

        /// The file path to write access logs to. You can use /dev/stdout to send
        ///          access logs to standard out and configure your Envoy container to use a log driver, such as
        ///             awslogs, to export the access logs to a log storage service such as Amazon
        ///          CloudWatch Logs. You can also specify a path in the Envoy container's file system to write
        ///          the files to disk.
        ///          
        ///             The Envoy process must have write permissions to the path that you specify here.
        ///             Otherwise, Envoy fails to bootstrap properly.
        ///          
        public let path: String

        public init(path: String) {
            self.path = path
        }

        public func validate(name: String) throws {
            try validate(self.path, name:"path", parent: name, max: 255)
            try validate(self.path, name:"path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
        }
    }

    public struct HeaderMatchMethod: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "exact", required: false, type: .string), 
            AWSShapeMember(label: "prefix", required: false, type: .string), 
            AWSShapeMember(label: "range", required: false, type: .structure), 
            AWSShapeMember(label: "regex", required: false, type: .string), 
            AWSShapeMember(label: "suffix", required: false, type: .string)
        ]

        /// The header value sent by the client must match the specified value exactly.
        public let exact: String?
        /// The header value sent by the client must begin with the specified characters.
        public let prefix: String?
        /// The object that specifies the range of numbers that the header value sent by the client must be included in.
        public let range: MatchRange?
        /// The header value sent by the client must include the specified characters.
        public let regex: String?
        /// The header value sent by the client must end with the specified characters.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try validate(self.exact, name:"exact", parent: name, max: 255)
            try validate(self.exact, name:"exact", parent: name, min: 1)
            try validate(self.prefix, name:"prefix", parent: name, max: 255)
            try validate(self.prefix, name:"prefix", parent: name, min: 1)
            try validate(self.regex, name:"regex", parent: name, max: 255)
            try validate(self.regex, name:"regex", parent: name, min: 1)
            try validate(self.suffix, name:"suffix", parent: name, max: 255)
            try validate(self.suffix, name:"suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public struct HealthCheckPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "healthyThreshold", required: true, type: .integer), 
            AWSShapeMember(label: "intervalMillis", required: true, type: .long), 
            AWSShapeMember(label: "path", required: false, type: .string), 
            AWSShapeMember(label: "port", required: false, type: .integer), 
            AWSShapeMember(label: "protocol", required: true, type: .enum), 
            AWSShapeMember(label: "timeoutMillis", required: true, type: .long), 
            AWSShapeMember(label: "unhealthyThreshold", required: true, type: .integer)
        ]

        /// The number of consecutive successful health checks that must occur before declaring
        ///          listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This is required only if the
        ///          specified protocol is HTTP. If the protocol is TCP, this parameter is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined
        ///          in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request.
        public let `protocol`: PortProtocol
        /// The amount of time to wait when receiving a response from the health check, in
        ///          milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a
        ///          virtual node unhealthy. 
        public let unhealthyThreshold: Int

        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: PortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, max: 10)
            try validate(self.healthyThreshold, name:"healthyThreshold", parent: name, min: 2)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, max: 300000)
            try validate(self.intervalMillis, name:"intervalMillis", parent: name, min: 5000)
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, max: 60000)
            try validate(self.timeoutMillis, name:"timeoutMillis", parent: name, min: 2000)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, max: 10)
            try validate(self.unhealthyThreshold, name:"unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "healthyThreshold"
            case intervalMillis = "intervalMillis"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case timeoutMillis = "timeoutMillis"
            case unhealthyThreshold = "unhealthyThreshold"
        }
    }

    public enum HttpMethod: String, CustomStringConvertible, Codable {
        case connect = "CONNECT"
        case delete = "DELETE"
        case get = "GET"
        case head = "HEAD"
        case options = "OPTIONS"
        case patch = "PATCH"
        case post = "POST"
        case put = "PUT"
        case trace = "TRACE"
        public var description: String { return self.rawValue }
    }

    public struct HttpRetryPolicy: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "httpRetryEvents", required: false, type: .list), 
            AWSShapeMember(label: "maxRetries", required: true, type: .long), 
            AWSShapeMember(label: "perRetryTimeout", required: true, type: .structure), 
            AWSShapeMember(label: "tcpRetryEvents", required: false, type: .list)
        ]

        /// Specify at least one of the following values.
        ///          
        ///             
        ///                
        ///                   server-error – HTTP status codes 500, 501,
        ///                502, 503, 504, 505, 506, 507, 508, 510, and 511
        ///             
        ///             
        ///                
        ///                   gateway-error – HTTP status codes 502,
        ///                503, and 504
        ///             
        ///             
        ///                
        ///                   client-error – HTTP status code 409
        ///             
        ///             
        ///                
        ///                   stream-error – Retry on refused
        ///                stream
        ///             
        ///          
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts. If no value is specified, the default is 1.
        public let maxRetries: Int64
        /// An object that represents the retry duration.
        public let perRetryTimeout: Duration
        /// Specify a valid value.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        public init(httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, max: 25)
            try validate(self.httpRetryEvents, name:"httpRetryEvents", parent: name, min: 1)
            try validate(self.maxRetries, name:"maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, max: 1)
            try validate(self.tcpRetryEvents, name:"tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case httpRetryEvents = "httpRetryEvents"
            case maxRetries = "maxRetries"
            case perRetryTimeout = "perRetryTimeout"
            case tcpRetryEvents = "tcpRetryEvents"
        }
    }

    public struct HttpRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "action", required: true, type: .structure), 
            AWSShapeMember(label: "match", required: true, type: .structure), 
            AWSShapeMember(label: "retryPolicy", required: false, type: .structure)
        ]

        /// The action to take if a match is determined.
        public let action: HttpRouteAction
        /// The criteria for determining an HTTP request match.
        public let match: HttpRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: HttpRetryPolicy?

        public init(action: HttpRouteAction, match: HttpRouteMatch, retryPolicy: HttpRetryPolicy? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case retryPolicy = "retryPolicy"
        }
    }

    public struct HttpRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "weightedTargets", required: true, type: .list)
        ]

        /// The targets that traffic is routed to when a request matches the route. You can specify
        ///          one or more targets and their relative weights to distribute traffic with.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct HttpRouteHeader: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "invert", required: false, type: .boolean), 
            AWSShapeMember(label: "match", required: false, type: .structure), 
            AWSShapeMember(label: "name", required: true, type: .string)
        ]

        /// Specify True to match the opposite of the HeaderMatchMethod method and value. The default value is False.
        public let invert: Bool?
        /// The HeaderMatchMethod object.
        public let match: HeaderMatchMethod?
        /// A name for the HTTP header in the client request that will be matched on.
        public let name: String

        public init(invert: Bool? = nil, match: HeaderMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try validate(self.name, name:"name", parent: name, max: 50)
            try validate(self.name, name:"name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct HttpRouteMatch: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "headers", required: false, type: .list), 
            AWSShapeMember(label: "method", required: false, type: .enum), 
            AWSShapeMember(label: "prefix", required: true, type: .string), 
            AWSShapeMember(label: "scheme", required: false, type: .enum)
        ]

        /// The client request headers to match on.
        public let headers: [HttpRouteHeader]?
        /// The client request header method to match on.
        public let method: HttpMethod?
        /// Specifies the path to match requests with. This parameter must always start with
        ///             /, which by itself matches all requests to the virtual service name. You
        ///          can also match for path-based routing of requests. For example, if your virtual service
        ///          name is my-service.local and you want the route to match requests to
        ///             my-service.local/metrics, your prefix should be
        ///          /metrics.
        public let prefix: String
        /// The client request header scheme to match on.
        public let scheme: HttpScheme?

        public init(headers: [HttpRouteHeader]? = nil, method: HttpMethod? = nil, prefix: String, scheme: HttpScheme? = nil) {
            self.headers = headers
            self.method = method
            self.prefix = prefix
            self.scheme = scheme
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try validate(self.headers, name:"headers", parent: name, max: 10)
            try validate(self.headers, name:"headers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers = "headers"
            case method = "method"
            case prefix = "prefix"
            case scheme = "scheme"
        }
    }

    public enum HttpScheme: String, CustomStringConvertible, Codable {
        case http = "http"
        case https = "https"
        public var description: String { return self.rawValue }
    }

    public struct ListMeshesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListMeshes in paginated output.
        ///          When you use this parameter, ListMeshes returns only limit
        ///          results in a single page along with a nextToken response element. You can see
        ///          the remaining results of the initial request by sending another ListMeshes
        ///          request with the returned nextToken value. This value can be between
        ///          1 and 100. If you don't use this parameter,
        ///             ListMeshes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated
        ///             ListMeshes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value. 
        ///          
        ///             This token should be treated as an opaque identifier that is used only to
        ///                 retrieve the next items in a list and not for other programmatic purposes.
        ///         
        public let nextToken: String?

        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case nextToken = "nextToken"
        }
    }

    public struct ListMeshesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshes", required: true, type: .list), 
            AWSShapeMember(label: "nextToken", required: false, type: .string)
        ]

        /// The list of existing service meshes.
        public let meshes: [MeshRef]
        /// The nextToken value to include in a future ListMeshes request.
        ///          When the results of a ListMeshes request exceed limit, you can
        ///          use this value to retrieve the next page of results. This value is null when
        ///          there are no more results to return.
        public let nextToken: String?

        public init(meshes: [MeshRef], nextToken: String? = nil) {
            self.meshes = meshes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshes = "meshes"
            case nextToken = "nextToken"
        }
    }

    public struct ListRoutesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// The maximum number of results returned by ListRoutes in paginated output.
        ///          When you use this parameter, ListRoutes returns only limit
        ///          results in a single page along with a nextToken response element. You can see
        ///          the remaining results of the initial request by sending another ListRoutes
        ///          request with the returned nextToken value. This value can be between
        ///          1 and 100. If you don't use this parameter,
        ///             ListRoutes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list routes in.
        public let meshName: String
        /// The nextToken value returned from a previous paginated
        ///             ListRoutes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual router to list routes in.
        public let virtualRouterName: String

        public init(limit: Int? = nil, meshName: String, nextToken: String? = nil, virtualRouterName: String) {
            self.limit = limit
            self.meshName = meshName
            self.nextToken = nextToken
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case nextToken = "nextToken"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct ListRoutesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "routes", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListRoutes request.
        ///          When the results of a ListRoutes request exceed limit, you can
        ///          use this value to retrieve the next page of results. This value is null when
        ///          there are no more results to return.
        public let nextToken: String?
        /// The list of existing routes for the specified service mesh and virtual router.
        public let routes: [RouteRef]

        public init(nextToken: String? = nil, routes: [RouteRef]) {
            self.nextToken = nextToken
            self.routes = routes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case routes = "routes"
        }
    }

    public struct ListTagsForResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string), 
            AWSShapeMember(label: "resourceArn", location: .querystring(locationName: "resourceArn"), required: true, type: .string)
        ]

        /// The maximum number of tag results returned by ListTagsForResource in
        ///          paginated output. When this parameter is used, ListTagsForResource returns
        ///          only limit results in a single page along with a nextToken
        ///          response element. You can see the remaining results of the initial request by sending
        ///          another ListTagsForResource request with the returned nextToken
        ///          value. This value can be between 1 and 100. If you don't use
        ///          this parameter, ListTagsForResource returns up to 100
        ///          results and a nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated
        ///             ListTagsForResource request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
        public let resourceArn: String

        public init(limit: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 50)
            try validate(self.limit, name:"limit", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case nextToken = "nextToken"
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListTagsForResource
        ///          request. When the results of a ListTagsForResource request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The tags for the resource.
        public let tags: [TagRef]

        public init(nextToken: String? = nil, tags: [TagRef]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct ListVirtualNodesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListVirtualNodes in paginated
        ///          output. When you use this parameter, ListVirtualNodes returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualNodes request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualNodes returns up to 100 results and a
        ///             nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual nodes in.
        public let meshName: String
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualNodes request where limit was used and the results
        ///          exceeded the value of that parameter. Pagination continues from the end of the previous
        ///          results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualNodesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualNodes", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListVirtualNodes
        ///          request. When the results of a ListVirtualNodes request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual nodes for the specified service mesh.
        public let virtualNodes: [VirtualNodeRef]

        public init(nextToken: String? = nil, virtualNodes: [VirtualNodeRef]) {
            self.nextToken = nextToken
            self.virtualNodes = virtualNodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualNodes = "virtualNodes"
        }
    }

    public struct ListVirtualRoutersInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListVirtualRouters in paginated
        ///          output. When you use this parameter, ListVirtualRouters returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualRouters request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualRouters returns up to 100 results and
        ///          a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual routers in.
        public let meshName: String
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualRouters request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualRoutersOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualRouters", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListVirtualRouters
        ///          request. When the results of a ListVirtualRouters request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual routers for the specified service mesh.
        public let virtualRouters: [VirtualRouterRef]

        public init(nextToken: String? = nil, virtualRouters: [VirtualRouterRef]) {
            self.nextToken = nextToken
            self.virtualRouters = virtualRouters
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualRouters = "virtualRouters"
        }
    }

    public struct ListVirtualServicesInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "limit", location: .querystring(locationName: "limit"), required: false, type: .integer), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "nextToken", location: .querystring(locationName: "nextToken"), required: false, type: .string)
        ]

        /// The maximum number of results returned by ListVirtualServices in paginated
        ///          output. When you use this parameter, ListVirtualServices returns only
        ///             limit results in a single page along with a nextToken response
        ///          element. You can see the remaining results of the initial request by sending another
        ///             ListVirtualServices request with the returned nextToken value.
        ///          This value can be between 1 and 100. If you don't use this
        ///          parameter, ListVirtualServices returns up to 100 results and
        ///          a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual services in.
        public let meshName: String
        /// The nextToken value returned from a previous paginated
        ///             ListVirtualServices request where limit was used and the
        ///          results exceeded the value of that parameter. Pagination continues from the end of the
        ///          previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try validate(self.limit, name:"limit", parent: name, max: 100)
            try validate(self.limit, name:"limit", parent: name, min: 1)
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case limit = "limit"
            case meshName = "meshName"
            case nextToken = "nextToken"
        }
    }

    public struct ListVirtualServicesOutput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "nextToken", required: false, type: .string), 
            AWSShapeMember(label: "virtualServices", required: true, type: .list)
        ]

        /// The nextToken value to include in a future ListVirtualServices
        ///          request. When the results of a ListVirtualServices request exceed
        ///             limit, you can use this value to retrieve the next page of results. This
        ///          value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual services for the specified service mesh.
        public let virtualServices: [VirtualServiceRef]

        public init(nextToken: String? = nil, virtualServices: [VirtualServiceRef]) {
            self.nextToken = nextToken
            self.virtualServices = virtualServices
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualServices = "virtualServices"
        }
    }

    public struct Listener: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "healthCheck", required: false, type: .structure), 
            AWSShapeMember(label: "portMapping", required: true, type: .structure)
        ]

        /// The health check information for the listener.
        public let healthCheck: HealthCheckPolicy?
        /// The port mapping information for the listener.
        public let portMapping: PortMapping

        public init(healthCheck: HealthCheckPolicy? = nil, portMapping: PortMapping) {
            self.healthCheck = healthCheck
            self.portMapping = portMapping
        }

        public func validate(name: String) throws {
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.portMapping.validate(name: "\(name).portMapping")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
            case portMapping = "portMapping"
        }
    }

    public struct Logging: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "accessLog", required: false, type: .structure)
        ]

        /// The access log configuration for a virtual node.
        public let accessLog: AccessLog?

        public init(accessLog: AccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "accessLog"
        }
    }

    public struct MatchRange: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "end", required: true, type: .long), 
            AWSShapeMember(label: "start", required: true, type: .long)
        ]

        /// The end of the range.
        public let end: Int64
        /// The start of the range.
        public let start: Int64

        public init(end: Int64, start: Int64) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct MeshData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure)
        ]

        /// The name of the service mesh.
        public let meshName: String
        /// The associated metadata for the service mesh.
        public let metadata: ResourceMetadata
        /// The associated specification for the service mesh.
        public let spec: MeshSpec
        /// The status of the service mesh.
        public let status: MeshStatus

        public init(meshName: String, metadata: ResourceMetadata, spec: MeshSpec, status: MeshStatus) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
        }
    }

    public struct MeshRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) of the service mesh.
        public let arn: String
        /// The name of the service mesh.
        public let meshName: String

        public init(arn: String, meshName: String) {
            self.arn = arn
            self.meshName = meshName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
        }
    }

    public struct MeshSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "egressFilter", required: false, type: .structure)
        ]

        /// The egress filter rules for the service mesh.
        public let egressFilter: EgressFilter?

        public init(egressFilter: EgressFilter? = nil) {
            self.egressFilter = egressFilter
        }

        private enum CodingKeys: String, CodingKey {
            case egressFilter = "egressFilter"
        }
    }

    public struct MeshStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: false, type: .enum)
        ]

        /// The current mesh status.
        public let status: MeshStatusCode?

        public init(status: MeshStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public enum MeshStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct PortMapping: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "port", required: true, type: .integer), 
            AWSShapeMember(label: "protocol", required: true, type: .enum)
        ]

        /// The port used for the port mapping.
        public let port: Int
        /// The protocol used for the port mapping.
        public let `protocol`: PortProtocol

        public init(port: Int, protocol: PortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try validate(self.port, name:"port", parent: name, max: 65535)
            try validate(self.port, name:"port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public enum PortProtocol: String, CustomStringConvertible, Codable {
        case http = "http"
        case tcp = "tcp"
        public var description: String { return self.rawValue }
    }

    public struct ResourceMetadata: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "createdAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "lastUpdatedAt", required: true, type: .timestamp), 
            AWSShapeMember(label: "uid", required: true, type: .string), 
            AWSShapeMember(label: "version", required: true, type: .long)
        ]

        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: TimeStamp
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: TimeStamp
        /// The unique identifier for the resource.
        public let uid: String
        /// The version of the resource. Resources are created at version 1, and this version is
        ///          incremented each time that they're updated.
        public let version: Int64

        public init(arn: String, createdAt: TimeStamp, lastUpdatedAt: TimeStamp, uid: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.uid = uid
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case uid = "uid"
            case version = "version"
        }
    }

    public struct RouteData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The associated metadata for the route.
        public let metadata: ResourceMetadata
        /// The name of the route.
        public let routeName: String
        /// The specifications of the route.
        public let spec: RouteSpec
        /// The status of the route.
        public let status: RouteStatus
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, routeName: String, spec: RouteSpec, status: RouteStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.routeName = routeName
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case routeName = "routeName"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "routeName", required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the route.
        public let arn: String
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The name of the route.
        public let routeName: String
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(arn: String, meshName: String, routeName: String, virtualRouterName: String) {
            self.arn = arn
            self.meshName = meshName
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case routeName = "routeName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "httpRoute", required: false, type: .structure), 
            AWSShapeMember(label: "priority", required: false, type: .integer), 
            AWSShapeMember(label: "tcpRoute", required: false, type: .structure)
        ]

        /// The HTTP routing information for the route.
        public let httpRoute: HttpRoute?
        /// The priority for the route. Routes are matched based on the specified value, where 0 is the highest priority.
        public let priority: Int?
        /// The TCP routing information for the route.
        public let tcpRoute: TcpRoute?

        public init(httpRoute: HttpRoute? = nil, priority: Int? = nil, tcpRoute: TcpRoute? = nil) {
            self.httpRoute = httpRoute
            self.priority = priority
            self.tcpRoute = tcpRoute
        }

        public func validate(name: String) throws {
            try self.httpRoute?.validate(name: "\(name).httpRoute")
            try validate(self.priority, name:"priority", parent: name, max: 1000)
            try validate(self.priority, name:"priority", parent: name, min: 0)
            try self.tcpRoute?.validate(name: "\(name).tcpRoute")
        }

        private enum CodingKeys: String, CodingKey {
            case httpRoute = "httpRoute"
            case priority = "priority"
            case tcpRoute = "tcpRoute"
        }
    }

    public struct RouteStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status for the route.
        public let status: RouteStatusCode

        public init(status: RouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public enum RouteStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct ServiceDiscovery: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "awsCloudMap", required: false, type: .structure), 
            AWSShapeMember(label: "dns", required: false, type: .structure)
        ]

        /// Specifies any AWS Cloud Map information for the virtual node.
        public let awsCloudMap: AwsCloudMapServiceDiscovery?
        /// Specifies the DNS information for the virtual node.
        public let dns: DnsServiceDiscovery?

        public init(awsCloudMap: AwsCloudMapServiceDiscovery? = nil, dns: DnsServiceDiscovery? = nil) {
            self.awsCloudMap = awsCloudMap
            self.dns = dns
        }

        public func validate(name: String) throws {
            try self.awsCloudMap?.validate(name: "\(name).awsCloudMap")
        }

        private enum CodingKeys: String, CodingKey {
            case awsCloudMap = "awsCloudMap"
            case dns = "dns"
        }
    }

    public struct TagRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "key", required: true, type: .string), 
            AWSShapeMember(label: "value", required: false, type: .string)
        ]

        /// One part of a key-value pair that make up a tag. A key is a general label
        ///          that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that make up a tag. A value acts as a
        ///          descriptor within a tag category (key).
        public let value: String?

        public init(key: String, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try validate(self.key, name:"key", parent: name, max: 128)
            try validate(self.key, name:"key", parent: name, min: 1)
            try validate(self.value, name:"value", parent: name, max: 256)
            try validate(self.value, name:"value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .querystring(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tags", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) of the resource to add tags to.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs.
        ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
        ///             a maximum length of 256 characters.
        public let tags: [TagRef]

        public init(resourceArn: String, tags: [TagRef]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try validate(self.tags, name:"tags", parent: name, max: 50)
            try validate(self.tags, name:"tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSShape {


        public init() {
        }

    }

    public enum TcpRetryPolicyEvent: String, CustomStringConvertible, Codable {
        case connectionError = "connection-error"
        public var description: String { return self.rawValue }
    }

    public struct TcpRoute: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "action", required: true, type: .structure)
        ]

        /// The action to take if a match is determined.
        public let action: TcpRouteAction

        public init(action: TcpRouteAction) {
            self.action = action
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
        }
    }

    public struct TcpRouteAction: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "weightedTargets", required: true, type: .list)
        ]

        /// The targets that traffic is routed to when a request matches the route. You can specify
        ///          one or more targets and their relative weights to distribute traffic with.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, max: 10)
            try validate(self.weightedTargets, name:"weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct UntagResourceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "resourceArn", location: .querystring(locationName: "resourceArn"), required: true, type: .string), 
            AWSShapeMember(label: "tagKeys", required: true, type: .list)
        ]

        /// The Amazon Resource Name (ARN) of the resource to delete tags from.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try validate(self.tagKeys, name:"tagKeys", parent: name, max: 50)
            try validate(self.tagKeys, name:"tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceOutput: AWSShape {


        public init() {
        }

    }

    public struct UpdateMeshInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: false, type: .structure)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to update.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?

        public init(clientToken: String? = UpdateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
        }
    }

    public struct UpdateMeshOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "mesh"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "mesh", required: true, type: .structure)
        ]

        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh = "mesh"
        }
    }

    public struct UpdateRouteInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "routeName", location: .uri(locationName: "routeName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The name of the route to update.
        public let routeName: String
        /// The new route specification to apply. This overwrites the existing data.
        public let spec: RouteSpec
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateRouteInput.idempotencyToken(), meshName: String, routeName: String, spec: RouteSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.routeName = routeName
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try validate(self.routeName, name:"routeName", parent: name, max: 255)
            try validate(self.routeName, name:"routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case routeName = "routeName"
            case spec = "spec"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct UpdateRouteOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "route"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "route", required: true, type: .structure)
        ]

        /// A full description of the route that was updated.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route = "route"
        }
    }

    public struct UpdateVirtualNodeInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The new virtual node specification to apply. This overwrites the existing data.
        public let spec: VirtualNodeSpec
        /// The name of the virtual node to update.
        public let virtualNodeName: String

        public init(clientToken: String? = UpdateVirtualNodeInput.idempotencyToken(), meshName: String, spec: VirtualNodeSpec, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct UpdateVirtualNodeOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualNode"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .structure)
        ]

        /// A full description of the virtual node that was updated.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
        }
    }

    public struct UpdateVirtualRouterInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The new virtual router specification to apply. This overwrites the existing data.
        public let spec: VirtualRouterSpec
        /// The name of the virtual router to update.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateVirtualRouterInput.idempotencyToken(), meshName: String, spec: VirtualRouterSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct UpdateVirtualRouterOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualRouter"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouter", required: true, type: .structure)
        ]

        /// A full description of the virtual router that was updated.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter = "virtualRouter"
        }
    }

    public struct UpdateVirtualServiceInput: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "clientToken", required: false, type: .string), 
            AWSShapeMember(label: "meshName", location: .uri(locationName: "meshName"), required: true, type: .string), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"), required: true, type: .string)
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The new virtual service specification to apply. This overwrites the existing
        ///          data.
        public let spec: VirtualServiceSpec
        /// The name of the virtual service to update.
        public let virtualServiceName: String

        public init(clientToken: String? = UpdateVirtualServiceInput.idempotencyToken(), meshName: String, spec: VirtualServiceSpec, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try validate(self.meshName, name:"meshName", parent: name, max: 255)
            try validate(self.meshName, name:"meshName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct UpdateVirtualServiceOutput: AWSShape {
        /// The key for the payload
        public static let payloadPath: String? = "virtualService"
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualService", required: true, type: .structure)
        ]

        /// A full description of the virtual service that was updated.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct VirtualNodeData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The associated metadata for the virtual node.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual node.
        public let spec: VirtualNodeSpec
        /// The current status for the virtual node.
        public let status: VirtualNodeStatus
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualNodeSpec, status: VirtualNodeStatus, virtualNodeName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the virtual node.
        public let arn: String
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(arn: String, meshName: String, virtualNodeName: String) {
            self.arn = arn
            self.meshName = meshName
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeServiceProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNodeName", required: true, type: .string)
        ]

        /// The name of the virtual node that is acting as a service provider.
        public let virtualNodeName: String

        public init(virtualNodeName: String) {
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, max: 255)
            try validate(self.virtualNodeName, name:"virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "backends", required: false, type: .list), 
            AWSShapeMember(label: "listeners", required: false, type: .list), 
            AWSShapeMember(label: "logging", required: false, type: .structure), 
            AWSShapeMember(label: "serviceDiscovery", required: false, type: .structure)
        ]

        /// The backends that the virtual node is expected to send outbound traffic to.
        public let backends: [Backend]?
        /// The listeners that the virtual node is expected to receive inbound traffic from.
        ///          Currently only one listener is supported per virtual node.
        public let listeners: [Listener]?
        /// The inbound and outbound access logging information for the virtual node.
        public let logging: Logging?
        /// The service discovery information for the virtual node. If your virtual node does not
        ///          expect ingress traffic, you can omit this parameter.
        public let serviceDiscovery: ServiceDiscovery?

        public init(backends: [Backend]? = nil, listeners: [Listener]? = nil, logging: Logging? = nil, serviceDiscovery: ServiceDiscovery? = nil) {
            self.backends = backends
            self.listeners = listeners
            self.logging = logging
            self.serviceDiscovery = serviceDiscovery
        }

        public func validate(name: String) throws {
            try validate(self.backends, name:"backends", parent: name, max: 25)
            try validate(self.backends, name:"backends", parent: name, min: 0)
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try validate(self.listeners, name:"listeners", parent: name, max: 1)
            try validate(self.listeners, name:"listeners", parent: name, min: 0)
            try self.logging?.validate(name: "\(name).logging")
            try self.serviceDiscovery?.validate(name: "\(name).serviceDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case backends = "backends"
            case listeners = "listeners"
            case logging = "logging"
            case serviceDiscovery = "serviceDiscovery"
        }
    }

    public struct VirtualNodeStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status of the virtual node.
        public let status: VirtualNodeStatusCode

        public init(status: VirtualNodeStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public enum VirtualNodeStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct VirtualRouterData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The associated metadata for the virtual router.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual router.
        public let spec: VirtualRouterSpec
        /// The current status of the virtual router.
        public let status: VirtualRouterStatus
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualRouterSpec, status: VirtualRouterStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterListener: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "portMapping", required: true, type: .structure)
        ]

        public let portMapping: PortMapping

        public init(portMapping: PortMapping) {
            self.portMapping = portMapping
        }

        public func validate(name: String) throws {
            try self.portMapping.validate(name: "\(name).portMapping")
        }

        private enum CodingKeys: String, CodingKey {
            case portMapping = "portMapping"
        }
    }

    public struct VirtualRouterRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the virtual router.
        public let arn: String
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(arn: String, meshName: String, virtualRouterName: String) {
            self.arn = arn
            self.meshName = meshName
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterServiceProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualRouterName", required: true, type: .string)
        ]

        /// The name of the virtual router that is acting as a service provider.
        public let virtualRouterName: String

        public init(virtualRouterName: String) {
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, max: 255)
            try validate(self.virtualRouterName, name:"virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "listeners", required: false, type: .list)
        ]

        /// The listeners that the virtual router is expected to receive inbound traffic from.
        ///          Currently only one listener is supported per virtual router.
        public let listeners: [VirtualRouterListener]?

        public init(listeners: [VirtualRouterListener]? = nil) {
            self.listeners = listeners
        }

        public func validate(name: String) throws {
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try validate(self.listeners, name:"listeners", parent: name, max: 1)
            try validate(self.listeners, name:"listeners", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "listeners"
        }
    }

    public struct VirtualRouterStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status of the virtual router.
        public let status: VirtualRouterStatusCode

        public init(status: VirtualRouterStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public enum VirtualRouterStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct VirtualServiceBackend: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// The name of the virtual service that is acting as a virtual node backend.
        public let virtualServiceName: String

        public init(virtualServiceName: String) {
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceData: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "metadata", required: true, type: .structure), 
            AWSShapeMember(label: "spec", required: true, type: .structure), 
            AWSShapeMember(label: "status", required: true, type: .structure), 
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual service.
        public let spec: VirtualServiceSpec
        /// The current status of the virtual service.
        public let status: VirtualServiceStatus
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualServiceSpec, status: VirtualServiceStatus, virtualServiceName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceProvider: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: false, type: .structure), 
            AWSShapeMember(label: "virtualRouter", required: false, type: .structure)
        ]

        /// The virtual node associated with a virtual service.
        public let virtualNode: VirtualNodeServiceProvider?
        /// The virtual router associated with a virtual service.
        public let virtualRouter: VirtualRouterServiceProvider?

        public init(virtualNode: VirtualNodeServiceProvider? = nil, virtualRouter: VirtualRouterServiceProvider? = nil) {
            self.virtualNode = virtualNode
            self.virtualRouter = virtualRouter
        }

        public func validate(name: String) throws {
            try self.virtualNode?.validate(name: "\(name).virtualNode")
            try self.virtualRouter?.validate(name: "\(name).virtualRouter")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case virtualRouter = "virtualRouter"
        }
    }

    public struct VirtualServiceRef: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "arn", required: true, type: .string), 
            AWSShapeMember(label: "meshName", required: true, type: .string), 
            AWSShapeMember(label: "virtualServiceName", required: true, type: .string)
        ]

        /// The full Amazon Resource Name (ARN) for the virtual service.
        public let arn: String
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(arn: String, meshName: String, virtualServiceName: String) {
            self.arn = arn
            self.meshName = meshName
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case meshName = "meshName"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceSpec: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "provider", required: false, type: .structure)
        ]

        /// The App Mesh object that is acting as the provider for a virtual service. You can specify
        ///          a single virtual node or virtual router.
        public let provider: VirtualServiceProvider?

        public init(provider: VirtualServiceProvider? = nil) {
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.provider?.validate(name: "\(name).provider")
        }

        private enum CodingKeys: String, CodingKey {
            case provider = "provider"
        }
    }

    public struct VirtualServiceStatus: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "status", required: true, type: .enum)
        ]

        /// The current status of the virtual service.
        public let status: VirtualServiceStatusCode

        public init(status: VirtualServiceStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public enum VirtualServiceStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public struct WeightedTarget: AWSShape {
        public static var _members: [AWSShapeMember] = [
            AWSShapeMember(label: "virtualNode", required: true, type: .string), 
            AWSShapeMember(label: "weight", required: true, type: .integer)
        ]

        /// The virtual node to associate with the weighted target.
        public let virtualNode: String
        /// The relative weight of the weighted target.
        public let weight: Int

        public init(virtualNode: String, weight: Int) {
            self.virtualNode = virtualNode
            self.weight = weight
        }

        public func validate(name: String) throws {
            try validate(self.virtualNode, name:"virtualNode", parent: name, max: 255)
            try validate(self.virtualNode, name:"virtualNode", parent: name, min: 1)
            try validate(self.weight, name:"weight", parent: name, max: 100)
            try validate(self.weight, name:"weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case weight = "weight"
        }
    }
}
